---
Status: REFERENCE
Created: 2026-01-15
Updated: 2026-01-27
Purpose: Structure primitives specification (⊙, ⊚, ⊝)
---

# Data Structures as First-Class Citizens

## Philosophy

In Guage, **data structures are first-class values** that can be:
- Created at runtime
- Passed to functions
- Returned from functions
- Pattern matched
- Introspected and analyzed
- Auto-generated by the compiler

This includes not just user-defined structures, but also **compiler-generated metadata** like CFG, DFG, call graphs, and dependency graphs.

## Core Principle: Everything is Queryable

```scheme
; Define a function
(≔ ! (λ (n) (? (≡ n #0) #1 (⊗ n (! (⊖ n #1))))))

; Its CFG is a first-class value you can query
(≔ cfg (⌂⟿ (⌜ !)))

; Query the graph like any other data structure
(⊝→ cfg :entry)        ; Get entry node
(⊝→ cfg :nodes)        ; Get all nodes
(⊝→ cfg :exit)         ; Get exit node

; Pattern match on it
(∇ cfg
  [(:CFG entry nodes edges exit)
   (⊙→ entry :label)])  ; Extract entry node label
```

## Three Kinds of Structures

### 1. ⊙ Leaf Structures (Simple Data)

**Non-recursive** structures with primitive fields.

```scheme
; Define a Point structure
(⊙≔ Point :x :y)

; Create instances
(≔ p1 (⊙ Point #3 #4))
(≔ p2 (⊙ Point #0 #0))

; Access fields
(⊙→ p1 :x)           ; → #3
(⊙→ p1 :y)           ; → #4

; Check type
(⊙? p1 Point)        ; → #t

; Pattern match
(∇ p1
  [(:Point x y) (⊕ (⊗ x x) (⊗ y y))])  ; → #25 (distance²)
```

**Primitives:**
```scheme
⊙≔  ; (⊙≔ name field₁ field₂ ...) - Define leaf structure
⊙   ; (⊙ type val₁ val₂ ...) - Create instance
⊙→  ; (⊙→ struct field) - Get field value
⊙←  ; (⊙← struct field value) - Set field (returns new struct)
⊙?  ; (⊙? value type) - Check if value is of type
```

### 2. ⊚ Node Structures (Recursive Data)

**Self-referential** structures for trees, lists, etc.

```scheme
; Define a List structure
(⊚≔ List
  [:Nil]                    ; Empty case
  [:Cons :head :tail])      ; Recursive case

; Create instances
(≔ empty (⊚ List :Nil))
(≔ lst (⊚ List :Cons #1 (⊚ List :Cons #2 (⊚ List :Nil))))

; Pattern match (destructure)
(≔ length (λ (l)
  (∇ l
    [(:List :Nil) #0]
    [(:List :Cons _ tail) (⊕ #1 (length tail))])))

; Define a Tree structure
(⊚≔ Tree
  [:Leaf :value]
  [:Node :left :value :right])

; Create tree
(≔ tree (⊚ Tree :Node
  (⊚ Tree :Leaf #1)
  #2
  (⊚ Tree :Leaf #3)))

; Pattern match on tree
(≔ depth (λ (t)
  (∇ t
    [(:Tree :Leaf _) #1]
    [(:Tree :Node l _ r)
     (⊕ #1 (max (depth l) (depth r)))])))
```

**Primitives:**
```scheme
⊚≔  ; (⊚≔ name [:variant₁ fields...] [:variant₂ fields...]) - Define ADT
⊚   ; (⊚ type :variant val₁ val₂ ...) - Create instance
⊚→  ; (⊚→ struct field) - Get field value
⊚?  ; (⊚? value type variant) - Check type and variant
```

### 3. ⊝ Graph Structures (Cyclical Data)

**Graph-based** structures with nodes and edges.

```scheme
; Define a Graph structure
(⊝≔ Graph :nodes :edges)

; Create empty graph
(≔ g (⊝ Graph ∅ ∅))

; Add nodes
(≔ g (⊝⊕ g (⊙ Node #0 :data)))
(≔ g (⊝⊕ g (⊙ Node #1 :data)))

; Add edges
(≔ g (⊝⊗ g #0 #1 :edge-label))

; Query graph
(⊝→ g :nodes)              ; Get all nodes
(⊝→ g :edges)              ; Get all edges
(⊝→ g :neighbors #0)       ; Get neighbors of node 0

; Pattern match on graph structure
(∇ g
  [(:Graph nodes edges)
   (length nodes)])
```

**Primitives:**
```scheme
⊝≔  ; (⊝≔ name field₁ field₂ ...) - Define graph structure type
⊝   ; (⊝ type nodes edges metadata) - Create graph
⊝⊕  ; (⊝⊕ graph node) - Add node to graph
⊝⊗  ; (⊝⊗ graph from to label) - Add edge to graph
⊝→  ; (⊝→ graph query) - Query graph (nodes, edges, neighbors, etc)
⊝∇  ; (⊝∇ graph pattern) - Pattern match in graph
⊝?  ; (⊝? value type) - Check if value is graph of type
```

## Auto-Generated Graph Structures

The compiler automatically generates four graph types for every user-defined function:

### 1. ⌂⟿ Control Flow Graph (CFG)

**Represents:** All possible execution paths through code.

**Structure:**
```scheme
(⊝≔ CFG
  :entry     ; Entry basic block
  :exit      ; Exit basic block
  :nodes     ; List of basic blocks
  :edges     ; List of control flow edges
  :metadata) ; Additional info
```

**Basic Block:**
```scheme
(⊙≔ BasicBlock
  :id        ; Unique identifier
  :label     ; Human-readable label
  :ops       ; List of operations in block
  :type)     ; :entry, :exit, :branch, :merge, :loop
```

**CFG Edge:**
```scheme
(⊙≔ CFGEdge
  :from      ; Source block ID
  :to        ; Target block ID
  :type      ; :unconditional, :true, :false, :call, :return
  :label)    ; Edge label (condition, etc)
```

**Example: Factorial CFG**
```scheme
(≔ ! (λ (n) (? (≡ n #0) #1 (⊗ n (! (⊖ n #1))))))

(≔ cfg (⌂⟿ (⌜ !)))

; Query CFG structure
(⊝→ cfg :entry)        ; → BasicBlock #0
(⊝→ cfg :nodes)        ; → List of 4 blocks
(⊝→ cfg :edges)        ; → List of 5 edges

; Visualize (conceptual)
; [entry] → [test: ≡ n #0]
;            ↓true        ↓false
;         [ret #1]    [⊗ n (rec)]
;                        ↓
;                     [exit]
```

**What CFG enables:**
- Dead code detection
- Unreachable code analysis
- Loop detection
- Dominator analysis
- Optimization opportunities

### 2. ⌂⇝ Data Flow Graph (DFG)

**Represents:** How data flows through the computation.

**Structure:**
```scheme
(⊝≔ DFG
  :inputs    ; Input parameters
  :outputs   ; Output values
  :nodes     ; Operations
  :edges     ; Data dependencies
  :metadata)
```

**DFG Node:**
```scheme
(⊙≔ DFGNode
  :id        ; Unique identifier
  :op        ; Operation (⊕, ⊗, ?, λ, etc)
  :type      ; Inferred type
  :value)    ; Constant value (if known)
```

**DFG Edge:**
```scheme
(⊙≔ DFGEdge
  :from      ; Producer node ID
  :to        ; Consumer node ID
  :port      ; Which input port (0, 1, 2...)
  :type)     ; Data type flowing through edge
```

**Example: Factorial DFG**
```scheme
(≔ dfg (⌂⇝ (⌜ !)))

; Query DFG structure
(⊝→ dfg :inputs)       ; → [n]
(⊝→ dfg :outputs)      ; → [result]
(⊝→ dfg :nodes)        ; → List of operations

; Data flow (conceptual)
; n → [≡ with #0] → [? condition]
; n → [⊖ with #1] → [! recursive] → [⊗ with n] → result
```

**What DFG enables:**
- Constant folding
- Common subexpression elimination
- Dead value elimination
- Value numbering
- Dependency analysis

### 3. ⌂⊚ Call Graph

**Represents:** Function call relationships.

**Structure:**
```scheme
(⊝≔ CallGraph
  :functions ; List of function nodes
  :calls     ; Call edges
  :recursive ; Recursive call cycles
  :metadata)
```

**Function Node:**
```scheme
(⊙≔ FunctionNode
  :name      ; Function name symbol
  :arity     ; Number of parameters
  :type      ; Type signature (if known)
  :recursive); Is this function recursive?
```

**Call Edge:**
```scheme
(⊙≔ CallEdge
  :caller    ; Calling function
  :callee    ; Called function
  :location  ; Where in caller (line/col)
  :type)     ; :direct, :indirect, :recursive
```

**Example: Factorial Call Graph**
```scheme
(≔ cg (⌂⊚ (⌜ !)))

; Query call graph
(⊝→ cg :functions)     ; → [!]
(⊝→ cg :calls)         ; → [! → !] (recursive)
(⊝→ cg :recursive)     ; → #t

; If we had helper functions:
(≔ ! (λ (n) (⊗ n (dec-and-recurse n))))
(≔ dec-and-recurse (λ (n) (! (⊖ n #1))))

(≔ cg (⌂⊚ (⌜ !)))
(⊝→ cg :functions)     ; → [!, dec-and-recurse]
(⊝→ cg :calls)         ; → [! → dec-and-recurse,
                       ;     dec-and-recurse → !]
(⊝→ cg :recursive)     ; → #t (mutual recursion)
```

**What Call Graph enables:**
- Inlining decisions
- Recursion detection
- Call stack prediction
- Optimization ordering
- Dead function elimination

### 4. ⌂⊙ Dependency Graph

**Represents:** Symbol dependencies between definitions.

**Structure:**
```scheme
(⊝≔ DepGraph
  :symbols   ; Definition nodes
  :depends   ; Dependency edges
  :order     ; Topological sort (compilation order)
  :cycles)   ; Circular dependencies (errors)
```

**Symbol Node:**
```scheme
(⊙≔ SymbolNode
  :name      ; Symbol name
  :type      ; :function, :constant, :macro, etc
  :defined   ; Definition location
  :used)     ; List of use locations
```

**Dependency Edge:**
```scheme
(⊙≔ DepEdge
  :from      ; Dependent symbol
  :to        ; Required symbol
  :type)     ; :calls, :uses-value, :uses-type
```

**Example: Factorial Dependency Graph**
```scheme
(≔ dg (⌂⊙ (⌜ !)))

; Query dependency graph
(⊝→ dg :symbols)       ; → [!]
(⊝→ dg :depends)       ; → [! → ?, ! → ≡, ! → ⊗, ! → ⊖, ! → !]
(⊝→ dg :order)         ; → [?, ≡, ⊗, ⊖, !] (compile order)

; Complex example with multiple functions
(≔ even? (λ (n) (? (≡ n #0) #t (odd? (⊖ n #1)))))
(≔ odd? (λ (n) (? (≡ n #0) #f (even? (⊖ n #1)))))

(≔ dg (⌂⊙ (⌜ even?)))
(⊝→ dg :cycles)        ; → [[even? → odd? → even?]]
```

**What Dependency Graph enables:**
- Compilation order determination
- Circular dependency detection
- Module boundary analysis
- Incremental compilation
- Code organization

## Auto-Generation Semantics

### When Graphs Are Generated

Graphs are automatically created when a function is **defined**:

```scheme
(≔ ! (λ (n) (? (≡ n #0) #1 (⊗ n (! (⊖ n #1))))))

; Compiler automatically:
; 1. Generates CFG and stores it
; 2. Generates DFG and stores it
; 3. Generates Call Graph and stores it
; 4. Generates Dep Graph and stores it
; 5. Prints documentation
```

### Lazy vs Eager Generation

**Eager (current plan):**
- All graphs generated at definition time
- Stored in environment metadata
- Ready for immediate query

**Lazy (future optimization):**
- Graphs generated on first query
- Cached for subsequent access
- Reduces memory for unused functions

### Graph Updates

Graphs are **immutable snapshots** of definition time:

```scheme
(≔ f (λ (x) (⊕ x #1)))
(≔ cfg-v1 (⌂⟿ (⌜ f)))

; Redefine function
(≔ f (λ (x) (⊗ x #2)))
(≔ cfg-v2 (⌂⟿ (⌜ f)))

; cfg-v1 ≠ cfg-v2 (different graphs)
(≗ cfg-v1 cfg-v2)      ; → #f
```

## Pattern Matching on Structures

### Simple Structure Patterns

```scheme
; Match leaf structure
(∇ point
  [(:Point x y) (⊕ x y)])

; Match with wildcards
(∇ point
  [(:Point #0 _) :origin-x]
  [(:Point _ #0) :origin-y]
  [(:Point x y) :other])
```

### Recursive Structure Patterns

```scheme
; Match list structure
(∇ lst
  [(:List :Nil) :empty]
  [(:List :Cons h t) (⟨⟩ h (length t))])

; Match tree structure
(∇ tree
  [(:Tree :Leaf v) v]
  [(:Tree :Node l v r) (⊕ v (⊕ (sum l) (sum r)))])

; Nested pattern matching
(∇ tree
  [(:Tree :Node
     (:Tree :Leaf x)
     y
     (:Tree :Leaf z))
   (⊕ x (⊕ y z))])  ; Match specific tree shape
```

### Graph Structure Patterns

```scheme
; Match graph by structure
(∇ cfg
  [(:CFG entry exit nodes edges)
   (length nodes)])

; Match specific graph patterns
(⊝∇ cfg (⟨⟩ :entry → :exit))  ; Direct path?
(⊝∇ cfg :cycle)                ; Has cycle?
(⊝∇ cfg (⟨⟩ :loop _))          ; Has loop?
```

## Implementation Strategy

### Phase 1: Cell Type Extensions (Week 1)

```c
// cell.h additions
typedef enum {
    CELL_NUMBER,
    CELL_BOOL,
    CELL_SYMBOL,
    CELL_PAIR,
    CELL_NIL,
    CELL_LAMBDA,
    // NEW:
    CELL_STRUCT,      // User-defined structures
    CELL_GRAPH,       // Graph structures
    CELL_TYPE         // Type as first-class value
} CellType;

// Structure data
typedef struct {
    Cell* type_tag;       // :Point, :List, :Tree, etc
    Cell* variant;        // :Nil, :Cons, :Leaf, :Node (for ADTs)
    Cell* fields;         // Alist of (field . value)
    StructKind kind;      // LEAF, NODE, GRAPH
} StructData;

// Graph data
typedef struct {
    GraphType graph_type; // CFG, DFG, CALL_GRAPH, DEP_GRAPH
    Cell* nodes;          // List of node cells
    Cell* edges;          // List of edge cells
    Cell* metadata;       // Additional properties
    Cell* entry;          // Entry point (for CFG)
    Cell* exit;           // Exit point (for CFG)
} GraphData;

typedef union {
    int64_t number;
    bool boolean;
    char* symbol;
    struct { Cell* car; Cell* cdr; } pair;
    struct { Cell* params; Cell* body; Cell* env; } lambda;
    StructData structure;     // NEW
    GraphData graph;          // NEW
} CellData;
```

### Phase 2: Structure Primitives (Week 2)

```c
// structure.c - Implementation

// Define structure type
Cell* prim_struct_define_leaf(Cell* name, Cell* fields);
Cell* prim_struct_define_node(Cell* name, Cell* variants);
Cell* prim_struct_define_graph(Cell* name, Cell* fields);

// Create structure instance
Cell* prim_struct_create(Cell* type, Cell* variant, Cell* values);

// Access structure fields
Cell* prim_struct_get(Cell* struct_val, Cell* field);
Cell* prim_struct_set(Cell* struct_val, Cell* field, Cell* value);

// Type checking
Cell* prim_struct_is_type(Cell* value, Cell* type);
Cell* prim_struct_is_variant(Cell* value, Cell* type, Cell* variant);

// Register in primitives.c
register_primitive(env, "⊙≔", prim_struct_define_leaf);
register_primitive(env, "⊚≔", prim_struct_define_node);
register_primitive(env, "⊝≔", prim_struct_define_graph);
register_primitive(env, "⊙", prim_struct_create);
register_primitive(env, "⊙→", prim_struct_get);
register_primitive(env, "⊙←", prim_struct_set);
register_primitive(env, "⊙?", prim_struct_is_type);
```

### Phase 3: Graph Primitives (Week 3)

```c
// graph.c - Implementation

// Graph construction
Cell* prim_graph_create(Cell* type, Cell* nodes, Cell* edges);
Cell* prim_graph_add_node(Cell* graph, Cell* node_data);
Cell* prim_graph_add_edge(Cell* graph, Cell* from, Cell* to, Cell* label);

// Graph queries
Cell* prim_graph_query(Cell* graph, Cell* query);
Cell* prim_graph_pattern_match(Cell* graph, Cell* pattern);

// Register in primitives.c
register_primitive(env, "⊝", prim_graph_create);
register_primitive(env, "⊝⊕", prim_graph_add_node);
register_primitive(env, "⊝⊗", prim_graph_add_edge);
register_primitive(env, "⊝→", prim_graph_query);
register_primitive(env, "⊝∇", prim_graph_pattern_match);
```

### Phase 4: CFG/DFG Generation (Week 4-5)

```c
// cfg.c - Control Flow Graph generation
Cell* generate_cfg(Cell* lambda);
Cell* find_basic_blocks(Cell* body);
Cell* add_control_edges(Cell* blocks, Cell* body);

// dfg.c - Data Flow Graph generation
Cell* generate_dfg(Cell* lambda);
Cell* find_operations(Cell* body);
Cell* add_data_edges(Cell* operations);

// callgraph.c - Call Graph generation
Cell* generate_callgraph(Cell* lambda, Cell* env);
Cell* find_function_calls(Cell* body, Cell* env);

// depgraph.c - Dependency Graph generation
Cell* generate_depgraph(Cell* name, Cell* value, Cell* env);
Cell* find_dependencies(Cell* body);
Cell* topological_sort(Cell* deps);
```

### Phase 5: Integration with eval.c (Week 6)

```c
// eval.c - Extend handle_define()
Cell* handle_define(Cell* name, Cell* value, Cell* env) {
    Cell* result = eval(value, env);

    // Store definition
    env_define(env, name, result);

    // Auto-generate graphs for lambdas
    if (result->type == CELL_LAMBDA) {
        // Generate and store CFG
        Cell* cfg = generate_cfg(result);
        env_define_metadata(env, name, make_symbol("⌂⟿"), cfg);

        // Generate and store DFG
        Cell* dfg = generate_dfg(result);
        env_define_metadata(env, name, make_symbol("⌂⇝"), dfg);

        // Generate and store Call Graph
        Cell* cg = generate_callgraph(result, env);
        env_define_metadata(env, name, make_symbol("⌂⊚"), cg);

        // Generate and store Dep Graph
        Cell* dg = generate_depgraph(name, result, env);
        env_define_metadata(env, name, make_symbol("⌂⊙"), dg);

        // Print documentation (existing)
        print_auto_docs(name, result, env);
    }

    return result;
}
```

## Memory Management

### Reference Counting for Structures

```c
// Structures and graphs are cells, so they follow standard refcounting
Cell* s = make_struct(type_tag, fields);  // refcount = 1
cell_retain(s);                            // refcount = 2
cell_release(s);                           // refcount = 1
cell_release(s);                           // refcount = 0, freed
```

### Cycles in Graphs

Graphs may contain cycles. Use weak references or cycle detection:

```c
// Option 1: Weak references in graph edges
typedef struct {
    Cell* nodes;       // Strong refs
    Cell* edges;       // Weak refs (don't increment refcount)
} GraphData;

// Option 2: Cycle detection in release
void cell_release(Cell* c) {
    if (--c->refcount == 0) {
        if (c->type == CELL_GRAPH) {
            // Special handling for graph cycles
            break_cycles(c);
        }
        free_cell(c);
    }
}
```

## Testing Strategy

### Unit Tests for Structures

```scheme
; Test leaf structures
(⊙≔ Point :x :y)
(≔ p (⊙ Point #3 #4))
(⊢ (≡ (⊙→ p :x) #3) :point-x-access)
(⊢ (⊙? p Point) :point-type-check)

; Test node structures (ADT)
(⊚≔ List [:Nil] [:Cons :head :tail])
(≔ l (⊚ List :Cons #1 (⊚ List :Nil)))
(⊢ (⊚? l List :Cons) :list-variant-check)

; Test graph structures
(⊝≔ Graph :nodes :edges)
(≔ g (⊝ Graph ∅ ∅))
(≔ g (⊝⊕ g #0))
(≔ g (⊝⊕ g #1))
(≔ g (⊝⊗ g #0 #1 :edge))
(⊢ (≡ (length (⊝→ g :nodes)) #2) :graph-nodes)
```

### Integration Tests for CFG/DFG

```scheme
; Test CFG generation
(≔ ! (λ (n) (? (≡ n #0) #1 (⊗ n (! (⊖ n #1))))))
(≔ cfg (⌂⟿ (⌜ !)))
(⊢ (⊝? cfg CFG) :cfg-is-graph)
(⊢ (> (length (⊝→ cfg :nodes)) #0) :cfg-has-nodes)
(⊢ (> (length (⊝→ cfg :edges)) #0) :cfg-has-edges)

; Test DFG generation
(≔ dfg (⌂⇝ (⌜ !)))
(⊢ (⊝? dfg DFG) :dfg-is-graph)

; Test Call Graph generation
(≔ cg (⌂⊚ (⌜ !)))
(⊢ (⊝? cg CallGraph) :cg-is-graph)
(⊢ (⊝→ cg :recursive) :cg-detects-recursion)

; Test Dep Graph generation
(≔ dg (⌂⊙ (⌜ !)))
(⊢ (⊝? dg DepGraph) :dg-is-graph)
```

## Future Extensions

### 1. Graph Algorithms as Primitives

```scheme
; Graph traversal
⊝⇉  ; (⊝⇉ graph start) - BFS from start node
⊝⇊  ; (⊝⇊ graph start) - DFS from start node

; Graph analysis
⊝⟲  ; (⊝⟲ graph) - Find cycles
⊝⇶  ; (⊝⇶ graph start end) - Shortest path
⊝⊤  ; (⊝⊤ graph) - Topological sort

; Graph transformation
⊝⊐  ; (⊝⊐ graph pattern) - Subgraph matching
⊝⇄  ; (⊝⇄ graph transform) - Graph rewrite
```

### 2. Structure Composition

```scheme
; Nested structures
(⊙≔ Circle :center :radius)
(⊙≔ Point :x :y)

(≔ c (⊙ Circle
  (⊙ Point #0 #0)  ; center is a Point
  #5))             ; radius

; Access nested fields
(⊙→ (⊙→ c :center) :x)  ; → #0
```

### 3. Generic Structures

```scheme
; Polymorphic data structures
(⊚≔ (⊳ T) List
  [:Nil]
  [:Cons (: head T) (: tail (List T))])

; Instantiate
(≔ int-list (⊲ List ℕ))
(≔ l (⊚ int-list :Cons #42 (⊚ int-list :Nil)))
```

## Summary

**Data structures as first-class citizens enable:**

1. ✅ **User-defined types** - Custom structures (⊙, ⊚, ⊝)
2. ✅ **Pattern matching** - Destructure any structure
3. ✅ **Compiler introspection** - Query CFG/DFG/Call/Dep graphs
4. ✅ **Meta-analysis** - Optimize using graph queries
5. ✅ **Type safety** - Structure types enforced
6. ✅ **understanding** - Structures are explicit and queryable

**Implementation timeline:**
- Week 1: Cell extensions + structure types
- Week 2: Structure primitives (⊙, ⊚, ⊝)
- Week 3: Graph primitives (⊝⊕, ⊝⊗, ⊝→)
- Week 4-5: CFG/DFG/Call/Dep generation
- Week 6: Integration + testing

**Next:** Pattern matching can now be designed with full knowledge of what it's matching on.

---

**Philosophy:** If it exists in the program, it should be queryable. Data structures aren't just implementation details - they're first-class values that and programmers can reason about.
