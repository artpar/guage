; Test structure primitives when loaded from file
; This verifies that :symbol keywords work correctly from files

; Test 1: Define leaf structure (keywords are self-evaluating now!)
(⊙≔ :Point :x :y)
::Point

; Test 2: Create structure instance
(≔ p (⊙ :Point #3 #4))
⊙:Point

; Test 3: Get field x
(⊙→ p :x)
#3

; Test 4: Get field y
(⊙→ p :y)
#4

; Test 5: Update field (immutable)
(≔ p2 (⊙← p :x #10))
⊙:Point

; Test 6: Verify original unchanged
(⊙→ p :x)
#3

; Test 7: Verify updated has new value
(⊙→ p2 :x)
#10

; Test 8: Type check - correct type
(⊙? p :Point)
#t

; Test 9: Type check - wrong type
(⊙? p :NotPoint)
#f

; Test 10: Type check - non-structure
(⊙? #42 :Point)
#f

; Test 11: Define structure with many fields
(⊙≔ :Person :name :age :email :phone)
::Person

; Test 12: Create person
(≔ person (⊙ :Person :alice #30 :alice@example.com :555-1234))
⊙:Person

; Test 13: Get person field
(⊙→ person :age)
#30

; Test 14: Nested structures - define Address
(⊙≔ :Address :street :city :zip)
::Address

; Test 15: Create address
(≔ addr (⊙ :Address :main-st :springfield #12345))
⊙:Address

; Test 16: Get address field
(⊙→ addr :city)
:springfield

; Test 17: Define Person2 with address field
(⊙≔ :Person2 :name :address)
::Person2

; Test 18: Create person with address
(≔ person2 (⊙ :Person2 :bob addr))
⊙:Person2

; Test 19: Get nested address
(≔ person-addr (⊙→ person2 :address))
⊙:Address

; Test 20: Get city from nested address
(⊙→ person-addr :city)
:springfield

; Test 21: Keywords are self-evaluating
:test
:test

; Test 22: Keywords in lists
(⟨⟩ :a (⟨⟩ :b (⟨⟩ :c ∅)))
⟨:a ⟨:b ⟨:c ∅⟩⟩⟩

; Test 23: Use structure in lambda
(≔ get-x (λ (pt) (⊙→ pt :x)))
λ[1]

; Test 24: Apply lambda
(get-x p)
#3

; Test 25: Update in lambda
(≔ double-x (λ (pt) (⊙← pt :x (⊗ (⊙→ pt :x) #2))))
λ[1]

; Test 26: Apply update lambda
(≔ p-doubled (double-x p))
⊙:Point

; Test 27: Verify doubled value
(⊙→ p-doubled :x)
#6

; Test 28: Keyword as function result
(≔ get-type (λ (x) :Point))
λ[1]

; Test 29: Get keyword from function
(get-type #42)
:Point

; Test 30: Keywords in conditional
(? (⊙? p :Point) :yes :no)
:yes
