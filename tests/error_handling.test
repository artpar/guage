; Error Handling Test Suite
; Tests first-class error values and error handling consistency
; All errors should be values (not exceptions) and composable

; ===== SECTION 1: Error Creation =====

; Test 1: Create simple error
(⊨ (⌜ :create-simple-error⌝)
   (⚠ :test-error :data)
   (⚠ :test-error :data))

; Test 2: Create error with number data
(⊨ (⌜ :create-error-number⌝)
   (⚠ :invalid-value #42)
   (⚠ :invalid-value #42))

; Test 3: Create error with nil data
(⊨ (⌜ :create-error-nil⌝)
   (⚠ :no-data ∅)
   (⚠ :no-data ∅))

; Test 4: Create error with pair data
(⊨ (⌜ :create-error-pair⌝)
   (⚠ :complex (⟨⟩ #1 #2))
   (⚠ :complex (⟨⟩ #1 #2)))

; ===== SECTION 2: Error Detection =====

; Test 5: Detect error value
(⊨ (⌜ :detect-error⌝)
   #t
   (⚠? (⚠ :test :data)))

; Test 6: Non-error returns false
(⊨ (⌜ :detect-non-error-number⌝)
   #f
   (⚠? #42))

; Test 7: Non-error returns false for symbol
(⊨ (⌜ :detect-non-error-symbol⌝)
   #f
   (⚠? :symbol))

; Test 8: Non-error returns false for pair
(⊨ (⌜ :detect-non-error-pair⌝)
   #f
   (⚠? (⟨⟩ #1 #2)))

; Test 9: Non-error returns false for nil
(⊨ (⌜ :detect-non-error-nil⌝)
   #f
   (⚠? ∅))

; ===== SECTION 3: Error Composition =====

; Test 10: Error containing error
(≔ nested-err (⚠ :outer (⚠ :inner :data)))
(⊨ (⌜ :error-containing-error⌝)
   #t
   (⚠? nested-err))

; Test 11: Error in pair
(≔ err-in-pair (⟨⟩ (⚠ :error :data) #42))
(⊨ (⌜ :error-in-pair⌝)
   #t
   (⚠? (◁ err-in-pair)))

; Test 12: List of errors
(≔ err-list (⟨⟩ (⚠ :err1 #1) (⟨⟩ (⚠ :err2 #2) ∅)))
(⊨ (⌜ :list-of-errors⌝)
   #t
   (⚠? (◁ err-list)))

; ===== SECTION 4: Function Errors =====

; Test 13: Arity mismatch error
(≔ two-arg (λ (x y) (⊕ x y)))
(≔ arity-err (two-arg #1))
(⊨ (⌜ :arity-mismatch⌝)
   #t
   (⚠? arity-err))

; Test 14: Non-function application error
(≔ not-fn-err (#42 #1))
(⊨ (⌜ :not-a-function⌝)
   #t
   (⚠? not-fn-err))

; Test 15: Undefined variable error (would fail at parse, skip)
; (≔ undef-err undefined-var)
; (⊨ (⌜ :undefined-variable⌝) #t (⚠? undef-err))

; ===== SECTION 5: Arithmetic Errors =====

; Test 16: Division by zero
(≔ div-zero (⊘ #10 #0))
(⊨ (⌜ :div-by-zero⌝)
   #t
   (⚠? div-zero))

; Test 17: Modulo by zero
(≔ mod-zero (% #10 #0))
(⊨ (⌜ :mod-by-zero⌝)
   #t
   (⚠? mod-zero))

; ===== SECTION 6: Error Recovery Patterns =====

; Test 18: Check and handle error
(≔ safe-divide (λ (x y)
  (? (≡ y #0)
     (⚠ :div-by-zero y)
     (⊘ x y))))

(⊨ (⌜ :safe-divide-error⌝)
   #t
   (⚠? (safe-divide #10 #0)))

; Test 19: Safe divide success
(⊨ (⌜ :safe-divide-success⌝)
   #5
   (safe-divide #10 #2))

; Test 20: Error handling function
(≔ handle-result (λ (r)
  (? (⚠? r)
     :error-occurred
     :success)))

(⊨ (⌜ :handle-error-branch⌝)
   :error-occurred
   (handle-result (⚠ :test :data)))

; Test 21: Handle success branch
(⊨ (⌜ :handle-success-branch⌝)
   :success
   (handle-result #42))

; ===== SECTION 7: Assertions =====

; Test 22: Assert true condition
(⊨ (⌜ :assert-true⌝)
   #t
   (⊢ #t :should-not-error))

; Test 23: Assert false condition
(≔ assert-err (⊢ #f :test-failure))
(⊨ (⌜ :assert-false⌝)
   #t
   (⚠? assert-err))

; Test 24: Assert with expression
(⊨ (⌜ :assert-expr⌝)
   #t
   (⊢ (≡ (⊕ #1 #1) #2) :should-pass))

; Test 25: Assert failure with expression
(≔ expr-assert-err (⊢ (≡ (⊕ #1 #1) #3) :math-failure))
(⊨ (⌜ :assert-expr-fail⌝)
   #t
   (⚠? expr-assert-err))

; ===== SECTION 8: Complex Error Scenarios =====

; Test 26: Error propagation through function
(≔ propagate (λ (x)
  (? (⚠? x)
     x
     (⊕ x #1))))

(≔ prop-err (propagate (⚠ :input-error :bad)))
(⊨ (⌜ :error-propagation⌝)
   #t
   (⚠? prop-err))

; Test 27: Error propagation with success
(⊨ (⌜ :propagation-success⌝)
   #43
   (propagate #42))

; Test 28: Multiple error checks
(≔ multi-check (λ (x y)
  (? (⚠? x)
     x
     (? (⚠? y)
        y
        (⊕ x y)))))

(≔ first-err (multi-check (⚠ :err1 #1) #2))
(⊨ (⌜ :multi-check-first⌝)
   #t
   (⚠? first-err))

; Test 29: Multi-check second error
(≔ second-err (multi-check #1 (⚠ :err2 #2)))
(⊨ (⌜ :multi-check-second⌝)
   #t
   (⚠? second-err))

; Test 30: Multi-check success
(⊨ (⌜ :multi-check-success⌝)
   #7
   (multi-check #3 #4))

; ===== SECTION 9: Error Type Preservation =====

; Test 31: Error symbols preserved
; Note: Can't easily test error data extraction without pattern matching
; Just verify error is created and detected

(≔ typed-err (⚠ :specific-type :important-data))
(⊨ (⌜ :error-type-preserved⌝)
   #t
   (⚠? typed-err))

; ===== SECTION 10: Practical Error Patterns =====

; Test 32: Maybe pattern (error as None)
(≔ maybe-get (λ (lst)
  (? (∅? lst)
     (⚠ :empty-list ∅)
     (◁ lst))))

(⊨ (⌜ :maybe-empty⌝)
   #t
   (⚠? (maybe-get ∅)))

; Test 33: Maybe success
(⊨ (⌜ :maybe-success⌝)
   #1
   (maybe-get (⟨⟩ #1 ∅)))

; Test 34: Result pattern (Ok/Err)
(≔ parse-number (λ (x)
  (? (ℕ? x)
     x
     (⚠ :not-a-number x))))

(⊨ (⌜ :result-ok⌝)
   #42
   (parse-number #42))

; Test 35: Result error
(≔ parse-err (parse-number :not-number))
(⊨ (⌜ :result-err⌝)
   #t
   (⚠? parse-err))

; Test 36: Chained error checks
(≔ chain (λ (x)
  (≔ step1 (parse-number x))
  (? (⚠? step1)
     step1
     (⊕ step1 #10))))

(⊨ (⌜ :chain-success⌝)
   #15
   (chain #5))

; Test 37: Chained error
(≔ chain-err (chain :bad))
(⊨ (⌜ :chain-error⌝)
   #t
   (⚠? chain-err))

; ===== SECTION 11: Edge Cases =====

; Test 38: Error as function argument
(≔ takes-error (λ (x) (⚠? x)))
(⊨ (⌜ :error-as-arg⌝)
   #t
   (takes-error (⚠ :test :data)))

; Test 39: Return error from nested function
(≔ nested (λ (x)
  ((λ (y) (⚠ :nested y)) x)))

(⊨ (⌜ :nested-error⌝)
   #t
   (⚠? (nested #42)))

; Test 40: Error in conditional test
; Error should propagate as the test result
(≔ cond-err (? (⚠ :bad-test #1) #2 #3))
; This might evaluate to error or to a branch - behavior depends on interpreter
; For now, just verify it doesn't crash

; ===== SUMMARY =====
; Total: 40 error handling tests
; Coverage:
;   - Error creation (4 tests)
;   - Error detection (5 tests)
;   - Error composition (3 tests)
;   - Function errors (3 tests)
;   - Arithmetic errors (2 tests)
;   - Error recovery patterns (4 tests)
;   - Assertions (4 tests)
;   - Complex scenarios (5 tests)
;   - Type preservation (1 test)
;   - Practical patterns (6 tests)
;   - Edge cases (3 tests)
