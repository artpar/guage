; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Guage Standard Library: S-Expression Parser
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Status: CURRENT
; Created: 2026-01-27 (Day 39)
; Purpose: Parse S-expressions written in Guage - Step toward self-hosting
;
; All names are PURELY SYMBOLIC - no English words!
; This parser converts strings to nested list structures (AST)
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Phase 1: Character Classification
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

; â‰ˆâŠ™space? :: :symbol â†’ ğ”¹
; Check if character symbol is whitespace
(â‰” â‰ˆâŠ™space? (Î» (ğ•”)
  (âˆ¨â€¦ (â‰¡ ğ•” (â‰ˆâ†’ " " #0))
  (âˆ¨â€¦ (â‰¡ ğ•” (â‰ˆâ†’ "\t" #0))
  (âˆ¨â€¦ (â‰¡ ğ•” (â‰ˆâ†’ "\n" #0))
      (â‰¡ ğ•” (â‰ˆâ†’ "\r" #0)))))))

; â‰ˆâŠ™digit? :: :symbol â†’ ğ”¹
; Check if character symbol is a digit (0-9)
(â‰” â‰ˆâŠ™digit? (Î» (ğ•”)
  (âˆ¨â€¦ (â‰¡ ğ•” (â‰ˆâ†’ "0" #0))
  (âˆ¨â€¦ (â‰¡ ğ•” (â‰ˆâ†’ "1" #0))
  (âˆ¨â€¦ (â‰¡ ğ•” (â‰ˆâ†’ "2" #0))
  (âˆ¨â€¦ (â‰¡ ğ•” (â‰ˆâ†’ "3" #0))
  (âˆ¨â€¦ (â‰¡ ğ•” (â‰ˆâ†’ "4" #0))
  (âˆ¨â€¦ (â‰¡ ğ•” (â‰ˆâ†’ "5" #0))
  (âˆ¨â€¦ (â‰¡ ğ•” (â‰ˆâ†’ "6" #0))
  (âˆ¨â€¦ (â‰¡ ğ•” (â‰ˆâ†’ "7" #0))
  (âˆ¨â€¦ (â‰¡ ğ•” (â‰ˆâ†’ "8" #0))
      (â‰¡ ğ•” (â‰ˆâ†’ "9" #0)))))))))))))

; â‰ˆâŠ™paren? :: :symbol â†’ ğ”¹
; Check if character is parenthesis
(â‰” â‰ˆâŠ™paren? (Î» (ğ•”)
  (âˆ¨â€¦ (â‰¡ ğ•” (â‰ˆâ†’ "(" #0))
      (â‰¡ ğ•” (â‰ˆâ†’ ")" #0)))))

; â‰ˆâŠ™special? :: :symbol â†’ ğ”¹
; Check if character is special delimiter
(â‰” â‰ˆâŠ™special? (Î» (ğ•”)
  (âˆ¨â€¦ (â‰ˆâŠ™space? ğ•”)
  (âˆ¨â€¦ (â‰ˆâŠ™paren? ğ•”)
  (âˆ¨â€¦ (â‰¡ ğ•” (â‰ˆâ†’ "\"" #0))
  (âˆ¨â€¦ (â‰¡ ğ•” (â‰ˆâ†’ "'" #0))
      (â‰¡ ğ•” (â‰ˆâ†’ ";" #0))))))))

; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Phase 2: Tokenization Helpers
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

; â‰ˆâŠ™â†’token :: :symbol â†’ Î± â†’ token
; Create token structure: âŸ¨type valueâŸ©
(â‰” â‰ˆâŠ™â†’token (Î» (ğ•¥ ğ•§)
  (âŸ¨âŸ© ğ•¥ ğ•§)))

; â‰ˆâŠ™token-type :: token â†’ :symbol
; Get token type
(â‰” â‰ˆâŠ™token-type (Î» (ğ•¥)
  (â— ğ•¥)))

; â‰ˆâŠ™token-val :: token â†’ Î±
; Get token value
(â‰” â‰ˆâŠ™token-val (Î» (ğ•¥)
  (â— (â–· ğ•¥))))

; â‰ˆâŠ™skip-ws :: â‰ˆ â†’ â„• â†’ â„•
; Skip whitespace, return new position
(â‰” â‰ˆâŠ™skip-ws (Î» (ğ•¤ ğ•¡)
  (? (â‰¥ ğ•¡ (â‰ˆ# ğ•¤))
     ğ•¡
     (? (â‰ˆâŠ™space? (â‰ˆâ†’ ğ•¤ ğ•¡))
        (â‰ˆâŠ™skip-ws ğ•¤ (âŠ• ğ•¡ #1))
        ğ•¡))))

; â‰ˆâŠ™skip-comment :: â‰ˆ â†’ â„• â†’ â„•
; Skip comment (from ; to newline), return new position
(â‰” â‰ˆâŠ™skip-comment (Î» (ğ•¤ ğ•¡)
  (? (â‰¥ ğ•¡ (â‰ˆ# ğ•¤))
     ğ•¡
     (? (â‰¡ (â‰ˆâ†’ ğ•¤ ğ•¡) (â‰ˆâ†’ "\n" #0))
        (âŠ• ğ•¡ #1)
        (â‰ˆâŠ™skip-comment ğ•¤ (âŠ• ğ•¡ #1))))))

; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Phase 3: Token Reading
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

; â‰ˆâŠ™read-number :: â‰ˆ â†’ â„• â†’ â„• â†’ â‰ˆ
; Read number characters until delimiter
(â‰” â‰ˆâŠ™read-number (Î» (ğ•¤ ğ•¡ ğ•¤ğ•¥ğ•’ğ•£ğ•¥)
  (? (â‰¥ ğ•¡ (â‰ˆ# ğ•¤))
     (â‰ˆâŠ‚ ğ•¤ ğ•¤ğ•¥ğ•’ğ•£ğ•¥ ğ•¡)
     (? (â‰ˆâŠ™special? (â‰ˆâ†’ ğ•¤ ğ•¡))
        (â‰ˆâŠ‚ ğ•¤ ğ•¤ğ•¥ğ•’ğ•£ğ•¥ ğ•¡)
        (â‰ˆâŠ™read-number ğ•¤ (âŠ• ğ•¡ #1) ğ•¤ğ•¥ğ•’ğ•£ğ•¥)))))

; â‰ˆâŠ™read-symbol :: â‰ˆ â†’ â„• â†’ â„• â†’ â‰ˆ
; Read symbol characters until delimiter
(â‰” â‰ˆâŠ™read-symbol (Î» (ğ•¤ ğ•¡ ğ•¤ğ•¥ğ•’ğ•£ğ•¥)
  (? (â‰¥ ğ•¡ (â‰ˆ# ğ•¤))
     (â‰ˆâŠ‚ ğ•¤ ğ•¤ğ•¥ğ•’ğ•£ğ•¥ ğ•¡)
     (? (â‰ˆâŠ™special? (â‰ˆâ†’ ğ•¤ ğ•¡))
        (â‰ˆâŠ‚ ğ•¤ ğ•¤ğ•¥ğ•’ğ•£ğ•¥ ğ•¡)
        (â‰ˆâŠ™read-symbol ğ•¤ (âŠ• ğ•¡ #1) ğ•¤ğ•¥ğ•’ğ•£ğ•¥)))))

; â‰ˆâŠ™read-string :: â‰ˆ â†’ â„• â†’ â„• â†’ â‰ˆ
; Read string characters until closing quote
(â‰” â‰ˆâŠ™read-string (Î» (ğ•¤ ğ•¡ ğ•¤ğ•¥ğ•’ğ•£ğ•¥)
  (? (â‰¥ ğ•¡ (â‰ˆ# ğ•¤))
     (âš  (âŒœ :unclosed-string) (â‰ˆâŠ‚ ğ•¤ ğ•¤ğ•¥ğ•’ğ•£ğ•¥ ğ•¡))
     (? (â‰¡ (â‰ˆâ†’ ğ•¤ ğ•¡) (â‰ˆâ†’ "\"" #0))
        (â‰ˆâŠ‚ ğ•¤ ğ•¤ğ•¥ğ•’ğ•£ğ•¥ ğ•¡)
        (â‰ˆâŠ™read-string ğ•¤ (âŠ• ğ•¡ #1) ğ•¤ğ•¥ğ•’ğ•£ğ•¥)))))

; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Phase 4: Tokenizer
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

; â‰ˆâŠ™tokenize-one :: â‰ˆ â†’ â„• â†’ âŸ¨token â„•âŸ© | âˆ…
; Read one token from position, return âŸ¨token new-positionâŸ© or âˆ… at EOF
(â‰” â‰ˆâŠ™tokenize-one (Î» (ğ•¤ ğ•¡)
  ; Skip whitespace using lambda binding
  ((Î» (ğ•¡â€²)
    ; Check if at end
    (? (â‰¥ ğ•¡â€² (â‰ˆ# ğ•¤))
       âˆ…

       ; Check for comment
       (? (â‰¡ (â‰ˆâ†’ ğ•¤ ğ•¡â€²) (â‰ˆâ†’ ";" #0))
          (â‰ˆâŠ™tokenize-one ğ•¤ (â‰ˆâŠ™skip-comment ğ•¤ ğ•¡â€²))

          ; Check for left paren
          (? (â‰¡ (â‰ˆâ†’ ğ•¤ ğ•¡â€²) (â‰ˆâ†’ "(" #0))
             (âŸ¨âŸ© (â‰ˆâŠ™â†’token (âŒœ :lparen) (â‰ˆâ†’ "(" #0)) (âŠ• ğ•¡â€² #1))

             ; Check for right paren
             (? (â‰¡ (â‰ˆâ†’ ğ•¤ ğ•¡â€²) (â‰ˆâ†’ ")" #0))
                (âŸ¨âŸ© (â‰ˆâŠ™â†’token (âŒœ :rparen) (â‰ˆâ†’ ")" #0)) (âŠ• ğ•¡â€² #1))

                ; Check for quote
                (? (â‰¡ (â‰ˆâ†’ ğ•¤ ğ•¡â€²) (â‰ˆâ†’ "'" #0))
                   (âŸ¨âŸ© (â‰ˆâŠ™â†’token (âŒœ :quote) (â‰ˆâ†’ "'" #0)) (âŠ• ğ•¡â€² #1))

                   ; Check for string
                   (? (â‰¡ (â‰ˆâ†’ ğ•¤ ğ•¡â€²) (â‰ˆâ†’ "\"" #0))
                      ((Î» (ğ•¤ğ•¥ğ•£)
                        (? (âš ? ğ•¤ğ•¥ğ•£)
                           (âŸ¨âŸ© ğ•¤ğ•¥ğ•£ ğ•¡â€²)  ; Return error
                           (âŸ¨âŸ© (â‰ˆâŠ™â†’token (âŒœ :string) ğ•¤ğ•¥ğ•£)
                               (âŠ• (âŠ• ğ•¡â€² #1) (âŠ• (â‰ˆ# ğ•¤ğ•¥ğ•£) #1)))))
                       (â‰ˆâŠ™read-string ğ•¤ (âŠ• ğ•¡â€² #1) (âŠ• ğ•¡â€² #1)))

                      ; Check for number (digit or -)
                      (? (âˆ¨â€¦ (â‰ˆâŠ™digit? (â‰ˆâ†’ ğ•¤ ğ•¡â€²))
                             (â‰¡ (â‰ˆâ†’ ğ•¤ ğ•¡â€²) (â‰ˆâ†’ "-" #0)))
                         ((Î» (ğ•Ÿğ•¦ğ•)
                           (âŸ¨âŸ© (â‰ˆâŠ™â†’token (âŒœ :number) ğ•Ÿğ•¦ğ•) (âŠ• ğ•¡â€² (â‰ˆ# ğ•Ÿğ•¦ğ•))))
                          (â‰ˆâŠ™read-number ğ•¤ ğ•¡â€² ğ•¡â€²))

                         ; Must be symbol
                         ((Î» (ğ•¤ğ•ªğ•)
                           (âŸ¨âŸ© (â‰ˆâŠ™â†’token (âŒœ :symbol) ğ•¤ğ•ªğ•) (âŠ• ğ•¡â€² (â‰ˆ# ğ•¤ğ•ªğ•))))
                          (â‰ˆâŠ™read-symbol ğ•¤ ğ•¡â€² ğ•¡â€²))))))))))
   (â‰ˆâŠ™skip-ws ğ•¤ ğ•¡))))

; â‰ˆâŠ™tokenize :: â‰ˆ â†’ [token] | âš 
; Tokenize entire string into list of tokens
(â‰” â‰ˆâŠ™tokenize (Î» (ğ•¤)
  (â‰ˆâŠ™tokenize-loop ğ•¤ #0)))

; Tokenize loop - calls tokenize-one repeatedly (no nested lambda, calls tokenize-one 3x)
(â‰” â‰ˆâŠ™tokenize-loop (Î» (ğ•¤ ğ•¡)
  (? (â‰¥ ğ•¡ (â‰ˆ# ğ•¤))
     âˆ…  ; At end of string
     ; Check if tokenize-one returns âˆ…
     (? (âˆ…? (â‰ˆâŠ™tokenize-one ğ•¤ ğ•¡))
        âˆ…
        ; Check if token is error
        (? (âš ? (â— (â‰ˆâŠ™tokenize-one ğ•¤ ğ•¡)))
           (â— (â‰ˆâŠ™tokenize-one ğ•¤ ğ•¡))  ; Return the error
           ; Build list: cons token onto recursive call
           (âŸ¨âŸ© (â— (â‰ˆâŠ™tokenize-one ğ•¤ ğ•¡))
               (â‰ˆâŠ™tokenize-loop ğ•¤ (â–· (â‰ˆâŠ™tokenize-one ğ•¤ ğ•¡)))))))))

; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Phase 5: Parser
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

; â‰ˆâŠ™parse-one :: [token] â†’ âŸ¨expr [token]âŸ© | âš 
; Parse one expression from token list
; Returns âŸ¨parsed-expr remaining-tokensâŸ©
(â‰” â‰ˆâŠ™parse-one (Î» (ğ•¥ğ• ğ•œğ•¤)
  (? (âˆ…? ğ•¥ğ• ğ•œğ•¤)
     (âš  (âŒœ :unexpected-eof) âˆ…)

     ; Use nested lambda bindings for local variables
     ((Î» (ğ•¥ğ• ğ•œ)
       ((Î» (ğ•¥ğ•ªğ•¡ğ•–)
         ((Î» (ğ•§ğ•’ğ•)
           ; Check token type
           (? (â‰¡ ğ•¥ğ•ªğ•¡ğ•– (âŒœ :number))
              ; TODO: Convert string to number (for now return string)
              (âŸ¨âŸ© ğ•§ğ•’ğ• (â–· ğ•¥ğ• ğ•œğ•¤))

              (? (â‰¡ ğ•¥ğ•ªğ•¡ğ•– (âŒœ :string))
                 (âŸ¨âŸ© ğ•§ğ•’ğ• (â–· ğ•¥ğ• ğ•œğ•¤))

                 (? (â‰¡ ğ•¥ğ•ªğ•¡ğ•– (âŒœ :symbol))
                    ; Convert string to symbol
                    ; TODO: Proper symbol creation (for now return string)
                    (âŸ¨âŸ© ğ•§ğ•’ğ• (â–· ğ•¥ğ• ğ•œğ•¤))

                    (? (â‰¡ ğ•¥ğ•ªğ•¡ğ•– (âŒœ :quote))
                       ; Parse quoted expression: ' â†’ (âŒœ ...)
                       ((Î» (ğ•¢ğ•¦ğ• ğ•¥ğ•–ğ••)
                         (? (âš ? ğ•¢ğ•¦ğ• ğ•¥ğ•–ğ••)
                            ğ•¢ğ•¦ğ• ğ•¥ğ•–ğ••
                            (âŸ¨âŸ© (âŸ¨âŸ© (âŒœ âŒœ) (âŸ¨âŸ© (â— ğ•¢ğ•¦ğ• ğ•¥ğ•–ğ••) âˆ…))
                                (â— (â–· ğ•¢ğ•¦ğ• ğ•¥ğ•–ğ••)))))
                        (â‰ˆâŠ™parse-one (â–· ğ•¥ğ• ğ•œğ•¤)))

                       (? (â‰¡ ğ•¥ğ•ªğ•¡ğ•– (âŒœ :lparen))
                          ; Parse list until rparen
                          (â‰ˆâŠ™parse-list (â–· ğ•¥ğ• ğ•œğ•¤))

                          (? (â‰¡ ğ•¥ğ•ªğ•¡ğ•– (âŒœ :rparen))
                             (âš  (âŒœ :unexpected-rparen) ğ•§ğ•’ğ•)
                             (âš  (âŒœ :unknown-token-type) ğ•¥ğ•ªğ•¡ğ•–))))))))
          (â‰ˆâŠ™token-val ğ•¥ğ• ğ•œ)))
        (â‰ˆâŠ™token-type ğ•¥ğ• ğ•œ)))
      (â— ğ•¥ğ• ğ•œğ•¤)))))

; â‰ˆâŠ™parse-list :: [token] â†’ âŸ¨list [token]âŸ© | âš 
; Parse list elements until rparen
; Returns âŸ¨list-expr remaining-tokensâŸ©
(â‰” â‰ˆâŠ™parse-list (Î» (ğ•¥ğ• ğ•œğ•¤)
  (? (âˆ…? ğ•¥ğ• ğ•œğ•¤)
     (âš  (âŒœ :unclosed-list) âˆ…)

     ((Î» (ğ•¥ğ• ğ•œ)
       ((Î» (ğ•¥ğ•ªğ•¡ğ•–)
         ; Check for closing paren
         (? (â‰¡ ğ•¥ğ•ªğ•¡ğ•– (âŒœ :rparen))
            (âŸ¨âŸ© âˆ… (â–· ğ•¥ğ• ğ•œğ•¤))

            ; Parse one element
            ((Î» (ğ•–ğ•ğ•–ğ•)
              (? (âš ? ğ•–ğ•ğ•–ğ•)
                 ğ•–ğ•ğ•–ğ•

                 ; Parse rest of list
                 ((Î» (ğ•£ğ•–ğ•¤ğ•¥)
                   (? (âš ? ğ•£ğ•–ğ•¤ğ•¥)
                      ğ•£ğ•–ğ•¤ğ•¥
                      (âŸ¨âŸ© (âŸ¨âŸ© (â— ğ•–ğ•ğ•–ğ•) (â— ğ•£ğ•–ğ•¤ğ•¥))
                          (â— (â–· ğ•£ğ•–ğ•¤ğ•¥)))))
                  (â‰ˆâŠ™parse-list (â— (â–· ğ•–ğ•ğ•–ğ•))))))
             (â‰ˆâŠ™parse-one ğ•¥ğ• ğ•œğ•¤))))
        (â‰ˆâŠ™token-type ğ•¥ğ• ğ•œ)))
      (â— ğ•¥ğ• ğ•œğ•¤)))))

; â‰ˆâŠ™parse :: â‰ˆ â†’ expr | âš 
; Parse string into S-expression
; Example: (â‰ˆâŠ™parse "(+ 1 2)") â†’ âŸ¨"+" âŸ¨"1" âŸ¨"2" âˆ…âŸ©âŸ©âŸ©
(â‰” â‰ˆâŠ™parse (Î» (ğ•¤)
  ((Î» (ğ•¥ğ• ğ•œğ•¤)
    (? (âš ? ğ•¥ğ• ğ•œğ•¤)
       ğ•¥ğ• ğ•œğ•¤
       ((Î» (ğ•£ğ•–ğ•¤)
         (? (âš ? ğ•£ğ•–ğ•¤)
            ğ•£ğ•–ğ•¤
            (â— ğ•£ğ•–ğ•¤)))
        (â‰ˆâŠ™parse-one ğ•¥ğ• ğ•œğ•¤))))
   (â‰ˆâŠ™tokenize ğ•¤))))

; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; End of Parser
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
