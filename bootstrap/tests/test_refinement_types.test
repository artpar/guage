; === Day 127: HFT-Grade Refinement Types ===
; Three-tier predicate evaluation with constraint trees

; === Definition ===
(refine-def :Positive Int (lambda (x) (> x #0)))
(refine-def :NonNeg Int (lambda (x) (>= x #0)))
(refine-def :Even Int (lambda (x) (equal? (% x #2) #0)))
(refine-def :Percentage Int (lambda (x) (and (>= x #0) (<= x #100))))
(refine-def :NonZero Int (lambda (x) (not-equal? x #0)))
(refine-def :NonEmpty String (lambda (s) (> (string-length s) #0)))

; === Check (refine-check?) ===
(test-case :pos-5       #t (refine-check? #5 :Positive))
(test-case :pos-neg3    #f (refine-check? #-3 :Positive))
(test-case :pos-0       #f (refine-check? #0 :Positive))
(test-case :nonneg-0    #t (refine-check? #0 :NonNeg))
(test-case :nonneg-neg  #f (refine-check? #-1 :NonNeg))
(test-case :even-4      #t (refine-check? #4 :Even))
(test-case :even-3      #f (refine-check? #3 :Even))
(test-case :pct-50      #t (refine-check? #50 :Percentage))
(test-case :pct-101     #f (refine-check? #101 :Percentage))
(test-case :pct-neg     #f (refine-check? #-1 :Percentage))
(test-case :nz-5        #t (refine-check? #5 :NonZero))
(test-case :nz-0        #f (refine-check? #0 :NonZero))
(test-case :wrong-base  #f (refine-check? "hello" :Positive))

; === String refinement ===
(test-case :ne-hello    #t (refine-check? "hello" :NonEmpty))
(test-case :ne-empty    #f (refine-check? "" :NonEmpty))

; === Assert (refine-assert!) ===
(test-case :assert-ok   #5 (refine-assert! #5 :Positive))
(test-case :assert-fail #t (error? (refine-assert! #-3 :Positive)))
(test-case :assert-pct  #50 (refine-assert! #50 :Percentage))

; === Introspection ===
(test-case :base-int    #t (type-equal? (refine-base :Positive) (Int)))
(test-case :base-str    #t (type-equal? (refine-base :NonEmpty) (String)))
(test-case :pred-fn     #t (equal? (type-of (refine-pred :Positive)) :function))
(test-case :pred-apply  #t ((refine-pred :Positive) #5))
(test-case :undef-err   #t (error? (refine-base :NoSuch)))

; === Constraint tree (refine-constraint) ===
(test-case :con-not-nil #t (not (null? (refine-constraint :Positive))))

; === Composition ===
(define pos-even (refine-intersect :Positive :Even))
(test-case :and-4      #t (refine-check? #4 pos-even))
(test-case :and-3      #f (refine-check? #3 pos-even))
(test-case :and-neg2   #f (refine-check? #-2 pos-even))

(define pos-or-neg (refine-union :Positive :NonNeg))
(test-case :or-5       #t (refine-check? #5 pos-or-neg))
(test-case :or-0       #t (refine-check? #0 pos-or-neg))

; === Subtyping ===
(test-case :sub-base   #t (refine-subtype? :Positive Int))
(test-case :sub-any    #t (refine-subtype? :Positive Any))
(test-case :sub-wrong  #f (refine-subtype? :Positive String))

; === List all ===
(test-case :list-nonempty #t (not (null? (refine-list))))

; === Find matching ===
(test-case :find-5 #t (not (null? (refine-find #5))))
