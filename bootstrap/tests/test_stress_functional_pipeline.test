;;; Stress: Functional Pipeline
;;; Tier 3 â€” Closures + Data Structures + Pattern Matching + Recursion

;;; --- ADT definitions ---

(adt-define :Category (quote (:CatA)) (quote (:CatB)) (quote (:CatC)) (quote (:CatD)) (quote (:CatE)))

;;; --- Utility functions ---

(define list-len (lambda (lst n)
  (if (null? lst) n
     (list-len (cdr lst) (+ n #1)))))

(define fold-list (lambda (f init lst)
  (if (null? lst) init
     (fold-list f (f init (car lst)) (cdr lst)))))

;;; --- 1. 1,000 items classified into 5 categories via pattern match ---

(define category-map (hashmap))

(define make-category (lambda (i)
  (if (equal? (% i #5) #0) (adt-create :Category :CatA)
     (if (equal? (% i #5) #1) (adt-create :Category :CatB)
        (if (equal? (% i #5) #2) (adt-create :Category :CatC)
           (if (equal? (% i #5) #3) (adt-create :Category :CatD)
              (adt-create :Category :CatE)))))))

(define classify-cat (lambda (cat)
  (match cat (quote (
    ((adt-create :Category :CatA) :a)
    ((adt-create :Category :CatB) :b)
    ((adt-create :Category :CatC) :c)
    ((adt-create :Category :CatD) :d)
    ((adt-create :Category :CatE) :e))))))

(define group-items (lambda (i)
  (if (equal? i #0) :done
     (begin
       (define cat (classify-cat (make-category i)))
       (define cur (hashmap-get category-map cat))
       (hashmap-put category-map cat (if (null? cur) #1 (+ cur #1)))
       (group-items (- i #1))))))

(group-items #1000)

(test-case :fp-5-categories #5 (hashmap-size category-map))
(test-case :fp-each-category-200 #200 (hashmap-get category-map :a))

;;; --- 2. Recursive tree map + fold via closures ---

(adt-define :Tree (quote (:Leaf :val)) (quote (:Node :left :right)))

(define tree-map (lambda (f t)
  (if (adt? t :Tree :Leaf)
     (adt-create :Tree :Leaf (f (adt-get t :val)))
     (adt-create :Tree :Node (tree-map f (adt-get t :left)) (tree-map f (adt-get t :right))))))

(define tree-fold (lambda (f init t)
  (if (adt? t :Tree :Leaf)
     (f init (adt-get t :val))
     (tree-fold f (tree-fold f init (adt-get t :left)) (adt-get t :right)))))

(define build-tree (lambda (depth)
  (if (equal? depth #0) (adt-create :Tree :Leaf #1)
     (adt-create :Tree :Node (build-tree (- depth #1)) (build-tree (- depth #1))))))

;; Depth 8 = 256 leaves
(define big-tree (build-tree #8))

;; Map: double every leaf
(define doubled-tree (tree-map (lambda (x) (* x #2)) big-tree))

;; Fold: sum all leaves
(define tree-sum (tree-fold (lambda (acc x) (+ acc x)) #0 doubled-tree))

;; 256 leaves * 2 = 512
(test-case :fp-tree-map-fold #512 tree-sum)

;;; --- 3. Sort 200 elements via closure-based comparator ---

(define insert-sorted (lambda (cmp x lst)
  (if (null? lst) (cons x nil)
     (if (cmp x (car lst))
        (cons x lst)
        (cons (car lst) (insert-sorted cmp x (cdr lst)))))))

(define sort-list (lambda (cmp lst)
  (if (null? lst) nil
     (insert-sorted cmp (car lst) (sort-list cmp (cdr lst))))))

(define unsorted (lambda (n acc)
  (if (equal? n #0) acc
     (unsorted (- n #1) (cons (% (* n #7919) #10000) acc)))))

(define unsorted-100 (unsorted #100 nil))
(define sorted (sort-list (lambda (a b) (< a b)) unsorted-100))

(test-case :fp-sort-len #100 (list-len sorted #0))

;; Verify sorted
(define is-sorted (lambda (lst)
  (if (null? lst) #t
     (if (null? (cdr lst)) #t
        (if (<= (car lst) (car (cdr lst)))
           (is-sorted (cdr lst))
           #f)))))

(test-case :fp-sort-ordered #t (is-sorted sorted))

;;; --- 4. fold building SortedMap from pairs ---

(define sm (sorted-map))
(define build-sm (lambda (i)
  (if (equal? i #0) :done
     (begin (sorted-map-put sm i (* i #3))
         (build-sm (- i #1))))))

(build-sm #500)

(test-case :fp-sm-size #t (> (sorted-map-size sm) #400))
(test-case :fp-sm-min #3 (sorted-map-get sm #1))

;;; --- 5. Higher-order: compose 10 functions, apply to 5,000 elements ---

(define compose2 (lambda (f g) (lambda (x) (f (g x)))))

(define compose-n (lambda (fns)
  (if (null? fns) (lambda (x) x)
     (compose2 (car fns) (compose-n (cdr fns))))))

(define add1 (lambda (x) (+ x #1)))
(define fns (cons add1 (cons add1 (cons add1 (cons add1 (cons add1
        (cons add1 (cons add1 (cons add1 (cons add1 (cons add1 nil)))))))))))

(define composed (compose-n fns))

;; Apply to 5,000 elements, sum results
(define compose-sum (lambda (n acc)
  (if (equal? n #0) acc
     (compose-sum (- n #1) (+ acc (composed #0))))))

;; Each application: 0 + 10 = 10; 5000 * 10 = 50000
(test-case :fp-compose-1k #10000 (compose-sum #1000 #0))
