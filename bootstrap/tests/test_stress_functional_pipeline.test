;;; Stress: Functional Pipeline
;;; Tier 3 — Closures + Data Structures + Pattern Matching + Recursion

;;; --- ADT definitions ---

(⊚≔ :Category (⌜ (:CatA)) (⌜ (:CatB)) (⌜ (:CatC)) (⌜ (:CatD)) (⌜ (:CatE)))

;;; --- Utility functions ---

(≔ list-len (λ (lst n)
  (? (∅? lst) n
     (list-len (▷ lst) (⊕ n #1)))))

(≔ fold-list (λ (f init lst)
  (? (∅? lst) init
     (fold-list f (f init (◁ lst)) (▷ lst)))))

;;; --- 1. 1,000 items classified into 5 categories via pattern match ---

(≔ category-map (⊞))

(≔ make-category (λ (i)
  (? (≡ (% i #5) #0) (⊚ :Category :CatA)
     (? (≡ (% i #5) #1) (⊚ :Category :CatB)
        (? (≡ (% i #5) #2) (⊚ :Category :CatC)
           (? (≡ (% i #5) #3) (⊚ :Category :CatD)
              (⊚ :Category :CatE)))))))

(≔ classify-cat (λ (cat)
  (∇ cat (⌜ (
    ((⊚ :Category :CatA) :a)
    ((⊚ :Category :CatB) :b)
    ((⊚ :Category :CatC) :c)
    ((⊚ :Category :CatD) :d)
    ((⊚ :Category :CatE) :e))))))

(≔ group-items (λ (i)
  (? (≡ i #0) :done
     (⪢
       (≔ cat (classify-cat (make-category i)))
       (≔ cur (⊞→ category-map cat))
       (⊞← category-map cat (? (∅? cur) #1 (⊕ cur #1)))
       (group-items (⊖ i #1))))))

(group-items #1000)

(⊨ :fp-5-categories #5 (⊞# category-map))
(⊨ :fp-each-category-200 #200 (⊞→ category-map :a))

;;; --- 2. Recursive tree map + fold via closures ---

(⊚≔ :Tree (⌜ (:Leaf :val)) (⌜ (:Node :left :right)))

(≔ tree-map (λ (f t)
  (? (⊚? t :Tree :Leaf)
     (⊚ :Tree :Leaf (f (⊚→ t :val)))
     (⊚ :Tree :Node (tree-map f (⊚→ t :left)) (tree-map f (⊚→ t :right))))))

(≔ tree-fold (λ (f init t)
  (? (⊚? t :Tree :Leaf)
     (f init (⊚→ t :val))
     (tree-fold f (tree-fold f init (⊚→ t :left)) (⊚→ t :right)))))

(≔ build-tree (λ (depth)
  (? (≡ depth #0) (⊚ :Tree :Leaf #1)
     (⊚ :Tree :Node (build-tree (⊖ depth #1)) (build-tree (⊖ depth #1))))))

;; Depth 8 = 256 leaves
(≔ big-tree (build-tree #8))

;; Map: double every leaf
(≔ doubled-tree (tree-map (λ (x) (⊗ x #2)) big-tree))

;; Fold: sum all leaves
(≔ tree-sum (tree-fold (λ (acc x) (⊕ acc x)) #0 doubled-tree))

;; 256 leaves * 2 = 512
(⊨ :fp-tree-map-fold #512 tree-sum)

;;; --- 3. Sort 200 elements via closure-based comparator ---

(≔ insert-sorted (λ (cmp x lst)
  (? (∅? lst) (⟨⟩ x ∅)
     (? (cmp x (◁ lst))
        (⟨⟩ x lst)
        (⟨⟩ (◁ lst) (insert-sorted cmp x (▷ lst)))))))

(≔ sort-list (λ (cmp lst)
  (? (∅? lst) ∅
     (insert-sorted cmp (◁ lst) (sort-list cmp (▷ lst))))))

(≔ unsorted (λ (n acc)
  (? (≡ n #0) acc
     (unsorted (⊖ n #1) (⟨⟩ (% (⊗ n #7919) #10000) acc)))))

(≔ unsorted-100 (unsorted #100 ∅))
(≔ sorted (sort-list (λ (a b) (< a b)) unsorted-100))

(⊨ :fp-sort-len #100 (list-len sorted #0))

;; Verify sorted
(≔ is-sorted (λ (lst)
  (? (∅? lst) #t
     (? (∅? (▷ lst)) #t
        (? (≤ (◁ lst) (◁ (▷ lst)))
           (is-sorted (▷ lst))
           #f)))))

(⊨ :fp-sort-ordered #t (is-sorted sorted))

;;; --- 4. fold building SortedMap from pairs ---

(≔ sm (⋔))
(≔ build-sm (λ (i)
  (? (≡ i #0) :done
     (⪢ (⋔← sm i (⊗ i #3))
         (build-sm (⊖ i #1))))))

(build-sm #500)

(⊨ :fp-sm-size #t (> (⋔# sm) #400))
(⊨ :fp-sm-min #3 (⋔→ sm #1))

;;; --- 5. Higher-order: compose 10 functions, apply to 5,000 elements ---

(≔ compose2 (λ (f g) (λ (x) (f (g x)))))

(≔ compose-n (λ (fns)
  (? (∅? fns) (λ (x) x)
     (compose2 (◁ fns) (compose-n (▷ fns))))))

(≔ add1 (λ (x) (⊕ x #1)))
(≔ fns (⟨⟩ add1 (⟨⟩ add1 (⟨⟩ add1 (⟨⟩ add1 (⟨⟩ add1
        (⟨⟩ add1 (⟨⟩ add1 (⟨⟩ add1 (⟨⟩ add1 (⟨⟩ add1 ∅)))))))))))

(≔ composed (compose-n fns))

;; Apply to 5,000 elements, sum results
(≔ compose-sum (λ (n acc)
  (? (≡ n #0) acc
     (compose-sum (⊖ n #1) (⊕ acc (composed #0))))))

;; Each application: 0 + 10 = 10; 5000 * 10 = 50000
(⊨ :fp-compose-1k #10000 (compose-sum #1000 #0))
