;;;
;;; Deep Integration: Macros + Effects + Pattern Matching + Closures
;;;

;;; --- Define macros ---

(macro when (c b) (quasiquote-tilde (if (~ c) (~ b) nil)))
(macro unless (c b) (quasiquote-tilde (if (~ c) nil (~ b))))
(macro twice (e) (quasiquote-tilde (+ (~ e) (~ e))))

;;; --- Effect declarations ---

(effect-def :State :get :put)
(effect-def :Logger :log)

;;; --- `when` macro inside effect handler -> performs effect when true ---

(test-case :when-true-effect :got-it
  (handle
    (when #t (perform :Logger :log :hello))
    (:Logger
      (:log (lambda (msg) :got-it)))))

;;; --- `when` macro with false -> returns âˆ…, skipping effect ---

(test-case :when-false-nil nil
  (handle
    (when #f (perform :Logger :log :hello))
    (:Logger
      (:log (lambda (msg) :should-not-reach)))))

;;; --- `unless` macro inside effect handler ---

(test-case :unless-false-effect :triggered
  (handle
    (unless #f (perform :Logger :log :world))
    (:Logger
      (:log (lambda (msg) :triggered)))))

(test-case :unless-true-nil nil
  (handle
    (unless #t (perform :Logger :log :world))
    (:Logger
      (:log (lambda (msg) :should-not-reach)))))

;;; --- begin sequencing multiple effect performs ---

(test-case :seq-effects (cons :a (cons :b (cons :c nil)))
  (handle-resume
    (begin (perform :Yield :value :a)
        (perform :Yield :value :b)
        (perform :Yield :value :c)
        nil)
    (:Yield
      (:value (lambda (k v) (cons v (k nil)))))))

;;; --- Custom macro `get-state` expands to effect perform ---

(macro get-state () (quasiquote-tilde (perform :State :get)))

(test-case :custom-macro-effect #42
  (handle-resume (get-state)
    (:State
      (:get (lambda (k) (k #42)))
      (:put (lambda (k v) (k nil))))))

;;; --- Custom macro wrapping effect with error fallback ---

(macro safe-fetch (eff op arg fallback)
  (quasiquote-tilde (define sf-result (perform (~ eff) (~ op) (~ arg)))
      (if (error? sf-result) (~ fallback) sf-result)))

;;; --- `twice` macro duplicating effect perform -> handler called twice ---

(test-case :twice-effect #20
  (handle-resume (twice (perform :State :get))
    (:State
      (:get (lambda (k) (k #10)))
      (:put (lambda (k v) (k nil))))))

;;; --- Custom `let1` macro with effect perform as bound value ---

(macro let1 (var val body) (quasiquote-tilde ((lambda ((~ var)) (~ body)) (~ val))))

(test-case :let1-effect #52
  (handle-resume (let1 x (perform :State :get) (+ x #10))
    (:State
      (:get (lambda (k) (k #42)))
      (:put (lambda (k v) (k nil))))))

;;; --- begin + yield-collect pattern ---

(effect-def :Yield :value)

(test-case :seq-yield-collect (cons #10 (cons #20 (cons #30 nil)))
  (handle-resume
    (begin (perform :Yield :value #10)
        (perform :Yield :value #20)
        (perform :Yield :value #30)
        nil)
    (:Yield
      (:value (lambda (k v) (cons v (k nil)))))))

;;; --- Nested `twice` macros applied to value ---

(test-case :nested-twice #84 (twice (twice #21)))

;;; --- Macro-generated pattern classification ---

(macro classify-num (n)
  (quasiquote-tilde (if (> (~ n) #0) :positive
        (if (< (~ n) #0) :negative
           :zero))))

(test-case :classify-pos :positive (classify-num #5))
(test-case :classify-neg :negative (classify-num (- #0 #3)))
(test-case :classify-zero :zero (classify-num #0))
