; Test: Deep Concurrency + Tracing Integration
; Verifies interaction between actors, channels, supervision and execution tracing

; ============ Helpers for event field access ============
(define ev-ts     (lambda (ev) (cdr (car ev))))
(define ev-sched  (lambda (ev) (cdr (car (cdr ev)))))
(define ev-actor  (lambda (ev) (cdr (car (cdr (cdr ev))))))
(define ev-kind   (lambda (ev) (cdr (car (cdr (cdr (cdr ev)))))))
(define ev-detail (lambda (ev) (cdr (car (cdr (cdr (cdr (cdr ev))))))))

; ============================================================
; Section 1: Multi-Actor Lifecycle Counting (4 tests)
; ============================================================
(actor-reset)
(chan-reset)
(trace-enable! #t)
(trace-clear)

(define ma1 (actor-spawn (lambda (self) :a)))
(define ma2 (actor-spawn (lambda (self) :b)))
(define ma3 (actor-spawn (lambda (self) :c)))
(define ma4 (actor-spawn (lambda (self) :d)))
(define ma5 (actor-spawn (lambda (self) :e)))
(actor-run #200)

(test-case (quote :multi-spawn-count) #5 (trace-count :SPAWN))
(test-case (quote :multi-die-count) #5 (trace-count :DIE))
(test-case (quote :multi-no-send) #0 (trace-count :SEND))
(test-case (quote :multi-resume-present) #t (>= (trace-count :RESUME) #5))

; ============================================================
; Section 2: Message Chain Trace (A→B→C) (5 tests)
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

; C receives and returns
(define actC (actor-spawn (lambda (self) (actor-receive))))
; B receives, forwards to C
(define actB (actor-spawn (lambda (self)
  (bind (actor-receive) (lambda (msg)
    (bind (actor-send actC :pong) (lambda (_)
      msg)))))))
; A sends to B
(define actA (actor-spawn (lambda (self)
  (bind (actor-send actB :ping) (lambda (_)
    :sent)))))
(actor-run #200)

(test-case (quote :chain-send-count) #2 (trace-count :SEND))
(test-case (quote :chain-recv-present) #t (>= (trace-count :RECV) #2))
(test-case (quote :chain-spawn-3) #3 (trace-count :SPAWN))
(test-case (quote :chain-die-3) #3 (trace-count :DIE))
(test-case (quote :chain-all-kinds-sum) #t
  (equal? (trace-count)
      (+ (+ (+ (+ (trace-count :SPAWN) (trace-count :SEND)) (trace-count :RECV))
              (+ (trace-count :DIE) (trace-count :RESUME)))
          (+ (+ (trace-count :YIELD) (trace-count :WAKE)) (trace-count :STEAL)))))

; ============================================================
; Section 3: Multiple Sends Trace Verification (3 tests)
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

; Receiver accepts 3 messages
(define pp-recv (actor-spawn (lambda (self)
  (bind (actor-receive) (lambda (m1)
  (bind (actor-receive) (lambda (m2)
  (bind (actor-receive) (lambda (m3)
    (cons m1 (cons m2 m3)))))))))))

; Sender1 sends 2, Sender2 sends 1 -> total 3 SENDs from 3 actors
(define pp-s1 (actor-spawn (lambda (self)
  (bind (actor-send pp-recv :p1) (lambda (_)
  (bind (actor-send pp-recv :p2) (lambda (_)
    :sent2)))))))
(define pp-s2 (actor-spawn (lambda (self)
  (bind (actor-send pp-recv :p3) (lambda (_)
    :sent1)))))
(actor-run #200)

(test-case (quote :multi-send-3) #3 (trace-count :SEND))
(test-case (quote :multi-recv-ge-3) #t (>= (trace-count :RECV) #3))
(test-case (quote :multi-send-spawn-3) #3 (trace-count :SPAWN))

; ============================================================
; Section 4: Channel Producer-Consumer Traces (4 tests)
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(define pch (chan-create))
(define producer (actor-spawn (lambda (self)
  (bind (chan-send pch :v1) (lambda (_)
  (bind (chan-send pch :v2) (lambda (_)
  (bind (chan-send pch :v3) (lambda (_)
  (bind (chan-close pch) (lambda (_)
    :produced)))))))))))
(define consumer (actor-spawn (lambda (self)
  (bind (chan-recv pch) (lambda (a)
  (bind (chan-recv pch) (lambda (b)
  (bind (chan-recv pch) (lambda (c)
    (cons a (cons b c)))))))))))
(actor-run #200)

(test-case (quote :chan-pc-send-3) #3 (trace-count :CHAN_SEND))
(test-case (quote :chan-pc-recv-3) #3 (trace-count :CHAN_RECV))
(test-case (quote :chan-pc-close-1) #1 (trace-count :CHAN_CLOSE))
(test-case (quote :chan-pc-actors-die) #2 (trace-count :DIE))

; ============================================================
; Section 5: Multiple Channels Isolation (3 tests)
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(define mch1 (chan-create))
(define mch2 (chan-create))
; Actor sends 2 items on ch1 and 1 on ch2
(define multi-sender (actor-spawn (lambda (self)
  (bind (chan-send mch1 :x1) (lambda (_)
  (bind (chan-send mch1 :x2) (lambda (_)
  (bind (chan-send mch2 :y1) (lambda (_)
    :sent)))))))))
; Another actor drains both
(define multi-reader (actor-spawn (lambda (self)
  (bind (chan-recv mch1) (lambda (a)
  (bind (chan-recv mch1) (lambda (b)
  (bind (chan-recv mch2) (lambda (c)
    (cons a (cons b c)))))))))))
(actor-run #200)

(test-case (quote :multi-chan-total-send) #3 (trace-count :CHAN_SEND))
(test-case (quote :multi-chan-total-recv) #3 (trace-count :CHAN_RECV))
; Verify CHAN_SEND events exist and first has detail > 0 (channel ID)
(define cs-events (trace-read :CHAN_SEND))
(test-case (quote :multi-chan-events-nonempty) #t
  (and (not (equal? cs-events nil))
      (>= (ev-detail (car cs-events)) #0)))

; ============================================================
; Section 6: Blocking Channel + RESUME Trace (3 tests)
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(define bch (chan-create #1))
; Sender sends 2 items — second will block (capacity=1)
(define bsender (actor-spawn (lambda (self)
  (bind (chan-send bch :a) (lambda (_)
  (bind (chan-send bch :b) (lambda (_)
    :sent-both)))))))
; Consumer drains both
(define brecver (actor-spawn (lambda (self)
  (bind (chan-recv bch) (lambda (v1)
  (bind (chan-recv bch) (lambda (v2)
    (cons v1 v2))))))))
(actor-run #200)

(test-case (quote :blocking-chan-send-2) #2 (trace-count :CHAN_SEND))
(test-case (quote :blocking-chan-recv-2) #2 (trace-count :CHAN_RECV))
; Blocking causes wake events when channel drains
(test-case (quote :blocking-chan-resume) #t (>= (trace-count :RESUME) (trace-count :SPAWN)))

; ============================================================
; Section 7: Link/Monitor/Exit Signal Traces (5 tests)
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

; D: target for exit signal — waits for message
(define actD (actor-spawn (lambda (self) (actor-receive))))
; C: monitored — waits, then completes when sent :go
(define actCC (actor-spawn (lambda (self) (actor-receive))))
; B: waits for :crash msg, then crashes (must be alive when A links)
(define actBB (actor-spawn (lambda (self)
  (bind (actor-receive) (lambda (msg)
    (error :crash :boom))))))
; A: links to B, monitors C, sends exit signal to D, then tells B to crash
(define actAA (actor-spawn (lambda (self)
  (bind (actor-trap-exit #t) (lambda (_)
  (bind (actor-link actBB) (lambda (_)
  (bind (actor-monitor actCC) (lambda (_)
  (bind (actor-exit actD :killed) (lambda (_)
  (bind (actor-send actCC :go) (lambda (_)
  (bind (actor-send actBB :crash) (lambda (_)
    (actor-receive))))))))))))))))
(actor-run #200)

(test-case (quote :link-event-traced) #t (>= (trace-count :LINK) #1))
(test-case (quote :monitor-event-traced) #t (>= (trace-count :MONITOR) #1))
(test-case (quote :exit-signal-traced) #t (>= (trace-count :EXIT_SIGNAL) #1))
; B crashes, D killed, C finishes, A gets :EXIT from link
; At least B, C, D die
(test-case (quote :link-die-propagates) #t (>= (trace-count :DIE) #2))
(test-case (quote :supervision-spawn-count) #4 (trace-count :SPAWN))

; ============================================================
; Section 8: Supervisor Restart in Trace (3 tests)
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(define sch (chan-create))
(define crashy (lambda (self)
  (bind (chan-send sch :alive) (lambda (_)
    (bind (actor-receive) (lambda (msg)
      (if (equal? msg :crash)
         (error :crashed :boom)
         msg)))))))
(define sup-tr (sup-start :one-for-one (cons crashy nil)))
(actor-run #100)
(define spawn-before (trace-count :SPAWN))
; Tell child to crash
(define kids-before (sup-children sup-tr))
(actor-send (car kids-before) :crash)
(actor-run #200)
(define spawn-after (trace-count :SPAWN))

; At least the initial child was spawned
(test-case (quote :sup-initial-spawn) #t (>= spawn-before #1))
; Child died from crash
(test-case (quote :sup-child-die) #t (>= (trace-count :DIE) #1))
; Restart created extra spawn
(test-case (quote :sup-extra-spawn) #t (> spawn-after spawn-before))

; ============================================================
; Section 9: Event Detail Field Verification (5 tests)
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(define det-recv (actor-spawn (lambda (self) (actor-receive))))
(define det-send (actor-spawn (lambda (self)
  (bind (actor-send det-recv :msg) (lambda (_) :sent)))))
(define det-ch (chan-create))
(define det-chan-actor (actor-spawn (lambda (self) (chan-send det-ch :val))))
(actor-run #200)

; SPAWN events have detail >= 0 (parent ID or 0)
(define spawn-evts (trace-read :SPAWN))
(test-case (quote :detail-spawn-exists) #t
  (and (not (equal? spawn-evts nil))
      (>= (ev-detail (car spawn-evts)) #0)))

; SEND event detail > 0 (target actor ID)
(define send-evts (trace-read :SEND))
(test-case (quote :detail-send-target) #t
  (and (not (equal? send-evts nil))
      (> (ev-detail (car send-evts)) #0)))

; CHAN_SEND event detail >= 0 (channel ID)
(define chan-send-evts (trace-read :CHAN_SEND))
(test-case (quote :detail-chan-send-id) #t
  (and (not (equal? chan-send-evts nil))
      (>= (ev-detail (car chan-send-evts)) #0)))

; SPAWN event actor field > 0 (new actor ID)
(test-case (quote :detail-actor-field) #t
  (> (ev-actor (car spawn-evts)) #0))

; Event kind field = :SPAWN
(test-case (quote :detail-kind-field) :SPAWN
  (ev-kind (car spawn-evts)))

; ============================================================
; Section 10: Filter Accuracy Under Load (4 tests)
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

; 8 actors: 4 senders, 4 receivers
(define lr1 (actor-spawn (lambda (self) (actor-receive))))
(define lr2 (actor-spawn (lambda (self) (actor-receive))))
(define lr3 (actor-spawn (lambda (self) (actor-receive))))
(define lr4 (actor-spawn (lambda (self) (actor-receive))))
(define ls1 (actor-spawn (lambda (self) (bind (actor-send lr1 :m) (lambda (_) :ok)))))
(define ls2 (actor-spawn (lambda (self) (bind (actor-send lr2 :m) (lambda (_) :ok)))))
(define ls3 (actor-spawn (lambda (self) (bind (actor-send lr3 :m) (lambda (_) :ok)))))
(define ls4 (actor-spawn (lambda (self) (bind (actor-send lr4 :m) (lambda (_) :ok)))))
; 2 channel ops
(define lch (chan-create))
(define lch-actor (actor-spawn (lambda (self)
  (bind (chan-send lch :v1) (lambda (_)
  (bind (chan-send lch :v2) (lambda (_)
    :ch-done)))))))
(actor-run #200)

(define total (trace-count))
(define sum-kinds (+ (+ (+ (+ (trace-count :SPAWN) (trace-count :SEND)) (trace-count :RECV))
                    (+ (trace-count :DIE) (trace-count :RESUME)))
                (+ (+ (trace-count :YIELD) (trace-count :WAKE))
                    (+ (trace-count :STEAL) (+ (trace-count :CHAN_SEND) (trace-count :CHAN_RECV))))))
(test-case (quote :filter-sum-matches-total) #t (equal? total sum-kinds))

; No timer events used
(test-case (quote :filter-nonexistent-zero) #0 (trace-count :TIMER_FIRE))

; 9 actors spawned (4 recv + 4 send + 1 chan)
(test-case (quote :filter-spawn-exact) #9 (trace-count :SPAWN))

; 4 actor-send calls from senders
(test-case (quote :filter-send-exact) #4 (trace-count :SEND))

; ============================================================
; Section 11: Flight Recorder Snapshot Semantics (3 tests)
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

; Generate 20+ events
(define sn1 (actor-spawn (lambda (self) :a)))
(define sn2 (actor-spawn (lambda (self) :b)))
(define sn3 (actor-spawn (lambda (self) :c)))
(define sn4 (actor-spawn (lambda (self) :d)))
(define sn5 (actor-spawn (lambda (self) :e)))
(define sn6 (actor-spawn (lambda (self) :f)))
(define sn7 (actor-spawn (lambda (self) :g)))
(actor-run #200)

; Snapshot last 5 — should return non-empty, <= 5
(define snap5 (trace-snapshot #5))
(test-case (quote :snap-last-5) #t (not (equal? snap5 nil)))

; Snapshot large N — count = total
(define snap-big (trace-snapshot #9999))
(define snap-big-total (trace-count))
(test-case (quote :snap-large-n) #t (> snap-big-total #0))

; Clear then snapshot -> empty
(trace-clear)
(define snap-empty (trace-snapshot #5))
(test-case (quote :snap-after-clear) nil snap-empty)

; ============================================================
; Section 12: Causal Tracing Through Message Chain (2 tests)
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

; Actor enables causal tracing (pass #t) and sends
(define causal-recv (actor-spawn (lambda (self) (actor-receive))))
(define causal-sender (actor-spawn (lambda (self)
  (bind (trace-causal #t) (lambda (ok)
    (bind (actor-send causal-recv :traced-msg) (lambda (_)
      ok)))))))
(actor-run #200)

; trace-causal inside actor returns #t
(test-case (quote :causal-enable-ok) #t (actor-result causal-sender))

; SEND events present after causal send
(test-case (quote :causal-send-traced) #t (> (trace-count :SEND) #0))

; ============================================================
; Section 13: Trace Toggle Mid-Workload (3 tests)
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

; Phase 1: tracing ON — spawn A
(trace-enable! #t)
(define togA (actor-spawn (lambda (self) :a)))
(actor-run #200)
(define count-phase1 (trace-count))
(test-case (quote :toggle-phase1-nonzero) #t (> count-phase1 #0))

; Phase 2: tracing OFF — spawn B
(trace-enable! #f)
(actor-reset)
(define togB (actor-spawn (lambda (self) :b)))
(actor-run #200)
(define count-phase2 (trace-count))
(test-case (quote :toggle-phase2-same) #t (equal? count-phase2 count-phase1))

; Phase 3: tracing ON — spawn C
(trace-enable! #t)
(actor-reset)
(define togC (actor-spawn (lambda (self) :c)))
(actor-run #200)
(define count-phase3 (trace-count))
(test-case (quote :toggle-phase3-grows) #t (> count-phase3 count-phase1))

; ============================================================
; Section 14: Rapid Lifecycle Stress (2 tests)
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)
(trace-enable! #t)

(define s01 (actor-spawn (lambda (self) :ok)))
(define s02 (actor-spawn (lambda (self) :ok)))
(define s03 (actor-spawn (lambda (self) :ok)))
(define s04 (actor-spawn (lambda (self) :ok)))
(define s05 (actor-spawn (lambda (self) :ok)))
(define s06 (actor-spawn (lambda (self) :ok)))
(define s07 (actor-spawn (lambda (self) :ok)))
(define s08 (actor-spawn (lambda (self) :ok)))
(define s09 (actor-spawn (lambda (self) :ok)))
(define s10 (actor-spawn (lambda (self) :ok)))
(define s11 (actor-spawn (lambda (self) :ok)))
(define s12 (actor-spawn (lambda (self) :ok)))
(define s13 (actor-spawn (lambda (self) :ok)))
(define s14 (actor-spawn (lambda (self) :ok)))
(define s15 (actor-spawn (lambda (self) :ok)))
(define s16 (actor-spawn (lambda (self) :ok)))
(define s17 (actor-spawn (lambda (self) :ok)))
(define s18 (actor-spawn (lambda (self) :ok)))
(define s19 (actor-spawn (lambda (self) :ok)))
(define s20 (actor-spawn (lambda (self) :ok)))
(actor-run #200)

(test-case (quote :stress-spawn-20) #20 (trace-count :SPAWN))
(test-case (quote :stress-die-20) #20 (trace-count :DIE))

; ============================================================
; Cleanup
; ============================================================
(trace-enable! #f)
(trace-clear)
(actor-reset)
(chan-reset)
