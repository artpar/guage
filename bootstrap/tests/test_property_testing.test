; Test file for property-based testing primitives
; Tests generators, property tests, and shrinking

; ============ Helper: List Length ============
(define len (lambda (lst)
  (if (null? lst)
     #0
     (+ #1 (len (cdr lst))))))

; ============ Generator Tests ============

; Test gen-int returns number in range [1, 10]
(define test-gen-int (gen-int #1 #10))
(test-case :gen-int-is-number #t (number? test-gen-int))
(test-case :gen-int-in-range #t (and (>= test-gen-int #1) (<= test-gen-int #10)))

; Test gen-int with single value range
(test-case :gen-int-single #5 (gen-int #5 #5))

; Test gen-int error on invalid range
(test-case :gen-int-invalid-range #t (error? (gen-int #10 #1)))

; Test gen-bool returns boolean
(test-case :gen-bool-returns-bool #t (boolean? (gen-bool)))

; Test gen-symbol from list
(define test-symbols (cons :a (cons :b (cons :c nil))))
(define test-result (gen-symbol test-symbols))
(test-case :gen-symbol-in-list #t
   (or (or (equal? test-result :a) (equal? test-result :b)) (equal? test-result :c)))

; Test gen-symbol error on empty list
(test-case :gen-symbol-empty #t (error? (gen-symbol nil)))

; Test gen-list with constant generator
(define const-gen (lambda () #42))
(define const-list (gen-list const-gen #5))
(test-case :gen-list-constant #5 (len const-list))

; Test gen-list with zero size
(define zero-gen (lambda () #1))
(test-case :gen-list-zero nil (gen-list zero-gen #0))

; Test gen-list with random integers
(define int-gen (lambda () (gen-int #1 #100)))
(define int-list (gen-list int-gen #10))
(test-case :gen-list-integers #10 (len int-list))

; ============ Property-Based Test Tests ============

; Simple property: all generated numbers are positive
(test-property :all-positive
        (lambda (n) (> n #0))
        (lambda () (gen-int #1 #100)))

; Property: list length matches requested size
(test-property :list-length-correct
        (lambda (lst) (equal? (len lst) #5))
        (lambda () (gen-list (lambda () (gen-int #1 #10)) #5)))

; Property: boolean is always true or false
(test-property :bool-valid
        (lambda (b) (or (equal? b #t) (equal? b #f)))
        (lambda () (gen-bool)))

; Property: generated integer is in range
(test-property :int-in-range
        (lambda (n) (and (>= n #-10) (<= n #10)))
        (lambda () (gen-int #-10 #10)))

; Property: list length is preserved (simpler test without reverse)
(define count (lambda (lst)
  (if (null? lst)
     #0
     (+ #1 (count (cdr lst))))))

(test-property :list-length-preserved
        (lambda (lst) (equal? (len lst) (count lst)))
        (lambda () (gen-list (lambda () (gen-int #1 #10)) #5)))

