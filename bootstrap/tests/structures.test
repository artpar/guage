; Structure Primitives Tests - Phase 2C Week 1

; Define Point structure
(struct-define (quote :Point) (quote :x) (quote :y))

; Create point instance
(define p1 (struct-create (quote :Point) #3 #4))

; Test field access
(test-case (quote :point-x) #3 (struct-get p1 (quote :x)))
(test-case (quote :point-y) #4 (struct-get p1 (quote :y)))

; Define Rectangle structure
(struct-define (quote :Rectangle) (quote :width) (quote :height) (quote :color))

; Create rectangle instance
(define r1 (struct-create (quote :Rectangle) #10 #20 (quote :blue)))

; Test rectangle fields
(test-case (quote :rect-width) #10 (struct-get r1 (quote :width)))
(test-case (quote :rect-height) #20 (struct-get r1 (quote :height)))
(test-case (quote :rect-color) (quote :blue) (struct-get r1 (quote :color)))

; Create another point
(define p2 (struct-create (quote :Point) #7 #8))
(test-case (quote :point2-x) #7 (struct-get p2 (quote :x)))
(test-case (quote :point2-y) #8 (struct-get p2 (quote :y)))

; Test field update (immutable)
(define p3 (struct-set p1 (quote :x) #100))
(test-case (quote :update-field-x) #100 (struct-get p3 (quote :x)))
(test-case (quote :update-field-y-unchanged) #4 (struct-get p3 (quote :y)))
(test-case (quote :original-unchanged) #3 (struct-get p1 (quote :x)))

; Test type checking
(test-case (quote :is-point) #t (struct? p1 (quote :Point)))
(test-case (quote :is-rect) #t (struct? r1 (quote :Rectangle)))
(test-case (quote :not-rect) #f (struct? p1 (quote :Rectangle)))
(test-case (quote :not-point) #f (struct? r1 (quote :Point)))
(test-case (quote :number-not-struct) #f (struct? #42 (quote :Point)))

; ============ Node/ADT Structure Tests ============

; Define List ADT with two variants
(adt-define (quote :List) (cons (quote :Nil) nil) (cons (quote :Cons) (cons (quote :head) (cons (quote :tail) nil))))

; Create empty list (Nil variant)
(define empty-list (adt-create (quote :List) (quote :Nil)))

; Test Nil variant checking
(test-case (quote :nil-is-list-nil) #t (adt? empty-list (quote :List) (quote :Nil)))
(test-case (quote :nil-not-cons) #f (adt? empty-list (quote :List) (quote :Cons)))

; Create list with one element (Cons variant)
(define cons1 (adt-create (quote :List) (quote :Cons) #1 empty-list))

; Test Cons variant checking
(test-case (quote :cons1-is-list-cons) #t (adt? cons1 (quote :List) (quote :Cons)))
(test-case (quote :cons1-not-nil) #f (adt? cons1 (quote :List) (quote :Nil)))

; Test field access on Cons
(test-case (quote :cons1-head) #1 (adt-get cons1 (quote :head)))
(test-case (quote :cons1-tail-is-nil) #t (adt? (adt-get cons1 (quote :tail)) (quote :List) (quote :Nil)))

; Create list with two elements
(define cons2 (adt-create (quote :List) (quote :Cons) #2 cons1))

; Test nested list
(test-case (quote :cons2-head) #2 (adt-get cons2 (quote :head)))
(test-case (quote :cons2-tail-is-cons) #t (adt? (adt-get cons2 (quote :tail)) (quote :List) (quote :Cons)))
(test-case (quote :cons2-tail-head) #1 (adt-get (adt-get cons2 (quote :tail)) (quote :head)))

; Define Tree ADT with two variants
(adt-define (quote :Tree) (cons (quote :Leaf) (cons (quote :value) nil)) (cons (quote :Node) (cons (quote :left) (cons (quote :right) nil))))

; Create leaf
(define leaf (adt-create (quote :Tree) (quote :Leaf) #42))

; Test leaf
(test-case (quote :leaf-is-tree-leaf) #t (adt? leaf (quote :Tree) (quote :Leaf)))
(test-case (quote :leaf-not-node) #f (adt? leaf (quote :Tree) (quote :Node)))
(test-case (quote :leaf-value) #42 (adt-get leaf (quote :value)))

; Create tree node
(define left-leaf (adt-create (quote :Tree) (quote :Leaf) #10))
(define right-leaf (adt-create (quote :Tree) (quote :Leaf) #20))
(define node (adt-create (quote :Tree) (quote :Node) left-leaf right-leaf))

; Test node
(test-case (quote :node-is-tree-node) #t (adt? node (quote :Tree) (quote :Node)))
(test-case (quote :node-not-leaf) #f (adt? node (quote :Tree) (quote :Leaf)))
(test-case (quote :node-left-is-leaf) #t (adt? (adt-get node (quote :left)) (quote :Tree) (quote :Leaf)))
(test-case (quote :node-right-is-leaf) #t (adt? (adt-get node (quote :right)) (quote :Tree) (quote :Leaf)))
(test-case (quote :node-left-value) #10 (adt-get (adt-get node (quote :left)) (quote :value)))
(test-case (quote :node-right-value) #20 (adt-get (adt-get node (quote :right)) (quote :value)))

; ============ Graph Structure Tests ============

; Define simple generic graph
(graph-define (quote :Graph) (quote :generic) (quote :nodes) (quote :edges))

; Create empty graph
(define g0 (graph-create (quote :Graph)))

; Test empty graph properties
(test-case (quote :empty-graph-nodes) nil (graph-query g0 (quote :nodes)))
(test-case (quote :empty-graph-edges) nil (graph-query g0 (quote :edges)))

; Add first node
(define g1 (graph-add-node g0 #0))

; Test single node (nodes list is not empty)
(test-case (quote :graph-has-node) #t (pair? (graph-query g1 (quote :nodes))))

; Add second node
(define g2 (graph-add-node g1 #1))

; Test two nodes (nodes list has tail that is non-empty)
(test-case (quote :graph-has-two-nodes) #t (pair? (cdr (graph-query g2 (quote :nodes)))))

; Test immutability - original unchanged
(test-case (quote :graph-original-unchanged) nil (graph-query g0 (quote :nodes)))

; Create fresh graph for edge testing
(define eg (graph-create (quote :Graph)))
(define eg (graph-add-node eg #10))
(define eg (graph-add-node eg #20))

; Add single edge
(define eg2 (graph-add-edge eg #10 #20 (quote :connects)))

; Test edge exists
(test-case (quote :graph-has-edge) #t (pair? (graph-query eg2 (quote :edges))))

; Test graph type checking
(test-case (quote :is-graph) #t (graph? g0 (quote :Graph)))
(test-case (quote :is-graph-with-nodes) #t (graph? g2 (quote :Graph)))
(test-case (quote :number-not-graph) #f (graph? #42 (quote :Graph)))
(test-case (quote :struct-not-graph) #f (graph? p1 (quote :Graph)))

; Define CFG graph type
(graph-define (quote :CFG) (quote :cfg) (quote :nodes) (quote :edges) (quote :entry) (quote :exit))

; Create CFG instance
(define cfg (graph-create (quote :CFG)))

; Test CFG is a graph
(test-case (quote :cfg-is-graph) #t (graph? cfg (quote :CFG)))

; Test CFG entry/exit (should be nil for empty CFG)
(test-case (quote :cfg-no-entry) nil (graph-query cfg (quote :entry)))
(test-case (quote :cfg-no-exit) nil (graph-query cfg (quote :exit)))
