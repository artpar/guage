; Day 125: FFI with JIT-Compiled Stubs
; Test: Load libm, bind math functions, call them

; ===== Library Loading =====

; Load libm
(define libm (ffi-dlopen "libm"))
(assert (ffi-ptr? libm) :libm-loaded)
(test-case (quote :ffi-tag) "dlhandle" (ffi-type-tag libm))

; ===== Function Binding =====

; Bind sin â€” returns CELL_BUILTIN (directly callable!)
(define sin (ffi-bind libm "sin" (cons :double nil) :double))

; Bind sqrt
(define sqrt (ffi-bind libm "sqrt" (cons :double nil) :double))

; Bind floor
(define floor (ffi-bind libm "floor" (cons :double nil) :double))

; Bind ceil
(define ceil (ffi-bind libm "ceil" (cons :double nil) :double))

; Bind pow (two args)
(define pow (ffi-bind libm "pow" (cons :double (cons :double nil)) :double))

; Bind fabs
(define fabs (ffi-bind libm "fabs" (cons :double nil) :double))

; ===== Direct Calls =====

; sin(0) = 0
(test-case (quote :sin-zero) #0 (sin #0))

; sin(pi/2) string 1
(assert (< (fabs (- (sin #1.5707963267948966) #1)) #0.0001) :sin-halfpi)

; sqrt(4) = 2
(test-case (quote :sqrt-4) #2 (sqrt #4))

; sqrt(9) = 3
(test-case (quote :sqrt-9) #3 (sqrt #9))

; sqrt(0) = 0
(test-case (quote :sqrt-0) #0 (sqrt #0))

; pow(2, 10) = 1024
(test-case (quote :pow-2-10) #1024 (pow #2 #10))

; pow(3, 3) = 27
(test-case (quote :pow-3-3) #27 (pow #3 #3))

; floor(3.7) = 3
(test-case (quote :floor-3.7) #3 (floor #3.7))

; ceil(3.2) = 4
(test-case (quote :ceil-3.2) #4 (ceil #3.2))

; fabs(-42) = 42
(test-case (quote :fabs-neg) #42 (fabs #-42))

; ===== Error Handling =====

; Bad library name -> error
(assert (error? (ffi-dlopen "no_such_lib_xyz_12345")) :bad-lib)

; Bad symbol name -> error
(assert (error? (ffi-bind libm "no_such_fn_xyz" (cons :double nil) :double)) :bad-sym)

; ===== NULL Pointer =====

(assert (ffi-null? (ffi-null)) :null-is-null)
(assert (not (ffi-null? libm)) :handle-not-null)

; ===== FFI Type Predicate =====

(assert (ffi-ptr? libm) :libm-is-ffi)
(assert (not (ffi-ptr? #42)) :num-not-ffi)
(assert (not (ffi-ptr? "hello")) :str-not-ffi)

; ===== Type Error Propagation =====

; Pass string to double-expecting function -> error
(assert (error? (sin "hello")) :type-error-str)

; Pass boolean to double-expecting function -> error
(assert (error? (sin #t)) :type-error-bool)

; ===== String Marshalling =====

; String to pointer and back
(define ptr (ffi-str->ptr "hello world"))
(assert (ffi-ptr? ptr) :str-to-ptr)
(test-case (quote :ptr-tag) "cstring" (ffi-type-tag ptr))
(test-case (quote :read-back) "hello world" (ffi-read-cstr ptr))

; ===== Address =====

(assert (> (ffi-addr libm) #0) :addr-positive)
(test-case (quote :null-addr) #0 (ffi-addr (ffi-null)))

; ===== Close =====

(ffi-dlclose libm)

; ===== Summary =====
(print "Day 125: FFI JIT tests complete")
