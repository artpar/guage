;;; Stress: Modules + Effects
;;; Tier 2 â€” Two-feature combination stress test

;;; --- Load stdlib modules ---

(load "bootstrap/stdlib/math.scm")

;;; --- Effect declarations ---

(effect-def :Compute :calc)
(effect-def :Logger :log)

;;; --- 1. Module function used inside effect handler, 1,000 iterations ---

(define mod-eff-loop (lambda (n acc)
  (if (equal? n #0) acc
     (begin
       (define result
         (handle (perform :Compute :calc n)
           (:Compute
             (:calc (lambda (x) (* x #2))))))
       (mod-eff-loop (- n #1) (+ acc result))))))

;; Sum of 2*i for i=1..1000 = 2 * 500500 = 1001000
(test-case :me-module-in-handler #1001000 (mod-eff-loop #1000 #0))

;;; --- 2. Effect handler wrapping computation 10,000 times ---

(define wrap-loop (lambda (n acc)
  (if (equal? n #0) acc
     (wrap-loop (- n #1)
       (+ acc
         (handle (perform :Compute :calc #1)
           (:Compute (:calc (lambda (x) x)))))))))

(test-case :me-wrap-10k #10000 (wrap-loop #10000 #0))

;;; --- 3. Cross-module computation with effect ---

(define compute-with-effect (lambda (x)
  (handle (perform :Compute :calc x)
    (:Compute (:calc (lambda (v) (+ v (* v v))))))))

(define cross-loop (lambda (n acc)
  (if (equal? n #0) acc
     (cross-loop (- n #1)
       (+ acc (compute-with-effect n))))))

;; Each iteration: n + n*n = n(1+n)
;; Sum of n(1+n) for n=1..1000
(define cross-result (cross-loop #1000 #0))
(test-case :me-cross-module #t (> cross-result #0))

;;; --- 4. Nested effects with module functions ---

(test-case :me-nested-effects #42
  (handle
    (handle (perform :Compute :calc #21)
      (:Compute (:calc (lambda (x) (* x #2)))))
    (:Logger (:log (lambda (msg) msg)))))

;;; --- 5. Namespace isolation: same-named functions in different contexts ---

(define local-add (lambda (x y) (+ x y)))

(define ns-loop (lambda (n acc)
  (if (equal? n #0) acc
     (begin
       (define r1 (handle (perform :Compute :calc n)
                 (:Compute (:calc (lambda (x) (local-add x #1))))))
       (define r2 (handle (perform :Compute :calc n)
                 (:Compute (:calc (lambda (x) (* x #2))))))
       (ns-loop (- n #1) (+ acc (+ r1 r2)))))))

;; Each iteration: (n+1) + (n*2) = 3n+1
;; Sum of (3n+1) for n=1..1000 = 3*500500 + 1000 = 1502500
(test-case :me-namespace-1k #1502500 (ns-loop #1000 #0))
