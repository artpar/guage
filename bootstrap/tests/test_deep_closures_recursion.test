;;;
;;; Deep Integration: Closures + Recursion (TCO) + Effects + Box (mutable refs) + Sequencing
;;;

;;; --- Closure-returned function used as effect handler operation ---

(effect-def :Compute :calc)

(define make-doubler (lambda () (lambda (x) (* x #2))))

(test-case :closure-in-handler #20
  (handle (perform :Compute :calc #10)
    (:Compute
      (:calc (make-doubler)))))

;;; --- Recursive function that yields values via resumable effect (countdown yield-collect) ---

(effect-def :Yield :value)

(define countdown-yield (lambda (n)
  (if (equal? n #0) nil
     (begin (perform :Yield :value n) (countdown-yield (- n #1))))))

(test-case :yield-countdown (cons #3 (cons #2 (cons #1 nil)))
  (handle-resume (countdown-yield #3)
    (:Yield
      (:value (lambda (k v) (cons v (k nil)))))))

;;; --- TCO with large N via accumulator ---

(define sum-acc (lambda (n acc)
  (if (equal? n #0) acc
     (sum-acc (- n #1) (+ acc n)))))

(test-case :tco-large #50005000 (sum-acc #10000 #0))

;;; --- Box mutation inside recursive function ---

(define counter (box #0))
(define inc-n (lambda (n)
  (if (equal? n #0) (unbox counter)
     (begin (box-set! counter (+ (unbox counter) #1))
         (inc-n (- n #1))))))

(inc-n #100)
(test-case :box-recursive #100 (unbox counter))

;;; --- Box mutation inside effect handler ---

(define log-box (box nil))

(effect-def :Logger :log)

(test-case :box-in-handler :logged
  (handle
    (begin (perform :Logger :log :hello) :logged)
    (:Logger
      (:log (lambda (msg) (begin (box-set! log-box msg) :logged))))))

(test-case :box-after-handler :hello (unbox log-box))

;;; --- Higher-order: make-adder -> apply-n-times recursive ---

(define make-adder (lambda (n) (lambda (x) (+ x n))))
(define add5 (make-adder #5))

(define apply-n-times (lambda (f n x)
  (if (equal? n #0) x
     (apply-n-times f (- n #1) (f x)))))

(test-case :apply-n-times #50 (apply-n-times add5 #10 #0))

;;; --- Mutual recursion (even?/odd?) ---

(define my-even? (lambda (n)
  (if (equal? n #0) #t (my-odd? (- n #1)))))

(define my-odd? (lambda (n)
  (if (equal? n #0) #f (my-even? (- n #1)))))

(test-case :mutual-even #t (my-even? #10))
(test-case :mutual-odd  #t (my-odd? #7))

;;; --- Recursive map over list using closure ---

(define my-map (lambda (f lst)
  (if (null? lst) nil
     (cons (f (car lst)) (my-map f (cdr lst))))))

(test-case :map-closure #t
  (deep-equal? (my-map (lambda (x) (* x #3)) (cons #1 (cons #2 (cons #3 nil))))
     (cons #3 (cons #6 (cons #9 nil)))))

;;; --- Recursive effect accumulation (counter via resumable) ---

(effect-def :Counter :inc :get)

(test-case :effect-counter #5
  (handle-resume
    (begin
      (perform :Counter :inc)
      (perform :Counter :inc)
      (perform :Counter :inc)
      (perform :Counter :inc)
      (perform :Counter :inc)
      (perform :Counter :get))
    (:Counter
      (:inc (lambda (k) (+ #1 (k nil))))
      (:get (lambda (k) (k #0))))))
