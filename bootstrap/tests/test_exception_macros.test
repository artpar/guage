#!/usr/bin/env guage
; Test suite for exception handling macros
; Tests all macros in stdlib/macros_exception.scm

(print "Testing Exception Handling Macros...")

; Load the exception macros
(load "bootstrap/stdlib/macros_exception.scm")

; ============================================================================
; Test: try-with (try-with)
; ============================================================================

(print "\nTesting try-with (try-with)...")

; Success case - no error, handler not called
(test-case :try-success
   #3
   (try-with (/ #6 #2) (lambda (e) :error-handled)))

; Error case - handler called
(test-case :try-error
   :handled
   (try-with (/ #1 #0) (lambda (e) :handled)))

; Handler receives error value
(test-case :try-receives-error
   #t
   (try-with (/ #1 #0) (lambda (e) (error? e))))

; ============================================================================
; Test: try-or (try-or)
; ============================================================================

(print "Testing try-or (try-or)...")

; Success case - returns result
(test-case :try-or-success
   #3
   (try-or (/ #6 #2) :default))

; Error case - returns default
(test-case :try-or-error
   :default
   (try-or (/ #1 #0) :default))

; Default is number
(test-case :try-or-num-default
   #0
   (try-or (/ #1 #0) #0))

; Default is nil
(test-case :try-or-nil-default
   nil
   (try-or (/ #1 #0) nil))

; ============================================================================
; Test: ignore-errors (ignore-errors)
; ============================================================================

(print "Testing ignore-errors (ignore-errors)...")

; Success case - returns result
(test-case :ignore-success
   #3
   (ignore-errors (/ #6 #2)))

; Error case - returns nil
(test-case :ignore-error
   nil
   (ignore-errors (/ #1 #0)))

; Nested expression success
(test-case :ignore-nested
   #5
   (ignore-errors (+ #2 #3)))

; ============================================================================
; Test: try (error-type?)
; ============================================================================

(print "Testing try (error-type?)...")

; Create test errors
(define div-error (error :div-by-zero #0))
(define not-found-error (error :not-found "x"))

; Match correct type
(test-case :errtype-match
   #t
   (try div-error :div-by-zero))

; No match different type
(test-case :errtype-no-match
   #f
   (try div-error :not-found))

; Not an error at all
(test-case :errtype-not-error
   #f
   (try #42 :any))

; Match :not-found
(test-case :errtype-not-found
   #t
   (try not-found-error :not-found))

; ============================================================================
; Test: error-data-safe (error-data)
; ============================================================================

(print "Testing error-data-safe (error-data)...")

; Extract data from error
(test-case :errdata-extract
   #0
   (error-data-safe (error :div-by-zero #0)))

; Extract string data
(test-case :errdata-string
   "missing key"
   (error-data-safe (error :not-found "missing key")))

; Not an error returns nil
(test-case :errdata-not-error
   nil
   (error-data-safe #42))

; ============================================================================
; Test: match-error (error-case)
; ============================================================================

(print "Testing match-error (error-case)...")

; Match first clause
(test-case :errcase-first
   :zero
   (match-error (/ #1 #0)
      ((:div-by-zero (lambda (d) :zero)))))

; Match with data access
(test-case :errcase-data
   #t
   (match-error (/ #1 #0)
      ((:div-by-zero (lambda (d) #t)))))

; Success passes through
(test-case :errcase-success
   #3
   (match-error (/ #6 #2)
      ((:div-by-zero (lambda (d) :error)))))

; Two clauses - match second
(test-case :errcase-two-match
   :not-found
   (match-error (error :not-found "x")
      ((:div-by-zero (lambda (d) :zero)))
      ((:not-found (lambda (d) :not-found)))))

; :else clause
(test-case :errcase-else
   :other
   (match-error (error :unknown-error "?")
      ((:div-by-zero (lambda (d) :zero)))
      ((:else (lambda (d) :other)))))

; ============================================================================
; Test: trace-error (try-finally)
; ============================================================================

(print "Testing trace-error (try-finally)...")

; Success case - cleanup runs, returns result
; Note: Can't test side effects easily, but can test return value
(test-case :finally-success
   #3
   (trace-error (/ #6 #2) :cleanup))

; Error case - cleanup runs, returns error
(test-case :finally-error
   #t
   (error? (trace-error (/ #1 #0) :cleanup)))

; ============================================================================
; Test: retry (retry)
; ============================================================================

(print "Testing retry (retry)...")

; Success on first try
(test-case :retry-first-success
   #3
   (retry #3 (/ #6 #2)))

; All retries exhausted (always errors)
(test-case :retry-exhausted
   #t
   (error? (retry #3 (/ #1 #0))))

; Verify exhausted error type
(test-case :retry-exhausted-type
   :retry-exhausted
   (error-type (retry #1 (/ #1 #0))))

; ============================================================================
; Test: and-errors (all-succeed)
; ============================================================================

(print "Testing and-errors (all-succeed)...")

; Single success
(test-case :allsucceed-single
   #3
   (and-errors (/ #6 #2)))

; Two successes - returns last
(test-case :allsucceed-two
   #5
   (and-errors (/ #6 #2) (+ #2 #3)))

; First fails
(test-case :allsucceed-first-fails
   #t
   (error? (and-errors (/ #1 #0) (+ #2 #3))))

; Second fails
(test-case :allsucceed-second-fails
   #t
   (error? (and-errors (/ #6 #2) (/ #1 #0))))

; Three expressions - all succeed
(test-case :allsucceed-three
   #9
   (and-errors (/ #6 #2) (+ #2 #3) (* #3 #3)))

; ============================================================================
; Test: or-errors (first-success)
; ============================================================================

(print "Testing or-errors (first-success)...")

; Single success
(test-case :firstsuccess-single
   #3
   (or-errors (/ #6 #2)))

; First succeeds - returns first
(test-case :firstsuccess-first
   #3
   (or-errors (/ #6 #2) (/ #8 #2)))

; First fails, second succeeds
(test-case :firstsuccess-second
   #4
   (or-errors (/ #1 #0) (/ #8 #2)))

; All fail - returns last error
(test-case :firstsuccess-all-fail
   #t
   (error? (or-errors (/ #1 #0) (/ #1 #0))))

; Three expressions - first succeeds
(test-case :firstsuccess-three-first
   #2
   (or-errors (/ #6 #3) (/ #1 #0) (/ #1 #0)))

; Three expressions - third succeeds
(test-case :firstsuccess-three-third
   #5
   (or-errors (/ #1 #0) (/ #1 #0) (+ #2 #3)))

; ============================================================================
; Integration Tests
; ============================================================================

(print "Testing integration scenarios...")

; Chain of error handling
(test-case :chain-or-then-with
   :recovered
   (try-with (try-or (/ #1 #0) (error :fallback-error #0))
      (lambda (e) :recovered)))

; All-succeed with error case handling
(test-case :chain-all-with-case
   :caught
   (try-or (and-errors (/ #6 #2) (/ #1 #0)) :caught))

; First-success with finally
(test-case :chain-first-finally
   #3
   (trace-error (or-errors (/ #1 #0) (/ #6 #2)) :cleanup))

; Safe division function
(define safe-div (lambda (x y)
  (try-or (/ x y) #0)))

(test-case :safe-div-success
   #3
   (safe-div #9 #3))

(test-case :safe-div-error
   #0
   (safe-div #9 #0))

; Multiple operations with fallback
(test-case :multi-ops
   #6
   (+ (try-or (/ #6 #2) #0)
      (try-or (/ #9 #3) #0)))

(print "\nâœ… All exception handling macro tests passed!")
