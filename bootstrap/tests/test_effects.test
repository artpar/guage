; Test: Algebraic Effect System
; Day 86 - Effect declaration, perform, and handle

; ============ Effect Declaration ============

; Declare effect with operations
(effect-def :Console :print :read)
(test-case (quote :declare-effect) #t #t)

; Declare another effect
(effect-def :State :get :put)
(test-case (quote :declare-state) #t #t)

; Declare single-op effect
(effect-def :Logger :log)
(test-case (quote :declare-logger) #t #t)

; ============ Effect Query ============

; Query declared effect
(test-case (quote :query-console) #t (effect? :Console))
(test-case (quote :query-state) #t (effect? :State))
(test-case (quote :query-undeclared) #f (effect? :Nope))

; ============ Basic Handle + Perform ============

; Simple perform returns handler's result
(test-case (quote :basic-handle)
  :printed
  (handle (perform :Console :print "hello")
    (:Console
      (:print (lambda (msg) :printed))
      (:read (lambda () "input")))))

; Perform read operation
(test-case (quote :basic-read)
  "fake-input"
  (handle (perform :Console :read)
    (:Console
      (:print (lambda (msg) :ok))
      (:read (lambda () "fake-input")))))

; ============ Perform Result in Computation ============

; Use perform result in arithmetic
(test-case (quote :perform-in-expr)
  #43
  (handle (+ (perform :State :get) #1)
    (:State
      (:get (lambda () #42))
      (:put (lambda (v) nil)))))

; Use perform result in conditional
(test-case (quote :perform-in-cond)
  :big
  (handle (if (> (perform :State :get) #10) :big :small)
    (:State
      (:get (lambda () #42))
      (:put (lambda (v) nil)))))

; Perform with argument
(test-case (quote :perform-with-args)
  :done
  (handle (perform :State :put #99)
    (:State
      (:get (lambda () #0))
      (:put (lambda (v) :done)))))

; Handler uses argument value
(test-case (quote :handler-uses-arg)
  #198
  (handle (perform :State :put #99)
    (:State
      (:get (lambda () #0))
      (:put (lambda (v) (* v #2))))))

; ============ Nested Handlers ============

; Inner handler shadows outer for same effect
(test-case (quote :nested-shadow)
  #99
  (handle
    (handle (perform :State :get)
      (:State
        (:get (lambda () #99))
        (:put (lambda (v) nil))))
    (:State
      (:get (lambda () #42))
      (:put (lambda (v) nil)))))

; Outer handler reached for different effect
(test-case (quote :nested-different)
  :logged
  (handle
    (handle (perform :Logger :log "inner")
      (:State
        (:get (lambda () #0))
        (:put (lambda (v) nil))))
    (:Logger
      (:log (lambda (msg) :logged)))))

; ============ Handler as Closure ============

; Handler captures enclosing scope
(define multiplier #3)
(test-case (quote :handler-closure)
  #126
  (handle (perform :State :get)
    (:State
      (:get (lambda () (* #42 multiplier)))
      (:put (lambda (v) nil)))))

; Handler from named function
(define my-reader (lambda () "config-value"))
(test-case (quote :handler-named-fn)
  "config-value"
  (handle (perform :Console :read)
    (:Console
      (:print (lambda (msg) nil))
      (:read my-reader))))

; ============ Unhandled Effect ============

; Performing without handler returns error
(test-case (quote :unhandled-effect)
  #t
  (error? (perform :Console :print "oops")))

; Performing undeclared effect returns error
(test-case (quote :unknown-effect)
  #t
  (error? (perform :Unknown :op)))

; Performing unknown operation returns error
(test-case (quote :unknown-op)
  #t
  (error? (handle (perform :Console :mystery)
    (:Console
      (:print (lambda (msg) nil))))))

; ============ No Effect Performed ============

; Body without performs returns normally
(test-case (quote :no-perform)
  #42
  (handle #42
    (:State
      (:get (lambda () #0))
      (:put (lambda (v) nil)))))

; Complex body without performs
(test-case (quote :no-perform-complex)
  #10
  (handle (+ #3 #7)
    (:State
      (:get (lambda () #0))
      (:put (lambda (v) nil)))))

; ============ Effect + Lambda ============

; Perform inside lambda within handler scope
(test-case (quote :perform-in-lambda)
  #42
  (handle ((lambda () (perform :State :get)))
    (:State
      (:get (lambda () #42))
      (:put (lambda (v) nil)))))

; Higher-order: pass effectful function
(test-case (quote :effectful-fn)
  #42
  (handle ((lambda (f) (f)) (lambda () (perform :State :get)))
    (:State
      (:get (lambda () #42))
      (:put (lambda (v) nil)))))

; ============ Multiple Effect Types Nested ============

; Handle different effects in nested handlers
(test-case (quote :multi-effect)
  #42
  (handle
    (handle (+ (perform :State :get) (perform :Logger :log "hi"))
      (:Logger
        (:log (lambda (msg) #2))))
    (:State
      (:get (lambda () #40))
      (:put (lambda (v) nil)))))

; ============ Pure and Bind ============

; Pure lifts value unchanged
(test-case (quote :pure-lift) #42 (effect-pure #42))
(test-case (quote :pure-string) "hello" (effect-pure "hello"))

; Bind sequences: (bind val fn) applies fn to val
(test-case (quote :bind-basic)
  #43
  (bind #42 (lambda (x) (+ x #1))))

; Bind with effect result
(test-case (quote :bind-effect)
  #43
  (handle (bind (perform :State :get) (lambda (x) (+ x #1)))
    (:State
      (:get (lambda () #42))
      (:put (lambda (v) nil)))))

; ============ Multiple Args ============

; Handler receives multiple args
(effect-def :Math :compute)
(test-case (quote :multi-arg)
  #7
  (handle (perform :Math :compute #3 #4)
    (:Math
      (:compute (lambda (a b) (+ a b))))))

; Three args
(test-case (quote :three-args)
  #24
  (handle (perform :Math :compute #2 #3 #4)
    (:Math
      (:compute (lambda (a b c) (* a (* b c)))))))

; ============ Practical: Config Reader ============

(effect-def :Config :get)

(define get-config (lambda (key) (perform :Config :get key)))

(test-case (quote :config-reader)
  "localhost:5432"
  (handle (get-config :db-url)
    (:Config
      (:get (lambda (key)
        (if (equal? key :db-url) "localhost:5432"
           (if (equal? key :port) #8080
              "unknown")))))))

(test-case (quote :config-port)
  #8080
  (handle (get-config :port)
    (:Config
      (:get (lambda (key)
        (if (equal? key :db-url) "localhost:5432"
           (if (equal? key :port) #8080
              "unknown")))))))

; ============ Zero-arg Perform ============

; Perform with no args (just operation name)
(test-case (quote :zero-arg-perform)
  #42
  (handle (perform :State :get)
    (:State
      (:get (lambda () #42))
      (:put (lambda (v) nil)))))

; ============ Summary ============
; Total: 35 tests
