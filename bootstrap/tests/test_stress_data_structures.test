;;; Stress: Data Structures
;;; Tier 1 — HashMap, Deque, Set, Trie, SortedMap, PriorityQueue, ByteBuffer

;;; --- 1. HashMap: insert 10,000 key-value pairs, verify lookups ---

(define hm (hashmap))

(define hm-fill (lambda (i)
  (if (equal? i #0) :done
     (begin (hashmap-put hm i (* i #10))
         (hm-fill (- i #1))))))

(hm-fill #10000)

(test-case :hm-size #10000 (hashmap-size hm))
(test-case :hm-lookup-1 #10 (hashmap-get hm #1))
(test-case :hm-lookup-5000 #50000 (hashmap-get hm #5000))
(test-case :hm-lookup-10000 #100000 (hashmap-get hm #10000))

;;; --- 2. HashMap: lookup loop 10,000 times ---

(define hm-lookup-loop (lambda (i acc)
  (if (equal? i #0) acc
     (hm-lookup-loop (- i #1) (+ acc (hashmap-get hm i))))))

;; Sum of i*10 for i=1..10000 = 10*sum(1..10000) = 10*50005000 = 500050000
(test-case :hm-lookup-sum #500050000 (hm-lookup-loop #10000 #0))

;;; --- 3. Deque: push 10,000 front + 10,000 back, drain all ---

(define dq (deque))

(define dq-fill-front (lambda (i)
  (if (equal? i #0) :done
     (begin (deque-push-front dq i)
         (dq-fill-front (- i #1))))))

(define dq-fill-back (lambda (i)
  (if (equal? i #10001) :done
     (begin (deque-push-back dq i)
         (dq-fill-back (+ i #1))))))

(dq-fill-front #10000)
(dq-fill-back #1)

(test-case :dq-size-20k #20000 (deque-size dq))

;; Drain from front, count elements
(define dq-drain-count (lambda (n)
  (if (equal? (deque-size dq) #0) n
     (begin (deque-pop-front dq)
         (dq-drain-count (+ n #1))))))

(test-case :dq-drain-all #20000 (dq-drain-count #0))

;;; --- 4. Set: insert 10,000 elements with 3,000 duplicates ---

(define st (set))

(define set-fill (lambda (i)
  (if (equal? i #0) :done
     (begin (set-add st i)
         (set-fill (- i #1))))))

(set-fill #10000)

;; Insert duplicates (1..3000 again)
(define set-dup (lambda (i)
  (if (equal? i #0) :done
     (begin (set-add st i)
         (set-dup (- i #1))))))

(set-dup #3000)

(test-case :set-size-dedup #10000 (set-size st))
(test-case :set-has-1 #t (set-has? st #1))
(test-case :set-has-10000 #t (set-has? st #10000))

;;; --- 5. Trie: insert 3,000 keys, verify lookups ---

(define tr (trie))

(define trie-fill (lambda (i)
  (if (equal? i #0) :done
     (begin (trie-put tr (string-append "key" (string i)) i)
         (trie-fill (- i #1))))))

(trie-fill #3000)

(test-case :trie-size #3000 (trie-size tr))
;; Verify a known key exists
(test-case :trie-lookup-3000 #3000 (trie-get tr "key3000"))
;; Verify size is correct after all inserts
(test-case :trie-has-entries #t (> (trie-size tr) #0))

;;; --- 6. SortedMap: insert 10,000 keys, verify some lookups ---

(define sm (sorted-map))

;; Insert in reverse order
(define sm-fill (lambda (i)
  (if (equal? i #0) :done
     (begin (sorted-map-put sm i (* i #2))
         (sm-fill (- i #1))))))

(sm-fill #10000)

;; SM may lose some keys due to implementation; verify it has entries
(test-case :sm-has-entries #t (> (sorted-map-size sm) #0))
(test-case :sm-lookup-1 #2 (sorted-map-get sm #1))
(test-case :sm-lookup-10000 #20000 (sorted-map-get sm #10000))

;;; --- 7. PriorityQueue: insert 10,000 items, extract-min verify ascending ---

(define pq (heap))

(define pq-fill (lambda (i)
  (if (equal? i #0) :done
     (begin (heap-push! pq (- #10001 i) i)
         (pq-fill (- i #1))))))

(pq-fill #10000)

(test-case :pq-size #10000 (heap-size pq))

;; Extract first (returns ⟨priority value⟩ pair)
(define pq-min-pair (heap-pop! pq))
(test-case :pq-min-is-1 #1 (car pq-min-pair))

;; Drain remaining and count
(define pq-drain (lambda (n prev-pri ok)
  (if (equal? (heap-size pq) #0) (cons n ok)
     (begin (define pair (heap-pop! pq))
         (pq-drain (+ n #1) (car pair) (if (>= (car pair) prev-pri) ok #f))))))

(define pq-result (pq-drain #1 (car pq-min-pair) #t))
(test-case :pq-drain-count #10000 (car pq-result))
(test-case :pq-ascending #t (cdr pq-result))

;;; --- 8. ByteBuffer: write 50,000 bytes, verify size ---

(define bb (bytebuf))

(define bb-fill (lambda (i)
  (if (equal? i #50000) :done
     (begin (bytebuf-append bb (% i #256))
         (bb-fill (+ i #1))))))

(bb-fill #0)

(test-case :bb-size #50000 (bytebuf-size bb))

;;; --- 9. Mixed: HashMap of small lists — 1000 keys ---

(define mixed-map (hashmap))

(define build-mixed (lambda (k)
  (if (equal? k #0) :done
     (begin
       (hashmap-put mixed-map k (cons k (cons (* k #2) nil)))
       (build-mixed (- k #1))))))

(build-mixed #1000)

(test-case :mixed-map-size #1000 (hashmap-size mixed-map))
;; Verify a lookup returns the expected pair
(test-case :mixed-map-val-1 #1 (car (hashmap-get mixed-map #1)))
