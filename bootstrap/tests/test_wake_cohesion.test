; Test: Suspend/Wake architectural cohesion
; Verifies that suspend paths correctly set wait_flag for wake protocol.
;
; Bug pattern: infrastructure for sender-side wake (wait_flag, recv_waiter)
; exists in channel.c and actor.c, but some suspend paths in primitives.c
; don't register the actor as a waiter. Without registration:
; - Single-scheduler: poll loop hides the bug (checks conditions every tick)
; - Multi-scheduler: parked workers never get woken -> latency or deadlock
;
; These tests use actor-wait-flag (actor-wait-flag introspection) to verify the
; exact property: wait_flag == 1 after suspension.


; ============ SUSPEND_MAILBOX: wait_flag must be set ============
(actor-reset)

(define mb-actor (actor-spawn (lambda (self) (bind (actor-receive) (lambda (msg) msg)))))
(actor-run 5)

(test-case (quote :mailbox-wait-flag) #1 (actor-wait-flag mb-actor))


; ============ SUSPEND_CHAN_RECV: wait_flag must be set ============
(actor-reset)
(chan-reset)

(define ch-recv (chan-create))
(define recv-actor (actor-spawn (lambda (self) (bind (chan-recv ch-recv) (lambda (v) v)))))
(actor-run 5)

(test-case (quote :chan-recv-wait-flag) #1 (actor-wait-flag recv-actor))


; ============ SUSPEND_CHAN_SEND: wait_flag must be set ============
; Note: capacity rounds to power-of-2, min 2. Fill both slots first.
(actor-reset)
(chan-reset)

(define ch-send (chan-create #2))
(define filler1 (actor-spawn (lambda (self) (chan-send ch-send :fill1))))
(define filler2 (actor-spawn (lambda (self) (chan-send ch-send :fill2))))
(actor-run 5)
(define send-actor (actor-spawn (lambda (self) (chan-send ch-send :blocked))))
(actor-run 5)

(test-case (quote :chan-send-wait-flag) #1 (actor-wait-flag send-actor))


; ============ SUSPEND_SELECT: wait_flag must be set ============
(actor-reset)
(chan-reset)

(define ch-sel1 (chan-create))
(define ch-sel2 (chan-create))

(define selector (actor-spawn (lambda (self)
  (bind (chan-select ch-sel1 ch-sel2) (lambda (pair) (cdr pair))))))

(actor-run 5)

(test-case (quote :select-wait-flag) #1 (actor-wait-flag selector))


; ============ SUSPEND_TASK_AWAIT: wait_flag must be set ============
(actor-reset)

(define slow-worker (actor-spawn (lambda (self) (bind (actor-receive) (lambda (msg) msg)))))
(define awaiter (actor-spawn (lambda (self) (task-await slow-worker))))

(actor-run 5)

(test-case (quote :task-await-wait-flag) #1 (actor-wait-flag awaiter))


; ============ Behavioral: SELECT wake after fix ============
(actor-reset)
(chan-reset)

(define ch-bsel1 (chan-create))
(define ch-bsel2 (chan-create))

(define bselector (actor-spawn (lambda (self)
  (bind (chan-select ch-bsel1 ch-bsel2) (lambda (pair) (cdr pair))))))

(actor-run 5)
(chan-send ch-bsel2 :selected-data)
(actor-run 10)

(test-case (quote :select-wake-behavioral) :selected-data (actor-result bselector))


; ============ Behavioral: TASK_AWAIT wake after fix ============
(actor-reset)

(define bworker (actor-spawn (lambda (self) (bind (actor-receive) (lambda (msg) msg)))))
(define bawaiter (actor-spawn (lambda (self) (task-await bworker))))

(actor-run 10)
(actor-send bworker :finished)
(actor-run 15)

(test-case (quote :task-await-wake-behavioral) :finished (actor-result bawaiter))
