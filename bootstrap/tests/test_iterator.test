; Test: Iterator (iter) — Morsel-Driven Batch Iteration
; Day 118

; 1. iter-list-basic — create from list, next returns elements in order
(define it1 (iter (cons #1 (cons #2 (cons #3 nil)))))
(test-case (quote :iter-list-first) #1 (iter-next it1))
(test-case (quote :iter-list-second) #2 (iter-next it1))
(test-case (quote :iter-list-third) #3 (iter-next it1))

; 2. iter-list-exhaust — next after exhaustion returns nil
(test-case (quote :iter-list-exhaust) nil (iter-next it1))

; 3. iter-done-predicate — iter-done? true after drain, false before
(define it2 (iter (cons #1 nil)))
(test-case (quote :iter-done-false) #f (iter-done? it2))
(iter-next it2)
(test-case (quote :iter-done-true) #t (iter-done? it2))

; 4. iter-collect — iter-collect collects remaining to list
(define it3 (iter (cons #10 (cons #20 (cons #30 nil)))))
(iter-next it3)
(define rest (iter-collect it3))
(test-case (quote :iter-collect-first) #20 (car rest))
(test-case (quote :iter-collect-second) #30 (car (cdr rest)))

; 5. iter-count — iter-count returns correct count
(test-case (quote :iter-count) #3 (iter-count (iter (cons #1 (cons #2 (cons #3 nil))))))

; 6. iter-vector — iterate vector, correct order
(define v (vector))
(vector-push! v #100)
(vector-push! v #200)
(vector-push! v #300)
(define vit (iter v))
(test-case (quote :iter-vec-first) #100 (iter-next vit))
(test-case (quote :iter-vec-second) #200 (iter-next vit))
(test-case (quote :iter-vec-third) #300 (iter-next vit))
(test-case (quote :iter-vec-done) nil (iter-next vit))

; 7. iter-deque — iterate deque front→back
(define dq (deque))
(deque-push-back dq #1)
(deque-push-back dq #2)
(deque-push-back dq #3)
(define dit (iter dq))
(test-case (quote :iter-deque-first) #1 (iter-next dit))
(test-case (quote :iter-deque-second) #2 (iter-next dit))
(test-case (quote :iter-deque-third) #3 (iter-next dit))

; 8. iter-buffer — iterate buffer as byte numbers
(define buf (bytebuf))
(bytebuf-append buf #65)
(bytebuf-append buf #66)
(bytebuf-append buf #67)
(define bit (iter buf))
(test-case (quote :iter-buf-first) #65 (iter-next bit))
(test-case (quote :iter-buf-second) #66 (iter-next bit))
(test-case (quote :iter-buf-third) #67 (iter-next bit))

; 9. iter-hashmap — iterate HashMap yields ⟨k v⟩ pairs
(define hm (hashmap))
(hashmap-put hm :a #1)
(hashmap-put hm :b #2)
(define hmit (iter hm))
(define e1 (iter-next hmit))
(define e2 (iter-next hmit))
(test-case (quote :iter-hmap-count) #2 (iter-count (iter hm)))

; 10. iter-hashset — iterate HashSet yields elements
(define hs (set))
(set-add hs #10)
(set-add hs #20)
(set-add hs #30)
(test-case (quote :iter-hset-count) #3 (iter-count (iter hs)))

; 11. iter-sorted-map — iterate SortedMap in key order
(define sm (sorted-map))
(sorted-map-put sm #3 :c)
(sorted-map-put sm #1 :a)
(sorted-map-put sm #2 :b)
(define smit (iter sm))
(define sme1 (iter-next smit))
(test-case (quote :iter-smap-first-key) #1 (car sme1))
(test-case (quote :iter-smap-first-val) :a (cdr sme1))
(define sme2 (iter-next smit))
(test-case (quote :iter-smap-second-key) #2 (car sme2))

; 12. iter-trie — iterate Trie yields ⟨key value⟩ pairs
(define tr (trie))
(trie-put tr :cat #1)
(trie-put tr :dog #2)
(test-case (quote :iter-trie-count) #2 (iter-count (iter tr)))

; 13. iter-heap — iterate Heap in priority order
(define hp (heap))
(heap-push! hp #30 :c)
(heap-push! hp #10 :a)
(heap-push! hp #20 :b)
(define hpit (iter hp))
(define hp1 (iter-next hpit))
(test-case (quote :iter-heap-first-pri) #10 (car hp1))
(test-case (quote :iter-heap-first-val) :a (cdr hp1))
(define hp2 (iter-next hpit))
(test-case (quote :iter-heap-second-pri) #20 (car hp2))

; 14. iter-map-transform — iter-map applies fn lazily, correct results
(define doubled (iter-map (cons #1 (cons #2 (cons #3 nil))) (lambda (x) (* x #2))))
(test-case (quote :iter-map-first) #2 (iter-next doubled))
(test-case (quote :iter-map-second) #4 (iter-next doubled))
(test-case (quote :iter-map-third) #6 (iter-next doubled))

; 15. iter-filter-select — iter-filter filters correctly
(define evens (iter-filter (cons #1 (cons #2 (cons #3 (cons #4 (cons #5 nil))))) (lambda (x) (equal? (% x #2) #0))))
(test-case (quote :iter-filter-first) #2 (iter-next evens))
(test-case (quote :iter-filter-second) #4 (iter-next evens))
(test-case (quote :iter-filter-done) nil (iter-next evens))

; 16. iter-take-limit — iter-take stops after n elements
(define taken (iter-take (cons #1 (cons #2 (cons #3 (cons #4 (cons #5 nil))))) #2))
(test-case (quote :iter-take-first) #1 (iter-next taken))
(test-case (quote :iter-take-second) #2 (iter-next taken))
(test-case (quote :iter-take-done) nil (iter-next taken))

; 17. iter-drop-skip — iter-drop skips first n
(define dropped (iter-drop (cons #1 (cons #2 (cons #3 (cons #4 nil)))) #2))
(test-case (quote :iter-drop-first) #3 (iter-next dropped))
(test-case (quote :iter-drop-second) #4 (iter-next dropped))

; 18. iter-chain-concat — iter-chain drains first then second
(define chained (iter-chain (cons #1 (cons #2 nil)) (cons #3 (cons #4 nil))))
(test-case (quote :iter-chain-1) #1 (iter-next chained))
(test-case (quote :iter-chain-2) #2 (iter-next chained))
(test-case (quote :iter-chain-3) #3 (iter-next chained))
(test-case (quote :iter-chain-4) #4 (iter-next chained))

; 19. iter-zip-pairs — iter-zip yields ⟨a b⟩ pairs, stops at shorter
(define zipped (iter-zip (cons #1 (cons #2 (cons #3 nil))) (cons :a (cons :b nil))))
(define z1 (iter-next zipped))
(test-case (quote :iter-zip-1a) #1 (car z1))
(test-case (quote :iter-zip-1b) :a (cdr z1))
(define z2 (iter-next zipped))
(test-case (quote :iter-zip-2a) #2 (car z2))
(test-case (quote :iter-zip-2b) :b (cdr z2))
(test-case (quote :iter-zip-done) nil (iter-next zipped))

; 20. iter-pipeline-fused — chained map→filter→take
(define pipeline (iter-take (iter-filter (iter-map (cons #1 (cons #2 (cons #3 (cons #4 (cons #5 nil)))))
                          (lambda (x) (* x #10)))
                    (lambda (x) (> x #20)))
              #2))
(test-case (quote :iter-pipeline-1) #30 (iter-next pipeline))
(test-case (quote :iter-pipeline-2) #40 (iter-next pipeline))
(test-case (quote :iter-pipeline-done) nil (iter-next pipeline))

; 21. iter-reduce-fold — iter-reduce folds correctly
(test-case (quote :iter-reduce-sum) #15 (iter-reduce (cons #1 (cons #2 (cons #3 (cons #4 (cons #5 nil))))) #0 (lambda (acc x) (+ acc x))))

; 22. iter-any-short-circuit — iter-any? stops early on match
(test-case (quote :iter-any-found) #t (iter-any? (cons #1 (cons #2 (cons #3 nil))) (lambda (x) (equal? x #2))))
(test-case (quote :iter-any-missing) #f (iter-any? (cons #1 (cons #2 nil)) (lambda (x) (equal? x #99))))

; 23. iter-all-short-circuit — iter-all? stops early on mismatch
(test-case (quote :iter-all-yes) #t (iter-all? (cons #2 (cons #4 (cons #6 nil))) (lambda (x) (equal? (% x #2) #0))))
(test-case (quote :iter-all-no) #f (iter-all? (cons #2 (cons #3 (cons #4 nil))) (lambda (x) (equal? (% x #2) #0))))

; 24. iter-find-first — iter-find returns first match
(test-case (quote :iter-find-yes) #3 (iter-find (cons #1 (cons #2 (cons #3 (cons #4 nil)))) (lambda (x) (> x #2))))
(test-case (quote :iter-find-no) nil (iter-find (cons #1 (cons #2 nil)) (lambda (x) (> x #99))))

; 25. iter-auto-coerce — transformers accept raw collections
(test-case (quote :iter-type-yes) #t (iter? (iter (cons #1 nil))))
(test-case (quote :iter-type-no) #f (iter? #42))
(test-case (quote :iter-auto-map) #t (iter? (iter-map (cons #1 nil) (lambda (x) x))))
(test-case (quote :iter-auto-filter) #t (iter? (iter-filter (cons #1 nil) (lambda (x) #t))))
