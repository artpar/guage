;;; Stress: Real-World Scenario — Order Processing System
;;; Tier 3 — ADT + GenServer + Supervisor + Channel + Effects + Pattern Match + HashMap + ETS

(actor-reset)
(chan-reset)

;;; --- ADT definitions ---

(adt-define :OrderStatus
  (quote (:Pending))
  (quote (:Validating))
  (quote (:Processing))
  (quote (:Shipped))
  (quote (:Failed :reason)))

(adt-define :OrderMsg
  (quote (:Submit :order-id :data))
  (quote (:GetStatus :order-id)))

;;; --- Effect declarations ---

(effect-def :Validate :check)

;;; --- ETS for persistence ---

(ets-new :orders)
(ets-new :stats)
(ets-insert :stats :submitted #0)
(ets-insert :stats :shipped #0)
(ets-insert :stats :failed #0)

;;; --- Notification channel ---

(define notify-ch (chan-create))

;;; --- Order processing server ---

(define order-server-fn (lambda (self)
  (begin
    (define process-order (lambda (order-id data)
      (begin
        ;; Set to Pending
        (ets-insert :orders order-id (adt-create :OrderStatus :Pending))
        (ets-insert :stats :submitted (+ (ets-lookup :stats :submitted) #1))

        ;; Validate
        (ets-insert :orders order-id (adt-create :OrderStatus :Validating))
        (define valid (if (> data #0) #t #f))

        (if valid
           (begin
             ;; Process
             (ets-insert :orders order-id (adt-create :OrderStatus :Processing))
             ;; Ship
             (ets-insert :orders order-id (adt-create :OrderStatus :Shipped))
             (ets-insert :stats :shipped (+ (ets-lookup :stats :shipped) #1))
             :shipped)
           (begin
             ;; Failed
             (ets-insert :orders order-id (adt-create :OrderStatus :Failed :invalid-data))
             (ets-insert :stats :failed (+ (ets-lookup :stats :failed) #1))
             :failed)))))

    ;; Server loop
    (define srv-loop (lambda ()
      (bind (actor-receive) (lambda (msg)
        (begin
          (define caller (car (cdr msg)))
          (define req (car (cdr (cdr msg))))
          (define response
            (if (pair? req)
               (process-order (car req) (cdr req))
               :unknown))
          (bind (actor-reply caller response) (lambda (_)
            (srv-loop))))))))
    (srv-loop))))

;;; --- Supervisor wrapping the server ---

(define order-sup (sup-start :one-for-one (cons order-server-fn nil)))
(actor-run #500)

;;; --- Client submitting orders ---

(define submit-orders (lambda (server n total-shipped total-failed)
  (if (equal? n #0) (cons total-shipped total-failed)
     (bind (actor-call server (cons n (if (equal? (% n #10) #0) (- #0 #1) n))) (lambda (r)
       (if (equal? r :shipped)
          (submit-orders server (- n #1) (+ total-shipped #1) total-failed)
          (submit-orders server (- n #1) total-shipped (+ total-failed #1))))))))

;;; --- Test 1: Process 500 orders through full pipeline ---

(define kids (sup-children order-sup))
(define server (car kids))

(define client1 (actor-spawn (lambda (self)
  (submit-orders server #500 #0 #0))))

(actor-run #500000)

(define result1 (actor-result client1))
(define shipped1 (car result1))
(define failed1 (cdr result1))

;; Every 10th order fails (data = -1), so 50 failures, 450 shipped
(test-case :rw-shipped-450 #450 shipped1)
(test-case :rw-failed-50 #50 failed1)
(test-case :rw-total-500 #500 (+ shipped1 failed1))

;;; --- Test 2: Verify ETS stats ---

(test-case :rw-ets-submitted #500 (ets-lookup :stats :submitted))
(test-case :rw-ets-shipped #450 (ets-lookup :stats :shipped))
(test-case :rw-ets-failed #50 (ets-lookup :stats :failed))

;;; --- Test 3: Crash server, supervisor restarts, continue processing ---

;; Reset stats for round 2
(ets-insert :stats :submitted #0)
(ets-insert :stats :shipped #0)
(ets-insert :stats :failed #0)

;; Crash the server
(actor-send server :crash-now)
(actor-run #5000)

;; Get new server after restart
(define kids2 (sup-children order-sup))
(define server2 (car kids2))

;; Process another 500 orders
(define client2 (actor-spawn (lambda (self)
  (submit-orders server2 #500 #0 #0))))

(actor-run #500000)

(define result2 (actor-result client2))
(test-case :rw-post-crash-total #500 (+ (car result2) (cdr result2)))

;;; --- Test 4: Query order statuses from ETS ---

;; Spot check some orders
(define order-100 (ets-lookup :orders #100))
(test-case :rw-order-exists #t (not (null? order-100)))

;;; --- Test 5: Verify counts are consistent ---

(define final-submitted (ets-lookup :stats :submitted))
(define final-shipped (ets-lookup :stats :shipped))
(define final-failed (ets-lookup :stats :failed))

(test-case :rw-counts-consistent #t
  (equal? final-submitted (+ final-shipped final-failed)))

;;; --- Test 6: Concurrent clients (5 clients × 100 orders each) ---

(actor-reset)
(chan-reset)

(ets-new :orders2)
(ets-new :stats2)
(ets-insert :stats2 :submitted #0)
(ets-insert :stats2 :shipped #0)
(ets-insert :stats2 :failed #0)

;; New server for concurrent test
(define conc-server-fn (lambda (self)
  (begin
    (define srv-loop (lambda ()
      (bind (actor-receive) (lambda (msg)
        (begin
          (define caller (car (cdr msg)))
          (define req (car (cdr (cdr msg))))
          (define order-id (if (pair? req) (car req) #0))
          (define data (if (pair? req) (cdr req) #0))
          ;; Simple processing
          (ets-insert :stats2 :submitted (+ (ets-lookup :stats2 :submitted) #1))
          (if (> data #0)
             (begin (ets-insert :stats2 :shipped (+ (ets-lookup :stats2 :shipped) #1))
                 (actor-reply caller :shipped))
             (begin (ets-insert :stats2 :failed (+ (ets-lookup :stats2 :failed) #1))
                 (actor-reply caller :failed)))
          (srv-loop))))))
    (srv-loop))))

(define conc-sup (sup-start :one-for-one (cons conc-server-fn nil)))
(actor-run #500)

(define conc-kids (sup-children conc-sup))
(define conc-server (car conc-kids))

;; Done channel for synchronization
(define done-ch (chan-create))

;; Spawn 5 client actors
(define spawn-clients (lambda (n)
  (if (equal? n #0) :done
     (begin
       (actor-spawn (lambda (self)
         (begin
           (define cl (lambda (i)
             (if (equal? i #0) (chan-send done-ch :done)
                (bind (actor-call conc-server (cons (+ (* n #1000) i) i)) (lambda (r)
                  (cl (- i #1)))))))
           (cl #100))))
       (spawn-clients (- n #1))))))

(spawn-clients #5)

;; Wait for all 5 to finish
(define done-waiter (actor-spawn (lambda (self)
  (begin
    (define wait (lambda (n)
      (if (equal? n #0) :all-done
         (bind (chan-recv done-ch) (lambda (_)
           (wait (- n #1)))))))
    (wait #5)))))

(actor-run #500000)

(test-case :rw-concurrent-done :all-done (actor-result done-waiter))
(test-case :rw-concurrent-submitted #500 (ets-lookup :stats2 :submitted))
(test-case :rw-concurrent-consistent #t
  (equal? (ets-lookup :stats2 :submitted)
     (+ (ets-lookup :stats2 :shipped) (ets-lookup :stats2 :failed))))
