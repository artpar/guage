; test_cfg_algorithms.test - Graph algorithm primitives
; Tests for ⊝↦, ⊝⊃, ⊝⊚, ⊝⊙, ⊝⇝, graph-cycles

; === Setup: Define :TestGraph type ===

; Define the graph type
(graph-define (quote :TestGraph) (quote :cfg) (quote :nodes) (quote :edges) (quote :entry) (quote :exit) (quote :metadata))

; Simple linear graph: A -> B -> C
(define linear-g (graph-create (quote :TestGraph)))
(define linear-g (graph-add-node linear-g (quote :A)))
(define linear-g (graph-add-node linear-g (quote :B)))
(define linear-g (graph-add-node linear-g (quote :C)))
(define linear-g (graph-add-edge linear-g (quote :A) (quote :B) (quote :next)))
(define linear-g (graph-add-edge linear-g (quote :B) (quote :C) (quote :next)))

; Branching graph: A -> B, A -> C, B -> D, C -> D
(define branch-g (graph-create (quote :TestGraph)))
(define branch-g (graph-add-node branch-g (quote :A)))
(define branch-g (graph-add-node branch-g (quote :B)))
(define branch-g (graph-add-node branch-g (quote :C)))
(define branch-g (graph-add-node branch-g (quote :D)))
(define branch-g (graph-add-edge branch-g (quote :A) (quote :B) (quote :left)))
(define branch-g (graph-add-edge branch-g (quote :A) (quote :C) (quote :right)))
(define branch-g (graph-add-edge branch-g (quote :B) (quote :D) (quote :next)))
(define branch-g (graph-add-edge branch-g (quote :C) (quote :D) (quote :next)))

; Cyclic graph: A -> B -> C -> A
(define cycle-g (graph-create (quote :TestGraph)))
(define cycle-g (graph-add-node cycle-g (quote :A)))
(define cycle-g (graph-add-node cycle-g (quote :B)))
(define cycle-g (graph-add-node cycle-g (quote :C)))
(define cycle-g (graph-add-edge cycle-g (quote :A) (quote :B) (quote :next)))
(define cycle-g (graph-add-edge cycle-g (quote :B) (quote :C) (quote :next)))
(define cycle-g (graph-add-edge cycle-g (quote :C) (quote :A) (quote :back)))

; Disconnected graph: A -> B, C -> D
(define disc-g (graph-create (quote :TestGraph)))
(define disc-g (graph-add-node disc-g (quote :A)))
(define disc-g (graph-add-node disc-g (quote :B)))
(define disc-g (graph-add-node disc-g (quote :C)))
(define disc-g (graph-add-node disc-g (quote :D)))
(define disc-g (graph-add-edge disc-g (quote :A) (quote :B) (quote :next)))
(define disc-g (graph-add-edge disc-g (quote :C) (quote :D) (quote :next)))

; Empty graph
(define empty-g (graph-create (quote :TestGraph)))

; Single node graph
(define single-g (graph-create (quote :TestGraph)))
(define single-g (graph-add-node single-g (quote :A)))

; Self-loop graph
(define self-loop-g (graph-create (quote :TestGraph)))
(define self-loop-g (graph-add-node self-loop-g (quote :A)))
(define self-loop-g (graph-add-edge self-loop-g (quote :A) (quote :A) (quote :loop)))

; === Tests: Graph Traversal (graph-traverse) ===

; Test: BFS traversal of linear graph returns non-empty list
(test-case (quote :bfs-linear) #t (pair? (graph-traverse linear-g (quote :bfs) (quote :A) (lambda (n) n))))

; Test: DFS traversal of linear graph returns non-empty list
(test-case (quote :dfs-linear) #t (pair? (graph-traverse linear-g (quote :dfs) (quote :A) (lambda (n) n))))

; Test: BFS traversal of branching graph returns non-empty list
(test-case (quote :bfs-branch) #t (pair? (graph-traverse branch-g (quote :bfs) (quote :A) (lambda (n) n))))

; Test: DFS traversal of branching graph returns non-empty list
(test-case (quote :dfs-branch) #t (pair? (graph-traverse branch-g (quote :dfs) (quote :A) (lambda (n) n))))

; Test: Visitor function returns correct results
(test-case (quote :traverse-visitor-result) #t (pair? (graph-traverse linear-g (quote :bfs) (quote :A) (lambda (n) #1))))

; Test: Empty traversal (node not in graph)
(test-case (quote :traverse-missing-node) nil (graph-traverse linear-g (quote :bfs) (quote :X) (lambda (n) n)))

; Test: Cyclic graph BFS (should visit each node once)
(test-case (quote :bfs-cycle) #t (pair? (graph-traverse cycle-g (quote :bfs) (quote :A) (lambda (n) n))))

; Test: Invalid mode error
(test-case (quote :traverse-invalid-mode) #t (error? (graph-traverse linear-g (quote :invalid) (quote :A) (lambda (n) n))))

; Test: Non-function visitor error
(test-case (quote :traverse-non-function) #t (error? (graph-traverse linear-g (quote :bfs) (quote :A) #42)))

; === Tests: Reachability (graph-reachable?) ===

; Test: Reachable in linear graph
(test-case (quote :reach-linear-yes) #t (graph-reachable? linear-g (quote :A) (quote :C)))

; Test: Unreachable in linear graph (reverse direction)
(test-case (quote :reach-linear-no) #f (graph-reachable? linear-g (quote :C) (quote :A)))

; Test: Reachable through branching
(test-case (quote :reach-branch) #t (graph-reachable? branch-g (quote :A) (quote :D)))

; Test: Reachable in cycle (all nodes reach all nodes)
(test-case (quote :reach-cycle-forward) #t (graph-reachable? cycle-g (quote :A) (quote :C)))

(test-case (quote :reach-cycle-backward) #t (graph-reachable? cycle-g (quote :C) (quote :A)))

; Test: Unreachable in disconnected graph
(test-case (quote :reach-disconnected) #f (graph-reachable? disc-g (quote :A) (quote :C)))

; Test: Node reachable from itself
(test-case (quote :reach-self) #t (graph-reachable? linear-g (quote :A) (quote :A)))

; Test: Missing node
(test-case (quote :reach-missing) #f (graph-reachable? linear-g (quote :A) (quote :X)))

; === Tests: Successors (graph-successors) ===

; Test: Successors in linear graph (non-empty)
(test-case (quote :succ-linear-a) #t (pair? (graph-successors linear-g (quote :A))))

; Test: Multiple successors in branching graph (non-empty)
(test-case (quote :succ-branch) #t (pair? (graph-successors branch-g (quote :A))))

; Test: No successors (leaf node)
(test-case (quote :succ-leaf) nil (graph-successors linear-g (quote :C)))

; === Tests: Predecessors (graph-predecessors) ===

; Test: Predecessors in linear graph (non-empty)
(test-case (quote :pred-linear-c) #t (pair? (graph-predecessors linear-g (quote :C))))

; Test: Multiple predecessors in branching graph (non-empty)
(test-case (quote :pred-branch-d) #t (pair? (graph-predecessors branch-g (quote :D))))

; Test: No predecessors (root node)
(test-case (quote :pred-root) nil (graph-predecessors linear-g (quote :A)))

; === Tests: Path Finding (graph-path) ===

; Test: Path in linear graph (non-empty)
(test-case (quote :path-linear) #t (pair? (graph-path linear-g (quote :A) (quote :C))))

; Test: No path (reverse direction)
(test-case (quote :path-none) nil (graph-path linear-g (quote :C) (quote :A)))

; Test: Path through branching (non-empty)
(test-case (quote :path-branch) #t (pair? (graph-path branch-g (quote :A) (quote :D))))

; Test: Path in cycle (non-empty)
(test-case (quote :path-cycle) #t (pair? (graph-path cycle-g (quote :A) (quote :C))))

; Test: No path in disconnected graph
(test-case (quote :path-disconnected) nil (graph-path disc-g (quote :A) (quote :C)))

; Test: Path to self (non-empty)
(test-case (quote :path-self) #t (pair? (graph-path linear-g (quote :A) (quote :A))))

; === Tests: Cycle Detection (graph-cycles) ===

; Test: No cycles in linear graph
(test-case (quote :cycles-linear) nil (graph-cycles linear-g))

; Test: No cycles in branching graph
(test-case (quote :cycles-branch) nil (graph-cycles branch-g))

; Test: Cycle detected in cyclic graph
(test-case (quote :cycles-detected) #t (not (null? (graph-cycles cycle-g))))

; Test: Self-loop detection
(test-case (quote :self-loop) #t (not (null? (graph-cycles self-loop-g))))

; === Edge Cases ===

; Test: Empty graph
(test-case (quote :empty-graph) nil (graph-traverse empty-g (quote :bfs) (quote :A) (lambda (n) n)))

; Test: Single node graph
(test-case (quote :single-node) #t (pair? (graph-traverse single-g (quote :bfs) (quote :A) (lambda (n) n))))
