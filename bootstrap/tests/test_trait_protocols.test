; ═══════════════════════════════════════════════════════════════
; Guage Trait Protocol Tests: FDT dispatch + stdlib traits
; ═══════════════════════════════════════════════════════════════

; Load sort (needed for ⊧sort) and traits
(load "bootstrap/stdlib/sort.scm")
(load "bootstrap/stdlib/traits.scm")

(print "Testing Trait Protocols (FDT dispatch)...")

; ────────────────────────────────────────────────────────────────
; runtime-type-of — FDT array-indexed type-of
; ────────────────────────────────────────────────────────────────

(test-case :fdt-type-of-number  :Number (runtime-type-of #42))
(test-case :fdt-type-of-bool    :Bool   (runtime-type-of #t))
(test-case :fdt-type-of-symbol  :Symbol (runtime-type-of :foo))
(test-case :fdt-type-of-nil     :Nil    (runtime-type-of nil))
(test-case :fdt-type-of-string  :String (runtime-type-of "hello"))
(test-case :fdt-type-of-pair    :Pair   (runtime-type-of (cons #1 #2)))
(test-case :fdt-type-of-lambda  :Lambda (runtime-type-of (lambda (x) x)))
(test-case :fdt-type-of-error   :Error  (runtime-type-of (error :test nil)))

; ────────────────────────────────────────────────────────────────
; :Showable — ⊧show dispatch
; ────────────────────────────────────────────────────────────────

(test-case :show-number  "42"  (⊧show #42))
(test-case :show-bool-t  "#t"  (⊧show #t))
(test-case :show-bool-f  "#f"  (⊧show #f))
(test-case :show-nil     "∅"   (⊧show nil))
(test-case :show-string  "hello" (⊧show "hello"))
(test-case :show-lambda  "<λ>" (⊧show (lambda (x) x)))

; ────────────────────────────────────────────────────────────────
; :Equatable — ⊧≡ dispatch
; ────────────────────────────────────────────────────────────────

(test-case :eq-numbers-same    #t  ((⊧≡ #42) #42))
(test-case :eq-numbers-diff    #f  ((⊧≡ #42) #99))
(test-case :eq-bools-same      #t  ((⊧≡ #t) #t))
(test-case :eq-strings-same    #t  ((⊧≡ "abc") "abc"))
(test-case :eq-strings-diff    #f  ((⊧≡ "abc") "xyz"))
(test-case :eq-nil             #t  ((⊧≡ nil) nil))
(test-case :eq-symbols-same    #t  ((⊧≡ :foo) :foo))

; ────────────────────────────────────────────────────────────────
; :Comparable — ⊧compare, ⊧<, ⊧≤, ⊧>, ⊧≥
; ────────────────────────────────────────────────────────────────

(test-case :cmp-numbers-lt  :lt  ((⊧compare #1) #2))
(test-case :cmp-numbers-eq  :eq  ((⊧compare #5) #5))
(test-case :cmp-numbers-gt  :gt  ((⊧compare #9) #3))

(test-case :lt-true   #t  ((⊧< #1) #2))
(test-case :lt-false  #f  ((⊧< #2) #1))
(test-case :le-true   #t  ((⊧≤ #1) #1))
(test-case :le-false  #f  ((⊧≤ #3) #1))
(test-case :gt-true   #t  ((⊧> #5) #2))
(test-case :gt-false  #f  ((⊧> #1) #2))
(test-case :ge-true   #t  ((⊧≥ #3) #3))

; String comparison
(test-case :cmp-strings-lt  :lt  ((⊧compare "abc") "xyz"))
(test-case :cmp-strings-eq  :eq  ((⊧compare "hello") "hello"))

; ────────────────────────────────────────────────────────────────
; trait-dispatch-fast — fused dispatch matches trait-dispatch
; ────────────────────────────────────────────────────────────────

; trait-dispatch-fast takes value directly, trait-dispatch takes type symbol
(define fdt-show-fn  (trait-dispatch-fast #42 :Showable :show))
(define str-show-fn  (trait-dispatch :Number :Showable :show))
(test-case :fused-dispatch-matches  (str-show-fn #42)  (fdt-show-fn #42))

; ────────────────────────────────────────────────────────────────
; FDT trait check (trait?)
; ────────────────────────────────────────────────────────────────

(test-case :fdt-check-showable-number  #t  (trait? :Number :Showable))
(test-case :fdt-check-showable-bool    #t  (trait? :Bool :Showable))
(test-case :fdt-check-equatable-nil    #t  (trait? :Nil :Equatable))
(test-case :fdt-check-comparable-num   #t  (trait? :Number :Comparable))

; Missing trait -> #f
(test-case :fdt-check-missing  #f  (trait? :Number :NonExistent))

; ────────────────────────────────────────────────────────────────
; Defaults fallback
; ────────────────────────────────────────────────────────────────

(define default-fn (lambda (x) :default-result))
(trait-define :DefaultTrait (cons :op1 nil) (cons (cons :op1 default-fn) nil))

; No impl for :Number, but default exists
(test-case :defaults-fallback  :default-result  ((trait-dispatch :Number :DefaultTrait :op1) #42))
(test-case :defaults-fused     :default-result  ((trait-dispatch-fast #42 :DefaultTrait :op1) #42))

; ────────────────────────────────────────────────────────────────
; Missing trait -> error
; ────────────────────────────────────────────────────────────────

(test-case :dispatch-missing-trait  #t  (error? (trait-dispatch :Number :NoSuchTrait :op)))
(test-case :fused-missing-trait     #t  (error? (trait-dispatch-fast #42 :NoSuchTrait :op)))

; ────────────────────────────────────────────────────────────────
; Generic sort via :Comparable
; ────────────────────────────────────────────────────────────────

(define list-equal? (lambda (lst1) (lambda (lst2)
  (if (null? lst1)
     (null? lst2)
     (if (null? lst2)
        #f
        (if (equal? (car lst1) (car lst2))
           ((list-equal? (cdr lst1)) (cdr lst2))
           #f))))))

(test-case :sort-numbers
   #t
   ((list-equal? (⊧sort (cons #3 (cons #1 (cons #2 nil)))))
                 (cons #1 (cons #2 (cons #3 nil)))))

(test-case :sort-strings
   #t
   ((list-equal? (⊧sort (cons "c" (cons "a" (cons "b" nil)))))
                 (cons "a" (cons "b" (cons "c" nil)))))

(test-case :sort-empty  #t  (null? (⊧sort nil)))

(print "\nTrait protocol tests complete.")
