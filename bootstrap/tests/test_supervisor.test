; Day 93: Supervisor Strategies â€” one-for-one, one-for-all
; Tests: supervisor creation, restart strategies, restart limits

;;; Test 1: Supervisor creates and starts children
(actor-reset)
(define w1 (lambda (self) (actor-receive)))
(define w2 (lambda (self) (actor-receive)))
(define sup (sup-start :one-for-one (cons w1 (cons w2 nil))))
(actor-run #100)
(define kids (sup-children sup))
(test-case (quote :sup-creates-children)
  #2
  (+ (if (actor-alive? (car kids)) #1 #0)
     (if (actor-alive? (car (cdr kids))) #1 #0)))

;;; Test 2: one-for-one restarts only crashed child
(actor-reset)
(define ch (chan-create))
(define crasher (lambda (self)
  (bind (chan-send ch :started) (lambda (_)
    (bind (actor-receive) (lambda (msg)
      (if (equal? msg :crash)
         (error :crashed :boom)
         msg)))))))
(define stable (lambda (self) (actor-receive)))
(define sup2 (sup-start :one-for-one (cons crasher (cons stable nil))))
(actor-run #100)
; Both children alive, crasher sent :started to channel
(define kids2 (sup-children sup2))
(define crasher-id (car kids2))
(define stable-id (car (cdr kids2)))
; Tell crasher to crash
(actor-send crasher-id :crash)
(actor-run #200)
; Crasher should have been restarted â€” new actor, sent :started again
(define kids2b (sup-children sup2))
(define new-crasher (car kids2b))
(define same-stable (car (cdr kids2b)))
(test-case (quote :one-for-one-restarts-crashed)
  #t
  (and (actor-alive? new-crasher)
      (actor-alive? same-stable)))

;;; Test 3: one-for-one stable child unchanged after restart
(test-case (quote :one-for-one-stable-unchanged)
  #t
  (equal? stable-id same-stable))

;;; Test 4: one-for-all restarts all children on crash
(actor-reset)
(define ch4 (chan-create))
(define worker-a (lambda (self)
  (bind (chan-send ch4 :a-started) (lambda (_)
    (bind (actor-receive) (lambda (msg)
      (if (equal? msg :crash) (error :crash :a) msg)))))))
(define worker-b (lambda (self)
  (bind (chan-send ch4 :b-started) (lambda (_)
    (actor-receive)))))
(define sup4 (sup-start :one-for-all (cons worker-a (cons worker-b nil))))
(actor-run #100)
(define kids4 (sup-children sup4))
(define old-a (car kids4))
(define old-b (car (cdr kids4)))
; Crash worker-a
(actor-send old-a :crash)
(actor-run #200)
; Both should be restarted with NEW actor IDs
(define kids4b (sup-children sup4))
(define new-a (car kids4b))
(define new-b (car (cdr kids4b)))
(test-case (quote :one-for-all-both-restarted)
  #t
  (and (actor-alive? new-a) (actor-alive? new-b)))

;;; Test 5: one-for-all replaces old children (different IDs)
(test-case (quote :one-for-all-new-ids)
  #f
  (or (equal? old-b new-b) (equal? old-a new-a)))

;;; Test 6: Restart count tracks restarts
(test-case (quote :restart-count-one-for-one)
  #1
  (sup-restart-count sup2))

;;; Test 7: Restart count for one-for-all
(test-case (quote :restart-count-one-for-all)
  #1
  (sup-restart-count sup4))

;;; Test 8: Max restarts exceeded returns error
(actor-reset)
(define always-crash (lambda (self) (error :crash :always)))
(define sup8 (sup-start :one-for-one (cons always-crash nil)))
; Run enough ticks for 5+ restart attempts
(actor-run #2000)
(test-case (quote :max-restarts-exceeded)
  #t
  (> (sup-restart-count sup8) #4))
