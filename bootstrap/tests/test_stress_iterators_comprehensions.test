;;; Stress: Iterators + Comprehensions
;;; Tier 2 — Two-feature combination stress test

;;; --- 1. Range, map, filter, collect over elements ---

;; Build range as list
(≔ range (λ (start end acc)
  (? (> start end) acc
     (range start (⊖ end #1) (⟨⟩ end acc)))))

;; Map function
(≔ map-list (λ (f lst)
  (? (∅? lst) ∅
     (⟨⟩ (f (◁ lst)) (map-list f (▷ lst))))))

;; Filter function
(≔ filter-list (λ (pred lst)
  (? (∅? lst) ∅
     (? (pred (◁ lst))
        (⟨⟩ (◁ lst) (filter-list pred (▷ lst)))
        (filter-list pred (▷ lst))))))

;; List length
(≔ list-len (λ (lst n)
  (? (∅? lst) n
     (list-len (▷ lst) (⊕ n #1)))))

;; Fold
(≔ fold-list (λ (f init lst)
  (? (∅? lst) init
     (fold-list f (f init (◁ lst)) (▷ lst)))))

;; Build range of 5,000
(≔ big-range (range #1 #5000 ∅))

;; Double each element
(≔ doubled (map-list (λ (x) (⊗ x #2)) big-range))

;; Filter even (all are even after doubling)
(≔ evens (filter-list (λ (x) (≡ (% x #2) #0)) doubled))

(⊨ :iter-map-filter-5k #5000 (list-len evens #0))

;;; --- 2. Iterator-based fold over large list ---

;; Sum of 1..5000 = 12502500
(⊨ :iter-fold-5k #12502500 (fold-list (λ (acc x) (⊕ acc x)) #0 big-range))

;;; --- 3. Chained transforms: map -> filter -> map -> filter ---

(≔ range-1k (range #1 #1000 ∅))

(≔ chain-result
  (fold-list (λ (acc x) (⊕ acc x)) #0
    (filter-list (λ (x) (> x #100))
      (map-list (λ (x) (⊖ x #50))
        (filter-list (λ (x) (≡ (% x #2) #0))
          (map-list (λ (x) (⊗ x #3)) range-1k))))))

(⊨ :iter-chained-positive #t (> chain-result #0))

;;; --- 4. Collect into HashMap: frequency counting ---

(≔ freq-map (⊞))

(≔ count-freq (λ (lst)
  (? (∅? lst) freq-map
     (⪢
       (≔ k (% (◁ lst) #20))
       (≔ cur (⊞→ freq-map k))
       (⊞← freq-map k (? (∅? cur) #1 (⊕ cur #1)))
       (count-freq (▷ lst))))))

(count-freq big-range)

;; 20 buckets for mod 20
(⊨ :iter-freq-buckets #20 (⊞# freq-map))

;;; --- 5. Nested iteration: 50 lists of 50 elements, collect all ---

(≔ nested-sum (λ (outer-n acc)
  (? (≡ outer-n #0) acc
     (⪢
       (≔ inner-list (range #1 #50 ∅))
       (≔ inner-sum (fold-list (λ (a x) (⊕ a x)) #0 inner-list))
       (nested-sum (⊖ outer-n #1) (⊕ acc inner-sum))))))

;; 50 * sum(1..50) = 50 * 1275 = 63750
(⊨ :iter-nested-50x50 #63750 (nested-sum #50 #0))

;;; --- 6. Build Vector from list via iteration ---

(≔ vec-from-list (⟦⟧))

(≔ list-to-vec (λ (lst)
  (? (∅? lst) :done
     (⪢ (⟦⊕ vec-from-list (◁ lst))
         (list-to-vec (▷ lst))))))

(≔ range-1k2 (range #1 #1000 ∅))
(list-to-vec range-1k2)

(⊨ :iter-list-to-vec #1000 (⟦# vec-from-list))
(⊨ :iter-vec-first #1 (⟦→ vec-from-list #0))
(⊨ :iter-vec-last #1000 (⟦→ vec-from-list #999))

;;; --- 7. Zip two lists via parallel iteration ---

(≔ zip-lists (λ (a b)
  (? (∨ (∅? a) (∅? b)) ∅
     (⟨⟩ (⟨⟩ (◁ a) (◁ b)) (zip-lists (▷ a) (▷ b))))))

(≔ list-a (range #1 #1000 ∅))
(≔ list-b (range #1001 #2000 ∅))
(≔ zipped (zip-lists list-a list-b))

(⊨ :iter-zip-len #1000 (list-len zipped #0))
(⊨ :iter-zip-first-pair (⟨⟩ #1 #1001) (◁ zipped))
