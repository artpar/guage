;;; Stress: Effects + Pattern Matching
;;; Tier 2 â€” Two-feature combination stress test

;;; --- ADT definitions ---

(adt-define :Result (quote (:Ok :value)) (quote (:Err :error)))

;;; --- Effect declarations ---

(effect-def :Provider :fetch)
(effect-def :State :get :put)
(effect-def :Dispatch :op)
(effect-def :Counter :inc :get)

;;; --- 1. Resumable effect returns ADT, 10,000 iterations matching Ok/Err ---

(define eff-adt-loop (lambda (n ok-count)
  (if (equal? n #0) ok-count
     (begin
       (define result
         (handle (perform :Provider :fetch n)
           (:Provider
             (:fetch (lambda (key) (if (equal? (% key #3) #0)
                                  (adt-create :Result :Err :bad)
                                  (adt-create :Result :Ok key)))))))
       (define is-ok (match result (quote (
         ((adt-create :Result :Ok v) #1)
         ((adt-create :Result :Err x) #0)))))
       (eff-adt-loop (- n #1) (+ ok-count is-ok))))))

;; 1/3 are Err (divisible by 3): out of 1000, ~333 err, ~667 ok
(test-case :ep-adt-ok-count #667 (eff-adt-loop #1000 #0))

;;; --- 2. Guard on effect-returned value: threshold classification ---

(define classify-loop (lambda (n big-count)
  (if (equal? n #0) big-count
     (begin
       (define val (handle (perform :Provider :fetch n)
                 (:Provider (:fetch (lambda (k) k)))))
       (define cls (match val (quote (
         ((x | (> x #500)) :big)
         (x :small)))))
       (classify-loop (- n #1) (+ big-count (if (equal? cls :big) #1 #0)))))))

;; Numbers 501..1000 are :big = 500
(test-case :ep-guard-classify #500 (classify-loop #1000 #0))

;;; --- 3. Effect handler dispatches via pattern match on 10 operations ---

(adt-define :Op
  (quote (:Add :a :b))
  (quote (:Sub :a :b))
  (quote (:Mul :a :b))
  (quote (:Div :a :b))
  (quote (:Neg :a)))

(define dispatch-op (lambda (op)
  (match op (quote (
    ((adt-create :Op :Add a b) (+ a b))
    ((adt-create :Op :Sub a b) (- a b))
    ((adt-create :Op :Mul a b) (* a b))
    ((adt-create :Op :Div a b) (if (equal? b #0) #0 (/ a b)))
    ((adt-create :Op :Neg a)   (- #0 a)))))))

(define dispatch-loop (lambda (n acc)
  (if (equal? n #0) acc
     (begin
       (define op (if (equal? (% n #5) #0) (adt-create :Op :Add n #1)
                (if (equal? (% n #5) #1) (adt-create :Op :Sub n #1)
                   (if (equal? (% n #5) #2) (adt-create :Op :Mul n #2)
                      (if (equal? (% n #5) #3) (adt-create :Op :Div n #2)
                         (adt-create :Op :Neg n))))))
       (define result (handle (perform :Dispatch :op op)
                    (:Dispatch (:op (lambda (o) (dispatch-op o))))))
       (dispatch-loop (- n #1) (+ acc result))))))

(define dispatch-result (dispatch-loop #500 #0))
(test-case :ep-dispatch-completes #t (> dispatch-result #0))

;;; --- 4. Nested pattern match inside nested effect handler ---

(test-case :ep-nested-3-levels #42
  (handle
    (handle-resume
      (match (adt-create :Result :Ok (perform :State :get)) (quote (
        ((adt-create :Result :Ok v) v)
        ((adt-create :Result :Err _) #0))))
      (:State
        (:get (lambda (k) (k #42)))
        (:put (lambda (k v) (k nil)))))
    (:Provider (:fetch (lambda (k) k)))))

;;; --- 5. Effect-driven state machine: 10 states, transitions via pattern match ---

(adt-define :FSM
  (quote (:S0)) (quote (:S1)) (quote (:S2)) (quote (:S3)) (quote (:S4))
  (quote (:S5)) (quote (:S6)) (quote (:S7)) (quote (:S8)) (quote (:S9)))

(define next-state (lambda (s)
  (match s (quote (
    ((adt-create :FSM :S0) (adt-create :FSM :S1))
    ((adt-create :FSM :S1) (adt-create :FSM :S2))
    ((adt-create :FSM :S2) (adt-create :FSM :S3))
    ((adt-create :FSM :S3) (adt-create :FSM :S4))
    ((adt-create :FSM :S4) (adt-create :FSM :S5))
    ((adt-create :FSM :S5) (adt-create :FSM :S6))
    ((adt-create :FSM :S6) (adt-create :FSM :S7))
    ((adt-create :FSM :S7) (adt-create :FSM :S8))
    ((adt-create :FSM :S8) (adt-create :FSM :S9))
    ((adt-create :FSM :S9) (adt-create :FSM :S0)))))))

(define fsm-loop (lambda (n state steps)
  (if (equal? n #0) steps
     (fsm-loop (- n #1) (next-state state) (+ steps #1)))))

(test-case :ep-fsm-1k #1000 (fsm-loop #1000 (adt-create :FSM :S0) #0))

;;; --- 6. As-pattern on effect result + destructure ---

(define as-eff-loop (lambda (n acc)
  (if (equal? n #0) acc
     (begin
       (define r (handle (perform :Provider :fetch n)
                (:Provider (:fetch (lambda (k) (adt-create :Result :Ok k))))))
       (define val (match r (quote (
         ((adt-create :Result :Ok v) v)
         (_ #0)))))
       (as-eff-loop (- n #1) (+ acc val))))))

;; Sum of 1..500 = 125250
(test-case :ep-as-pattern-500 #125250 (as-eff-loop #500 #0))
