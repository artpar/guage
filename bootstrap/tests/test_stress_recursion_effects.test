;;; Stress: Recursion + Effects
;;; Tier 2 â€” Two-feature combination stress test

;;; --- Effect declarations ---

(effect-def :Counter :inc :get)

;;; --- 1. Recursive fn performing effect each step, 500 deep with resumable handler ---

(define recursive-count (lambda (n)
  (if (equal? n #0) #0
     (+ (perform :Counter :inc) (recursive-count (- n #1))))))

(define rc-result
  (handle-resume (recursive-count #100)
    (:Counter
      (:inc (lambda (k) (k #1)))
      (:get (lambda (k) (k #0))))))

(test-case :re-recursive-effect-500 #100 rc-result)

;;; --- 2. Binary tree traversal (depth 8 = 256 leaves) with effect at each node ---

(adt-define :BTree (quote (:BLeaf :val)) (quote (:BNode :left :right)))

(define build-btree (lambda (depth)
  (if (equal? depth #0) (adt-create :BTree :BLeaf #1)
     (adt-create :BTree :BNode (build-btree (- depth #1)) (build-btree (- depth #1))))))

(define btree8 (build-btree #6))

(define traverse-tree (lambda (t)
  (if (adt? t :BTree :BLeaf)
     (perform :Counter :inc)
     (+ (traverse-tree (adt-get t :left)) (traverse-tree (adt-get t :right))))))

(define tree-count
  (handle-resume (traverse-tree btree8)
    (:Counter
      (:inc (lambda (k) (k #1)))
      (:get (lambda (k) (k #0))))))

;; 2^6 = 64 leaves
(test-case :re-tree-traverse #64 tree-count)

;;; --- 3. Mutual recursion where each fn performs different effect ---

(define mut-a (lambda (n)
  (if (equal? n #0) #0
     (+ (perform :Counter :inc) (mut-b (- n #1))))))

(define mut-b (lambda (n)
  (if (equal? n #0) #0
     (+ (perform :Counter :inc) (mut-a (- n #1))))))

(define mut-result
  (handle-resume (mut-a #100)
    (:Counter
      (:inc (lambda (k) (k #1)))
      (:get (lambda (k) (k #0))))))

(test-case :re-mutual-effect-500 #100 mut-result)

;;; --- 4. TCO loop with effect perform, 1000 iterations ---

(define tco-eff-loop (lambda (n acc)
  (if (equal? n #0) acc
     (tco-eff-loop (- n #1) (+ acc (perform :Counter :inc))))))

(define tco-eff-result
  (handle-resume (tco-eff-loop #100 #0)
    (:Counter
      (:inc (lambda (k) (k #1)))
      (:get (lambda (k) (k #0))))))

(test-case :re-tco-effect-1k #100 tco-eff-result)

;;; --- 5. Recursive accumulator collecting effect results into list ---

(define collect-effects (lambda (n)
  (if (equal? n #0) nil
     (cons (perform :Counter :inc) (collect-effects (- n #1))))))

(define collected-list
  (handle-resume (collect-effects #100)
    (:Counter
      (:inc (lambda (k) (k #1)))
      (:get (lambda (k) (k #0))))))

;; First element should be 1
(test-case :re-collect-first #1 (car collected-list))

;; Count list length
(define list-len (lambda (lst n)
  (if (null? lst) n
     (list-len (cdr lst) (+ n #1)))))

(test-case :re-collect-200 #100 (list-len collected-list #0))

;;; --- 6. Fibonacci with effect at each step ---

(define fib-eff (lambda (n a b)
  (if (equal? n #0) (begin (perform :Counter :inc) a)
     (fib-eff (- n #1) b (+ a b)))))

(define fib-eff-result
  (handle-resume (fib-eff #100 #0 #1)
    (:Counter
      (:inc (lambda (k) (k #1)))
      (:get (lambda (k) (k #0))))))

(test-case :re-fib-effect-completes #t (> fib-eff-result #0))
