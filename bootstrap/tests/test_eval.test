;;;
;;; Tests for S-Expression Evaluator
;;;

(⋘ "bootstrap/stdlib/eval.scm")

;;; ===================================================================
;;; Test 1: Evaluate atomic values
;;; ===================================================================

(≔ empty-env (env-empty))

;; Numbers self-evaluate
(⊨ :eval-number-zero
   #0
   ((eval #0) empty-env))

(⊨ :eval-number-positive
   #42
   ((eval #42) empty-env))

(⊨ :eval-number-negative
   #-5
   ((eval #-5) empty-env))

;; Booleans self-evaluate
(⊨ :eval-bool-true
   #t
   ((eval #t) empty-env))

(⊨ :eval-bool-false
   #f
   ((eval #f) empty-env))

;; Nil self-evaluates
(⊨ :eval-nil
   ∅
   ((eval ∅) empty-env))

;;; ===================================================================
;;; Test 2: Symbol lookup
;;; ===================================================================

(≔ env-with-x (((env-extend empty-env) :x) #42))

(⊨ :eval-symbol-lookup
   #42
   ((eval :x) env-with-x))

;; Undefined symbol returns error
(≔ result-undefined ((eval :undefined) empty-env))
(⊨ :eval-symbol-undefined
   #t
   (⚠? result-undefined))

;;; ===================================================================
;;; Test 3: Lambda creation
;;; ===================================================================

;; Lambda creates closure
(≔ identity-closure ((eval (⌜ (λ (:x) :x))) empty-env))

(⊨ :eval-lambda-creates-closure
   :closure
   (◁ identity-closure))

;;; ===================================================================
;;; Test 4: Function application
;;; ===================================================================

;; Identity function
(⊨ :eval-apply-identity
   #42
   ((eval (⌜ ((λ (:x) :x) #42))) empty-env))

;; Constant function
(⊨ :eval-apply-const
   #100
   ((eval (⌜ ((λ (:x) #100) #42))) empty-env))

;;; ===================================================================
;;; Test 5: Arithmetic with primitives
;;; ===================================================================

;; Environment with arithmetic primitives
(≔ env-arith
  (((env-extend
    (((env-extend empty-env) :⊕) ⊕))
   :⊗) ⊗))

(⊨ :eval-add
   #5
   ((eval (⌜ (:⊕ #2 #3))) env-arith))

(⊨ :eval-multiply
   #12
   ((eval (⌜ (:⊗ #3 #4))) env-arith))

(⊨ :eval-nested-arithmetic
   #14
   ((eval (⌜ (:⊕ (:⊗ #2 #3) (:⊗ #2 #4)))) env-arith))

;;; ===================================================================
;;; Test 6: Conditionals
;;; ===================================================================

;; Environment with comparison
(≔ env-cond
  (((env-extend env-arith) :>) >))

(⊨ :eval-if-true
   #1
   ((eval (⌜ (? #t #1 #2))) env-cond))

(⊨ :eval-if-false
   #2
   ((eval (⌜ (? #f #1 #2))) env-cond))

(⊨ :eval-if-comparison
   #100
   ((eval (⌜ (? (:> #5 #3) #100 #200))) env-cond))

;;; ===================================================================
;;; Test 7: Lambda with captured variables
;;; ===================================================================

(⊨ :eval-lambda-capture
   #10
   ((eval (⌜ ((λ (:x) ((λ (:y) (:⊕ :x :y)) #3)) #7))) env-arith))

;;; ===================================================================
;;; Test 8: Multiple parameters
;;; ===================================================================

(⊨ :eval-lambda-two-params
   #7
   ((eval (⌜ ((λ (:x :y) (:⊕ :x :y)) #3 #4))) env-arith))

;;; ===================================================================
;;; Test 9: Higher-order functions
;;; ===================================================================

;; Function that returns a function
(⊨ :eval-higher-order
   #10
   ((eval (⌜ (((λ (:x) (λ (:y) (:⊕ :x :y))) #3) #7))) env-arith))

;;; ===================================================================
;;; Test 10: Error cases
;;; ===================================================================

;; Quoted empty list self-evaluates to nil
;; Note: The empty application error only applies to UNQUOTED empty lists.
;; Since (⌜ ()) creates the VALUE ∅ (nil), it self-evaluates like numbers/booleans.
(≔ result-empty ((eval (⌜ ())) empty-env))
(⊨ :eval-quoted-empty-list-is-nil
   ∅
   result-empty)

;; Non-function application
(≔ result-not-fn ((eval (⌜ (#42 #1))) empty-env))
(⊨ :eval-non-function-is-error
   #t
   (⚠? result-not-fn))

;;; ===================================================================
;;; Test 11: Quote special form
;;; ===================================================================

;; Quote returns expression unevaluated
(⊨ :eval-quote-symbol
   :foo
   ((eval (⌜ (⌜ :foo))) empty-env))

(⊨ :eval-quote-list
   (⌜ (:a :b :c))
   ((eval (⌜ (⌜ (:a :b :c)))) empty-env))

(⊨ :eval-quote-number
   #42
   ((eval (⌜ (⌜ #42))) empty-env))

;;; ===================================================================
;;; Test 12: Nested lambdas (currying)
;;; ===================================================================

(⊨ :eval-curried-add
   #15
   ((eval (⌜ ((((λ (:x) (λ (:y) (λ (:z) (:⊕ :x (:⊕ :y :z))))) #3) #5) #7))) env-arith))

;;; ===================================================================
;;; Test 13: Recursive factorial via Y combinator style
;;; ===================================================================

;; Self-application for recursion
(≔ env-full
  (((env-extend
    (((env-extend
      (((env-extend env-arith) :⊖) ⊖))
     :≡) ≡))
   :≤) ≤))

(⊨ :eval-factorial-3
   #6
   ((eval (⌜ (((λ (:f) (:f :f))
               (λ (:self) (λ (:n)
                 (? (:≤ :n #1)
                    #1
                    (:⊗ :n ((:self :self) (:⊖ :n #1))))))) #3))) env-full))

;;; ===================================================================
;;; Test 14: List construction in evaluator
;;; ===================================================================

(≔ env-list (((env-extend env-full) :⟨⟩) ⟨⟩))

;; Test pair creation - use ⟨⟩? to verify it's a pair
(⊨ :eval-cons-is-pair
   #t
   (⟨⟩? ((eval (⌜ (:⟨⟩ #1 #2))) env-list)))

;; Test head of constructed pair
(⊨ :eval-cons-head
   #1
   (◁ ((eval (⌜ (:⟨⟩ #1 #2))) env-list)))

;;; ===================================================================
;;; Test 15: Pure lambda calculus - no external functions
;;; ===================================================================

;; K combinator: λx.λy.x
(⊨ :eval-k-combinator
   #1
   ((eval (⌜ (((λ (:x) (λ (:y) :x)) #1) #2))) empty-env))

;; Simplified test: apply identity twice
(⊨ :eval-double-apply
   #42
   ((eval (⌜ (((λ (:f) (λ (:x) (:f (:f :x)))) (λ (:y) :y)) #42))) empty-env))

;;; ===================================================================
;;; Test 16: Nested conditionals with quoted results
;;; ===================================================================

;; Test nested conditional returning quoted symbols
(⊨ :eval-nested-cond
   :large
   ((eval (⌜ (? (:≤ #10 #5) (⌜ :small) (⌜ :large)))) env-full))

;;; ===================================================================
;;; Test 17: Define (≔) in lambda bodies
;;; ===================================================================

;; Simple define - bind and use (use keywords for consistency)
(⊨ :eval-define-simple
   #5
   ((eval (⌜ ((λ () (≔ :x #5) :x)))) env-arith))

;; Define with expression
(⊨ :eval-define-expr
   #7
   ((eval (⌜ ((λ () (≔ :y (:⊕ #3 #4)) :y)))) env-arith))

;; Sequential defines
(⊨ :eval-define-seq
   #15
   ((eval (⌜ ((λ () (≔ :a #5) (≔ :b #10) (:⊕ :a :b))))) env-arith))

;; Define shadows outer binding
(⊨ :eval-define-shadow
   #100
   ((eval (⌜ ((λ (:x) (≔ :x #100) :x) #1))) env-arith))

;; Define uses outer scope
(⊨ :eval-define-uses-outer
   #12
   ((eval (⌜ ((λ (:x) (≔ :y (:⊕ :x #5)) :y) #7))) env-arith))

;; Standalone define returns value
(⊨ :eval-define-standalone
   #42
   ((eval (⌜ (≔ :z #42))) empty-env))
