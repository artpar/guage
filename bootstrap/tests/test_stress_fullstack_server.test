;;; Stress: Full-Stack GenServer
;;; Tier 3 — GenServer + Patterns + ETS + Supervisor + Effects

(actor-reset)
(chan-reset)

;;; --- Effect declarations ---

(effect-def :Compute :calc)

;;; --- 1. GenServer handles 10,000 calls dispatched via pattern match ---

(actor-reset)

(define dispatch-server (actor-spawn (lambda (self)
  (begin
    (define srv-loop (lambda ()
      (bind (actor-receive) (lambda (msg)
        (begin
          ;; msg = ⟨:call caller-id request⟩
          (define caller (car (cdr msg)))
          (define req (car (cdr (cdr msg))))
          (define response
            (if (equal? (% req #5) #0) (* req #2)
               (if (equal? (% req #5) #1) (+ req #10)
                  (if (equal? (% req #5) #2) (- req #1)
                     (if (equal? (% req #5) #3) (* req req)
                        req)))))
          (bind (actor-reply caller response) (lambda (_)
            (srv-loop))))))))
    (srv-loop)))))

;; Client makes 10,000 calls
(define client-10k (actor-spawn (lambda (self)
  (begin
    (define cl-loop (lambda (n total)
      (if (equal? n #0) total
         (bind (actor-call dispatch-server n) (lambda (r)
           (cl-loop (- n #1) (+ total #1)))))))
    (cl-loop #10000 #0)))))

(actor-run #500000)
(test-case :fs-dispatch-10k #10000 (actor-result client-10k))

;;; --- 2. GenServer + ETS: crash/restart cycles, ETS preserved ---

(actor-reset)

(ets-new :server-data)
(ets-insert :server-data :calls #0)

(define ets-server-fn (lambda (self)
  (begin
    (define cur (ets-lookup :server-data :calls))
    (ets-insert :server-data :calls (+ cur #1))
    (bind (actor-receive) (lambda (msg)
      (begin
        (define caller (car (cdr msg)))
        (define req (car (cdr (cdr msg))))
        (ets-insert :server-data :calls (+ (ets-lookup :server-data :calls) #1))
        (if (equal? req :crash)
           (error :server-crash nil)
           (actor-reply caller (ets-lookup :server-data :calls)))))))))

(define ets-sup (sup-start :one-for-one (cons ets-server-fn nil)))
(actor-run #500)

;; Crash and restart 10 times
(define crash-server (lambda (n)
  (if (equal? n #0) :done
     (begin
       (define kids (sup-children ets-sup))
       (define srv (car kids))
       (actor-send srv (cons :call (cons srv (cons :crash nil))))
       (actor-run #2000)
       (crash-server (- n #1))))))

(crash-server #10)

;; ETS counter should be > 10 (initial starts + restarts)
(test-case :fs-ets-survives #t (> (ets-lookup :server-data :calls) #10))

;;; --- 3. Pipeline of 3 GenServers ---

(actor-reset)

(define make-pipe-server (lambda (transform-fn)
  (actor-spawn (lambda (self)
    (begin
      (define ps-loop (lambda ()
        (bind (actor-receive) (lambda (msg)
          (begin
            (define caller (car (cdr msg)))
            (define req (car (cdr (cdr msg))))
            (bind (actor-reply caller (transform-fn req)) (lambda (_)
              (ps-loop))))))))
      (ps-loop))))))

(define validate-srv (make-pipe-server (lambda (x) (if (> x #0) x (error :invalid x)))))
(define process-srv (make-pipe-server (lambda (x) (* x #2))))
(define respond-srv (make-pipe-server (lambda (x) (+ x #100))))

(define pipeline-client (actor-spawn (lambda (self)
  (begin
    (define pipe-loop (lambda (n total)
      (if (equal? n #0) total
         (bind (actor-call validate-srv n) (lambda (v)
           (if (error? v) (pipe-loop (- n #1) total)
              (bind (actor-call process-srv v) (lambda (p)
                (bind (actor-call respond-srv p) (lambda (r)
                  (pipe-loop (- n #1) (+ total #1))))))))))))
    (pipe-loop #5000 #0)))))

(actor-run #500000)
(test-case :fs-pipeline-5k #5000 (actor-result pipeline-client))

;;; --- 4. Supervised farm: 5 GenServers + supervisor, round-robin ---

(actor-reset)

(define make-farm-worker (lambda ()
  (lambda (self)
    (begin
      (define fw-loop (lambda ()
        (bind (actor-receive) (lambda (msg)
          (begin
            (define caller (car (cdr msg)))
            (define req (car (cdr (cdr msg))))
            (bind (actor-reply caller (* req #3)) (lambda (_)
              (fw-loop))))))))
      (fw-loop)))))

(define farm-children (lambda (n acc)
  (if (equal? n #0) acc
     (farm-children (- n #1) (cons (make-farm-worker) acc)))))

(define farm-sup (sup-start :one-for-one (farm-children #5 nil)))
(actor-run #500)

(define farm-kids (sup-children farm-sup))

;; Round-robin client across 5 workers
(define farm-client (actor-spawn (lambda (self)
  (begin
    (define rr-loop (lambda (n total workers)
      (if (equal? n #0) total
         (begin
           (define w (if (null? workers) farm-kids workers))
           (bind (actor-call (car w) n) (lambda (r)
             (rr-loop (- n #1) (+ total #1) (cdr w))))))))
    (rr-loop #10000 #0 farm-kids)))))

(actor-run #500000)
(test-case :fs-farm-10k #10000 (actor-result farm-client))

;;; --- 5. GenServer uses effect handler for computation ---

(actor-reset)

(define effect-server (actor-spawn (lambda (self)
  (begin
    (define es-loop (lambda ()
      (bind (actor-receive) (lambda (msg)
        (begin
          (define caller (car (cdr msg)))
          (define req (car (cdr (cdr msg))))
          (define result (handle (perform :Compute :calc req)
                       (:Compute (:calc (lambda (x) (+ x #42))))))
          (bind (actor-reply caller result) (lambda (_)
            (es-loop))))))))
    (es-loop)))))

(define eff-client (actor-spawn (lambda (self)
  (begin
    (define ec-loop (lambda (n total)
      (if (equal? n #0) total
         (bind (actor-call effect-server n) (lambda (r)
           (ec-loop (- n #1) (+ total r)))))))
    (ec-loop #5000 #0)))))

(actor-run #500000)

;; Each call returns n+42, sum of (n+42) for n=1..5000
(define eff-client-result (actor-result eff-client))
(test-case :fs-effect-server #t (> eff-client-result #0))
