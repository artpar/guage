; ═══════════════════════════════════════════════════════════════
; Test suite for variadic stdlib macros (Day 79)
; ═══════════════════════════════════════════════════════════════
; Verifies unlimited arity for:
; - ∧* (and*) - unlimited args
; - ∨* (or*)  - unlimited args
; - ⇒* (cond) - unlimited clauses
; - ≔⇊ (let*) - unlimited bindings
; - ⇤ (case) - unlimited cases
; ═══════════════════════════════════════════════════════════════

; Load stdlib
(load "bootstrap/stdlib/macros_control.scm")
(load "bootstrap/stdlib/macros_pattern.scm")

; ═══════════════════════════════════════════════════════════════
; Section 1: ∧* (and*) - Unlimited Short-Circuit AND
; ═══════════════════════════════════════════════════════════════

; Zero args - vacuous truth
(test-case :and-zero #t (∧*))

; Single arg
(test-case :and-one-t #t (∧* #t))
(test-case :and-one-f #f (∧* #f))
(test-case :and-one-val #42 (∧* #42))

; Two args
(test-case :and-two-tt #t (∧* #t #t))
(test-case :and-two-tf #f (∧* #t #f))
(test-case :and-two-ft #f (∧* #f #t))

; Five args (beyond old 4-arg limit)
(test-case :and-five-all-t #t (∧* #t #t #t #t #t))
(test-case :and-five-last-f #f (∧* #t #t #t #t #f))
(test-case :and-five-first-f #f (∧* #f #t #t #t #t))

; Ten args
(test-case :and-ten #t (∧* #t #t #t #t #t #t #t #t #t #t))
(test-case :and-ten-fail #f (∧* #t #t #t #t #t #t #t #t #t #f))

; Returns last value if all truthy (only #t is truthy in Guage)
(test-case :and-lisp-val :end (∧* #t #t :end))
(test-case :and-lisp-sym :finally (∧* #t #t #t #t #t :finally))

; Short-circuit test - this would error if not short-circuited
(test-case :and-short #f (∧* #f (/ #1 #0)))

; ═══════════════════════════════════════════════════════════════
; Section 2: ∨* (or*) - Unlimited Short-Circuit OR
; ═══════════════════════════════════════════════════════════════

; Zero args - vacuous false
(test-case :or-zero #f (∨*))

; Single arg
(test-case :or-one-t #t (∨* #t))
(test-case :or-one-f #f (∨* #f))
(test-case :or-one-val #42 (∨* #42))

; Two args
(test-case :or-two-tt #t (∨* #t #t))
(test-case :or-two-tf #t (∨* #t #f))
(test-case :or-two-ft #t (∨* #f #t))
(test-case :or-two-ff #f (∨* #f #f))

; Five args (beyond old 4-arg limit)
(test-case :or-five-all-f #f (∨* #f #f #f #f #f))
(test-case :or-five-last-t #t (∨* #f #f #f #f #t))
(test-case :or-five-first-t #t (∨* #t #f #f #f #f))

; Ten args
(test-case :or-ten-f #f (∨* #f #f #f #f #f #f #f #f #f #f))
(test-case :or-ten-t #t (∨* #f #f #f #f #f #f #f #f #f #t))

; Lisp semantics - returns first truthy value
(test-case :or-lisp-val #42 (∨* #f #42 #99))
(test-case :or-lisp-sym :found (∨* #f #f #f :found :not-reached))

; Short-circuit test - this would error if not short-circuited
(test-case :or-short #t (∨* #t (/ #1 #0)))

; ═══════════════════════════════════════════════════════════════
; Section 3: ⇒* (cond) - Unlimited Clauses
; ═══════════════════════════════════════════════════════════════

; Zero clauses
(test-case :cond-zero nil (⇒*))

; One clause
(test-case :cond-one-t :yes (⇒* (#t :yes)))
(test-case :cond-one-f nil (⇒* (#f :no)))

; Two clauses
(test-case :cond-two-first :first (⇒* (#t :first) (#t :second)))
(test-case :cond-two-second :second (⇒* (#f :first) (#t :second)))

; Five clauses (beyond old 5-clause limit)
(test-case :cond-five :fifth (⇒*
  (#f :1) (#f :2) (#f :3) (#f :4) (#t :fifth)))

; Six clauses
(test-case :cond-six :sixth (⇒*
  (#f :1) (#f :2) (#f :3) (#f :4) (#f :5) (#t :sixth)))

; Ten clauses
(test-case :cond-ten :ten (⇒*
  (#f :1) (#f :2) (#f :3) (#f :4) (#f :5)
  (#f :6) (#f :7) (#f :8) (#f :9) (#t :ten)))

; With expressions
(test-case :cond-expr :big (⇒*
  ((> #5 #10) :small)
  ((> #5 #3) :big)
  (#t :default)))

; ═══════════════════════════════════════════════════════════════
; Section 4: ≔⇊ (let*) - Unlimited Bindings
; ═══════════════════════════════════════════════════════════════

; Zero bindings
(test-case :let-zero #42 (≔⇊ () #42))

; One binding
(test-case :let-one #5 (≔⇊ ((:x #5)) :x))

; Two bindings with dependency
(test-case :let-two #11 (≔⇊ ((:x #5) (:y (+ :x #1))) (+ :x :y)))

; Five bindings (beyond old 4-binding limit)
(test-case :let-five #15 (≔⇊ ((:a #1) (:b #2) (:c #3) (:d #4) (:e #5))
  (+ :a (+ :b (+ :c (+ :d :e))))))

; Six bindings - each references previous
(test-case :let-chain #720 (≔⇊
  ((:a #1)
   (:b (* :a #2))
   (:c (* :b #3))
   (:d (* :c #4))
   (:e (* :d #5))
   (:f (* :e #6)))
  :f))

; Eight bindings
(test-case :let-eight #8 (≔⇊
  ((:a #1) (:b #1) (:c #1) (:d #1)
   (:e #1) (:f #1) (:g #1) (:h #1))
  (+ :a (+ :b (+ :c (+ :d (+ :e (+ :f (+ :g :h)))))))))

; ═══════════════════════════════════════════════════════════════
; Section 5: ⇤ (case) - Unlimited Cases
; ═══════════════════════════════════════════════════════════════

; Just :else
(test-case :case-else :default (⇤ :anything (:else :default)))

; One case, no match
(test-case :case-one-miss nil (⇤ :b (:a :matched)))

; One case with match
(test-case :case-one-hit :matched (⇤ :a (:a :matched)))

; Two cases
(test-case :case-two-first :one (⇤ #1 (#1 :one) (#2 :two)))
(test-case :case-two-second :two (⇤ #2 (#1 :one) (#2 :two)))

; Five cases (beyond old limits)
(test-case :case-five :five (⇤ #5
  (#1 :one) (#2 :two) (#3 :three) (#4 :four) (#5 :five)))

; Six cases with else
(test-case :case-six-else :default (⇤ #99
  (#1 :one) (#2 :two) (#3 :three)
  (#4 :four) (#5 :five) (#6 :six) (:else :default)))

; Ten cases
(test-case :case-ten :ten (⇤ #10
  (#1 :1) (#2 :2) (#3 :3) (#4 :4) (#5 :5)
  (#6 :6) (#7 :7) (#8 :8) (#9 :9) (#10 :ten)))

; Case with symbols - when :green matches, returns :go
(test-case :case-sym :go (⇤ :green
  (:red :stop) (:yellow :slow) (:green :go) (:else :unknown)))

; Verify single evaluation of expr
; bump returns counter value after incrementing, so first call returns #1
; which matches (#1 :one), returning :one
(define counter #0)
(define bump (lambda () (define counter (+ counter #1)) counter))
(test-case :case-single-eval :one (⇤ (bump) (#1 :one) (#2 :two) (:else :other)))
(test-case :case-counter-check #1 counter)

; ═══════════════════════════════════════════════════════════════
; Summary
; ═══════════════════════════════════════════════════════════════
(print "✓ 58 variadic stdlib macro tests complete")
