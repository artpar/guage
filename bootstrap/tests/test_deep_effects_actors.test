;;;
;;; Deep Integration: Effects + Actors + Channels + Resumable Effects + GenServer
;;;

(actor-reset)
(chan-reset)

;;; --- Effect declarations ---

(effect-def :Compute :calc)
(effect-def :State :get :put)
(effect-def :Logger :log)
(effect-def :Yield :value)

;;; --- Actor body uses non-resumable effect handler -> returns computed result ---

(define a1 (actor-spawn (lambda (self)
  (handle (perform :Compute :calc #7)
    (:Compute
      (:calc (lambda (x) (* x #3))))))))

(actor-run #100)
(test-case :actor-effect-basic #21 (actor-result a1))

;;; --- Actor body uses resumable effect handler ---

(define a2 (actor-spawn (lambda (self)
  (handle-resume (+ (perform :State :get) #10)
    (:State
      (:get (lambda (k) (k #5)))
      (:put (lambda (k v) (k nil))))))))

(actor-run #100)
(test-case :actor-resumable #15 (actor-result a2))

;;; --- Actor receives message, uses it inside effect handler ---

(define a3 (actor-spawn (lambda (self)
  (bind (actor-receive) (lambda (msg)
    (handle (perform :Compute :calc msg)
      (:Compute
        (:calc (lambda (x) (* x #2))))))))))

(actor-send a3 #25)
(actor-run #100)
(test-case :actor-msg-effect #50 (actor-result a3))

;;; --- Two actors: producer performs effect, sends result via channel to consumer ---

(define ch1 (chan-create))

(define producer (actor-spawn (lambda (self)
  (begin
    (define pval (handle (perform :Compute :calc #8)
      (:Compute
        (:calc (lambda (x) (+ x #100))))))
    (chan-send ch1 pval)))))

(define consumer (actor-spawn (lambda (self)
  (chan-recv ch1))))

(actor-run #200)
(test-case :producer-consumer #108 (actor-result consumer))

;;; --- Actor with nested effect handlers (:State + :Logger) ---

(define a5 (actor-spawn (lambda (self)
  (handle
    (handle-resume
      (begin (perform :State :put #42)
          (perform :Logger :log :started)
          (perform :State :get))
      (:State
        (:get (lambda (k) (k #42)))
        (:put (lambda (k v) (k nil)))))
    (:Logger
      (:log (lambda (msg) msg)))))))

(actor-run #100)
(test-case :nested-handlers #42 (actor-result a5))

;;; --- Resumable effect with multiple performs inside actor ---

(define a6 (actor-spawn (lambda (self)
  (handle-resume
    (+ (perform :State :get) (perform :State :get))
    (:State
      (:get (lambda (k) (k #20)))
      (:put (lambda (k v) (k nil))))))))

(actor-run #100)
(test-case :multi-perform #40 (actor-result a6))

;;; --- GenServer-style call/reply where server uses effect to compute reply ---

(define gs-server (actor-spawn (lambda (self)
  (bind (actor-receive) (lambda (msg)
    (bind (actor-reply (car (cdr msg))
      (handle (perform :Compute :calc (car (cdr (cdr msg))))
        (:Compute
          (:calc (lambda (x) (+ x #100))))))
    (lambda (_) :done)))))))

(define gs-client (actor-spawn (lambda (self)
  (actor-call gs-server #5))))

(actor-run #100)
(test-case :genserver-effect #105 (actor-result gs-client))

;;; --- Unhandled effect in actor -> error result ---

(define a8 (actor-spawn (lambda (self)
  (perform :Compute :calc #99))))

(actor-run #100)
(test-case :unhandled-effect #t (error? (actor-result a8)))

;;; --- Yield-collect pattern inside actor body ---

(define a10 (actor-spawn (lambda (self)
  (handle-resume
    (begin (perform :Yield :value #1)
        (perform :Yield :value #2)
        (perform :Yield :value #3)
        nil)
    (:Yield
      (:value (lambda (k v) (cons v (k nil)))))))))

(actor-run #100)
(test-case :actor-yield-collect #t
  (deep-equal? (actor-result a10) (cons #1 (cons #2 (cons #3 nil)))))
