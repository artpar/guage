; Day 104: DynamicSupervisor — on-demand child spawning with restart types
; Primitives: ⟳⊛⊹, ⟳⊛⊹⊕, ⟳⊛⊹⊖, ⟳⊛⊹?, dynsup-count

;;; Test 1: dynsup-start — create empty dynamic supervisor
(actor-reset)
(define ds1 (dynsup-start))
(test-case (quote :dynsup-start-basic)
  #t
  (>= ds1 #0))

;;; Test 2: dynsup-count — starts with zero children
(actor-reset)
(define ds2 (dynsup-start))
(test-case (quote :dynsup-count-empty)
  #0
  (dynsup-count ds2))

;;; Test 3: dynsup-start-child permanent — add child, verify alive
(actor-reset)
(define ds3 (dynsup-start))
(define c3 (dynsup-start-child ds3 (lambda (self) (actor-receive)) :permanent))
(actor-run #50)
(test-case (quote :dynsup-start-child-permanent)
  #t
  (and (actor-alive? c3) (equal? (dynsup-count ds3) #1)))

;;; Test 4: dynsup-which-children — list children with restart types
(actor-reset)
(define ds4 (dynsup-start))
(define c4 (dynsup-start-child ds4 (lambda (self) (actor-receive)) :transient))
(actor-run #50)
(define kids4 (dynsup-which-children ds4))
; Should be list of ⟨actor-cell :restart-type⟩
(test-case (quote :dynsup-which-children)
  :transient
  (cdr (car kids4)))

;;; Test 5: dynsup-terminate-child — terminate and remove
(actor-reset)
(define ds5 (dynsup-start))
(define c5 (dynsup-start-child ds5 (lambda (self) (actor-receive)) :permanent))
(actor-run #50)
(dynsup-terminate-child ds5 c5)
(test-case (quote :dynsup-terminate-child)
  #0
  (dynsup-count ds5))

;;; Test 6: permanent child — error crash triggers restart
(actor-reset)
(define ds6 (dynsup-start))
(define crasher6 (lambda (self)
  (bind (actor-receive) (lambda (msg)
    (if (equal? msg :crash) (error :crashed :boom) msg)))))
(define c6 (dynsup-start-child ds6 crasher6 :permanent))
(actor-run #50)
(actor-send c6 :crash)
(actor-run #200)
; Permanent: should restart on error — count stays 1
(test-case (quote :dynsup-permanent-restarts)
  #1
  (dynsup-count ds6))

;;; Test 7: temporary child — never restarted on error
(actor-reset)
(define ds7 (dynsup-start))
(define crasher7 (lambda (self)
  (bind (actor-receive) (lambda (msg)
    (if (equal? msg :crash) (error :crashed :boom) msg)))))
(define c7 (dynsup-start-child ds7 crasher7 :temporary))
(actor-run #50)
(actor-send c7 :crash)
(actor-run #200)
; Temporary: not restarted, removed from children
(test-case (quote :dynsup-temporary-no-restart)
  #0
  (dynsup-count ds7))

;;; Test 8: transient child — not restarted on normal exit
(actor-reset)
(define ds8 (dynsup-start))
; Normal exit child
(define normal8 (lambda (self) :done))
(define c8a (dynsup-start-child ds8 normal8 :transient))
(actor-run #100)
; Transient: normal exit -> not restarted, removed
(test-case (quote :dynsup-transient-normal-no-restart)
  #0
  (dynsup-count ds8))

;;; Test 9: transient child — restarts on error exit
(actor-reset)
(define ds9 (dynsup-start))
(define crasher9 (lambda (self)
  (bind (actor-receive) (lambda (msg)
    (if (equal? msg :crash) (error :crashed :boom) msg)))))
(define c9 (dynsup-start-child ds9 crasher9 :transient))
(actor-run #50)
(actor-send c9 :crash)
(actor-run #200)
; Transient: error exit -> restarted
(test-case (quote :dynsup-transient-error-restarts)
  #1
  (dynsup-count ds9))

;;; Test 10: multiple children with mixed restart types
(actor-reset)
(define ds10 (dynsup-start))
(define w10 (lambda (self) (actor-receive)))
(dynsup-start-child ds10 w10 :permanent)
(dynsup-start-child ds10 w10 :transient)
(dynsup-start-child ds10 w10 :temporary)
(actor-run #50)
(test-case (quote :dynsup-multiple-children)
  #3
  (dynsup-count ds10))
