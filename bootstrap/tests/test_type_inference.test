#!/usr/bin/env guage
; Test suite for type inference (Day 85)
; Deep type inference: type-infer (infer value type), type-prim-sig (primitive signatures)

(print "Testing Type Inference System...")

; ============================================================================
; Part 1: type-infer (Deep Value Type Inference)
; ============================================================================

(print "\nTesting type-infer (deep value type inference)...")

; --- Basic types (same as type-of but always returns type structs) ---

(test-case :infer-int
   #t
   (type-equal? (type-infer #42) (Int)))

(test-case :infer-bool-true
   #t
   (type-equal? (type-infer #t) (Bool)))

(test-case :infer-bool-false
   #t
   (type-equal? (type-infer #f) (Bool)))

(test-case :infer-string
   #t
   (type-equal? (type-infer "hello") (String)))

(test-case :infer-nil
   #t
   (type-equal? (type-infer nil) (Nil-type)))

; --- Pair types (DEEP - unlike type-of which returns :pair) ---

(test-case :infer-pair-int-int
   #t
   (type-equal? (type-infer (cons #1 #2)) (Pair-type (Int) (Int))))

(test-case :infer-pair-string-bool
   #t
   (type-equal? (type-infer (cons "hi" #t)) (Pair-type (String) (Bool))))

(test-case :infer-pair-int-string
   #t
   (type-equal? (type-infer (cons #1 "abc")) (Pair-type (Int) (String))))

(test-case :infer-pair-nested
   #t
   (type-equal? (type-infer (cons #1 (cons #2 #3)))
        (Pair-type (Int) (Pair-type (Int) (Int)))))

; --- List types (detect proper lists: nil-terminated pair chains) ---

(test-case :infer-list-empty
   #t
   (type-equal? (type-infer nil) (Nil-type)))

; Single-element list: (cons #1 nil)
(test-case :infer-list-single-int
   #t
   (type-equal? (type-infer (cons #1 nil)) (List-type (Int))))

; Multi-element list: (cons #1 (cons #2 (cons #3 nil)))
(test-case :infer-list-multi-int
   #t
   (type-equal? (type-infer (cons #1 (cons #2 (cons #3 nil)))) (List-type (Int))))

; String list
(test-case :infer-list-strings
   #t
   (type-equal? (type-infer (cons "a" (cons "b" nil))) (List-type (String))))

; Bool list
(test-case :infer-list-bools
   #t
   (type-equal? (type-infer (cons #t (cons #f nil))) (List-type (Bool))))

; Mixed-type list -> union element type
(test-case :infer-list-mixed
   #t
   (type-equal? (type-infer (cons #1 (cons "hi" nil))) (List-type (Union-type (Int) (String)))))

; Nested list: list of lists
(test-case :infer-list-of-lists
   #t
   (type-equal? (type-infer (cons (cons #1 nil) (cons (cons #2 nil) nil)))
        (List-type (List-type (Int)))))

; Improper pair (cdr is NOT nil or pair) stays as pair type
(test-case :infer-improper-pair
   #t
   (type-equal? (type-infer (cons #1 #2)) (Pair-type (Int) (Int))))

; --- Function types ---

; Lambda with declared type -> use declaration
(define inf-add (lambda (x y) (+ x y)))
(type-decl inf-add (-> (Int) (Int) (Int)))

(test-case :infer-func-declared
   #t
   (type-equal? (type-infer inf-add) (-> (Int) (Int) (Int))))

; Lambda without declared type -> generic function type
(define inf-id (lambda (x) x))

(test-case :infer-func-undeclared
   #t
   (type-equal? (type-infer inf-id) (-> (Any) (Any))))

; Multi-arg lambda without declaration
(define inf-pair-fn (lambda (x y) (cons x y)))

(test-case :infer-func-multi-undeclared
   #t
   (type-equal? (type-infer inf-pair-fn) (-> (Any) (Any) (Any))))

; --- Symbol type ---

(test-case :infer-symbol
   #t
   (type-equal? (type-infer :hello) (type-infer :world)))

; --- Error type ---

(test-case :infer-error
   #t
   (type-equal? (type-infer (error :oops #0)) (type-infer (error :other #1))))

; --- Struct type (user-defined structures) ---

(struct-define :inf-point :x :y)
(define p1 (struct-create :inf-point #3 #4))

; Struct inference returns type struct with the struct's tag
(test-case :infer-struct
   #t
   (type-equal? (type-infer p1) (type-infer (struct-create :inf-point #7 #8))))

; ============================================================================
; Part 2: type-infer for named bindings (uses annotation registry)
; ============================================================================

(print "\nTesting type-infer for named bindings...")

; Annotated binding - use annotation
(define typed-x #42)
(type-decl typed-x (Int))

(test-case :infer-named-annotated
   #t
   (type-equal? (type-infer typed-x) (Int)))

; Annotated function
(define typed-inc (lambda (n) (+ n #1)))
(type-decl typed-inc (-> (Int) (Int)))

(test-case :infer-named-func-annotated
   #t
   (type-equal? (type-infer typed-inc) (-> (Int) (Int))))

; Unannotated binding - infer from value
(define untyped-y "hello")

(test-case :infer-named-unannotated
   #t
   (type-equal? (type-infer untyped-y) (String)))

; ============================================================================
; Part 3: type-prim-sig (Primitive Type Signatures)
; ============================================================================

(print "\nTesting type-prim-sig (primitive type signatures)...")

; --- Arithmetic primitives ---

(test-case :sig-add
   #t
   (type-equal? (type-prim-sig :+) (-> (Int) (Int) (Int))))

(test-case :sig-sub
   #t
   (type-equal? (type-prim-sig :-) (-> (Int) (Int) (Int))))

(test-case :sig-mul
   #t
   (type-equal? (type-prim-sig :*) (-> (Int) (Int) (Int))))

(test-case :sig-div
   #t
   (type-equal? (type-prim-sig :/) (-> (Int) (Int) (Int))))

(test-case :sig-mod
   #t
   (type-equal? (type-prim-sig :%) (-> (Int) (Int) (Int))))

; --- Comparison primitives ---

(test-case :sig-eq
   #t
   (type-equal? (type-prim-sig :equal?) (-> (Any) (Any) (Bool))))

(test-case :sig-neq
   #t
   (type-equal? (type-prim-sig :not-equal?) (-> (Any) (Any) (Bool))))

(test-case :sig-lt
   #t
   (type-equal? (type-prim-sig :<) (-> (Int) (Int) (Bool))))

(test-case :sig-gt
   #t
   (type-equal? (type-prim-sig :>) (-> (Int) (Int) (Bool))))

(test-case :sig-le
   #t
   (type-equal? (type-prim-sig :<=) (-> (Int) (Int) (Bool))))

(test-case :sig-ge
   #t
   (type-equal? (type-prim-sig :>=) (-> (Int) (Int) (Bool))))

; --- Logic primitives ---

(test-case :sig-and
   #t
   (type-equal? (type-prim-sig :and) (-> (Bool) (Bool) (Bool))))

(test-case :sig-or
   #t
   (type-equal? (type-prim-sig :or) (-> (Bool) (Bool) (Bool))))

(test-case :sig-not
   #t
   (type-equal? (type-prim-sig :not) (-> (Bool) (Bool))))

; --- List primitives ---

(test-case :sig-cons
   #t
   (type-equal? (type-prim-sig :cons) (-> (Any) (Any) (Any))))

(test-case :sig-car
   #t
   (type-equal? (type-prim-sig :car) (-> (Any) (Any))))

(test-case :sig-cdr
   #t
   (type-equal? (type-prim-sig :cdr) (-> (Any) (Any))))

; --- Type primitives ---

(test-case :sig-typeof
   #t
   (type-equal? (type-prim-sig :type-of) (-> (Any) (Any))))

; --- Error primitives ---

(test-case :sig-is-error
   #t
   (type-equal? (type-prim-sig :error?) (-> (Any) (Bool))))

; --- String primitives ---

(test-case :sig-str-len
   #t
   (type-equal? (type-prim-sig :string-length) (-> (String) (Int))))

(test-case :sig-str-cat
   #t
   (type-equal? (type-prim-sig :string-append) (-> (String) (String) (String))))

; Unknown primitive returns nil
(test-case :sig-unknown
   #t
   (equal? (type-prim-sig :nonexistent-prim) nil))

; ============================================================================
; Part 4: type-infer-all (Expression Type Inference - without evaluation)
; ============================================================================

(print "\nTesting type-infer-all (expression type inference)...")

; --- Literal inference ---

(test-case :expr-infer-number
   #t
   (type-equal? (type-infer-all #42) (Int)))

(test-case :expr-infer-bool
   #t
   (type-equal? (type-infer-all #t) (Bool)))

(test-case :expr-infer-string
   #t
   (type-equal? (type-infer-all "hello") (String)))

(test-case :expr-infer-nil
   #t
   (type-equal? (type-infer-all nil) (Nil-type)))

; --- Symbol inference (uses annotation registry) ---

(define expr-typed-val #42)
(type-decl expr-typed-val (Int))

(test-case :expr-infer-symbol-annotated
   #t
   (type-equal? (type-infer-all expr-typed-val) (Int)))

; Unannotated symbol -> infer from current value
(define expr-untyped-val "world")

(test-case :expr-infer-symbol-unannotated
   #t
   (type-equal? (type-infer-all expr-untyped-val) (String)))

; --- Primitive application inference ---

(test-case :expr-infer-add
   #t
   (type-equal? (type-infer-all (+ #1 #2)) (Int)))

(test-case :expr-infer-sub
   #t
   (type-equal? (type-infer-all (- #5 #3)) (Int)))

(test-case :expr-infer-mul
   #t
   (type-equal? (type-infer-all (* #2 #3)) (Int)))

(test-case :expr-infer-lt
   #t
   (type-equal? (type-infer-all (< #1 #2)) (Bool)))

(test-case :expr-infer-eq
   #t
   (type-equal? (type-infer-all (equal? #1 #2)) (Bool)))

(test-case :expr-infer-and
   #t
   (type-equal? (type-infer-all (and #t #f)) (Bool)))

(test-case :expr-infer-not
   #t
   (type-equal? (type-infer-all (not #t)) (Bool)))

(test-case :expr-infer-str-cat
   #t
   (type-equal? (type-infer-all (string-append "a" "b")) (String)))

(test-case :expr-infer-str-len
   #t
   (type-equal? (type-infer-all (string-length "hello")) (Int)))

; --- Conditional inference (union of branches) ---

(test-case :expr-infer-cond-same
   #t
   (type-equal? (type-infer-all (if #t #1 #2)) (Int)))

(test-case :expr-infer-cond-different
   #t
   (type-equal? (type-infer-all (if #t #1 "hello")) (Union-type (Int) (String))))

(test-case :expr-infer-cond-bool
   #t
   (type-equal? (type-infer-all (if #t #t #f)) (Bool)))

; --- Lambda inference ---

(test-case :expr-infer-lambda-simple
   #t
   (type-equal? (type-infer-all (lambda (x) #42)) (-> (Any) (Int))))

(test-case :expr-infer-lambda-multi
   #t
   (type-equal? (type-infer-all (lambda (x y) (+ x y))) (-> (Any) (Any) (Int))))

(test-case :expr-infer-lambda-bool-body
   #t
   (type-equal? (type-infer-all (lambda (x) (< x #0))) (-> (Any) (Bool))))

; --- Nested expression inference ---

(test-case :expr-infer-nested-arith
   #t
   (type-equal? (type-infer-all (+ (* #2 #3) #1)) (Int)))

(test-case :expr-infer-nested-compare
   #t
   (type-equal? (type-infer-all (and (< #1 #2) (> #3 #0))) (Bool)))

; --- Function application inference ---

(define my-inc (lambda (n) (+ n #1)))
(type-decl my-inc (-> (Int) (Int)))

(test-case :expr-infer-user-func-call
   #t
   (type-equal? (type-infer-all (my-inc #5)) (Int)))

; Unannotated function application -> Any
(define my-id (lambda (x) x))

(test-case :expr-infer-untyped-func-call
   #t
   (type-equal? (type-infer-all (my-id #5)) (Any)))

; ============================================================================
; Summary
; ============================================================================

(print "\nType Inference tests complete!")
