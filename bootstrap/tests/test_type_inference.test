#!/usr/bin/env guage
; Test suite for type inference (Day 85)
; Deep type inference: âˆˆâœ (infer value type), âˆˆâœâŠ• (primitive signatures)

(â‰‹ "Testing Type Inference System...")

; ============================================================================
; Part 1: âˆˆâœ (Deep Value Type Inference)
; ============================================================================

(â‰‹ "\nTesting âˆˆâœ (deep value type inference)...")

; --- Basic types (same as âˆˆâŠ™ but always returns type structs) ---

(âŠ¨ :infer-int
   #t
   (âˆˆâ‰¡ (âˆˆâœ #42) (â„¤)))

(âŠ¨ :infer-bool-true
   #t
   (âˆˆâ‰¡ (âˆˆâœ #t) (ğ”¹)))

(âŠ¨ :infer-bool-false
   #t
   (âˆˆâ‰¡ (âˆˆâœ #f) (ğ”¹)))

(âŠ¨ :infer-string
   #t
   (âˆˆâ‰¡ (âˆˆâœ "hello") (ğ•Š)))

(âŠ¨ :infer-nil
   #t
   (âˆˆâ‰¡ (âˆˆâœ âˆ…) (âˆ…â‚œ)))

; --- Pair types (DEEP - unlike âˆˆâŠ™ which returns :pair) ---

(âŠ¨ :infer-pair-int-int
   #t
   (âˆˆâ‰¡ (âˆˆâœ (âŸ¨âŸ© #1 #2)) (âŸ¨âŸ©â‚œ (â„¤) (â„¤))))

(âŠ¨ :infer-pair-string-bool
   #t
   (âˆˆâ‰¡ (âˆˆâœ (âŸ¨âŸ© "hi" #t)) (âŸ¨âŸ©â‚œ (ğ•Š) (ğ”¹))))

(âŠ¨ :infer-pair-int-string
   #t
   (âˆˆâ‰¡ (âˆˆâœ (âŸ¨âŸ© #1 "abc")) (âŸ¨âŸ©â‚œ (â„¤) (ğ•Š))))

(âŠ¨ :infer-pair-nested
   #t
   (âˆˆâ‰¡ (âˆˆâœ (âŸ¨âŸ© #1 (âŸ¨âŸ© #2 #3)))
        (âŸ¨âŸ©â‚œ (â„¤) (âŸ¨âŸ©â‚œ (â„¤) (â„¤)))))

; --- List types (detect proper lists: nil-terminated pair chains) ---

(âŠ¨ :infer-list-empty
   #t
   (âˆˆâ‰¡ (âˆˆâœ âˆ…) (âˆ…â‚œ)))

; Single-element list: (âŸ¨âŸ© #1 âˆ…)
(âŠ¨ :infer-list-single-int
   #t
   (âˆˆâ‰¡ (âˆˆâœ (âŸ¨âŸ© #1 âˆ…)) ([]â‚œ (â„¤))))

; Multi-element list: (âŸ¨âŸ© #1 (âŸ¨âŸ© #2 (âŸ¨âŸ© #3 âˆ…)))
(âŠ¨ :infer-list-multi-int
   #t
   (âˆˆâ‰¡ (âˆˆâœ (âŸ¨âŸ© #1 (âŸ¨âŸ© #2 (âŸ¨âŸ© #3 âˆ…)))) ([]â‚œ (â„¤))))

; String list
(âŠ¨ :infer-list-strings
   #t
   (âˆˆâ‰¡ (âˆˆâœ (âŸ¨âŸ© "a" (âŸ¨âŸ© "b" âˆ…))) ([]â‚œ (ğ•Š))))

; Bool list
(âŠ¨ :infer-list-bools
   #t
   (âˆˆâ‰¡ (âˆˆâœ (âŸ¨âŸ© #t (âŸ¨âŸ© #f âˆ…))) ([]â‚œ (ğ”¹))))

; Mixed-type list â†’ union element type
(âŠ¨ :infer-list-mixed
   #t
   (âˆˆâ‰¡ (âˆˆâœ (âŸ¨âŸ© #1 (âŸ¨âŸ© "hi" âˆ…))) ([]â‚œ (âˆªâ‚œ (â„¤) (ğ•Š)))))

; Nested list: list of lists
(âŠ¨ :infer-list-of-lists
   #t
   (âˆˆâ‰¡ (âˆˆâœ (âŸ¨âŸ© (âŸ¨âŸ© #1 âˆ…) (âŸ¨âŸ© (âŸ¨âŸ© #2 âˆ…) âˆ…)))
        ([]â‚œ ([]â‚œ (â„¤)))))

; Improper pair (cdr is NOT nil or pair) stays as pair type
(âŠ¨ :infer-improper-pair
   #t
   (âˆˆâ‰¡ (âˆˆâœ (âŸ¨âŸ© #1 #2)) (âŸ¨âŸ©â‚œ (â„¤) (â„¤))))

; --- Function types ---

; Lambda with declared type â†’ use declaration
(â‰” inf-add (Î» (x y) (âŠ• x y)))
(âˆˆ inf-add (â†’ (â„¤) (â„¤) (â„¤)))

(âŠ¨ :infer-func-declared
   #t
   (âˆˆâ‰¡ (âˆˆâœ inf-add) (â†’ (â„¤) (â„¤) (â„¤))))

; Lambda without declared type â†’ generic function type
(â‰” inf-id (Î» (x) x))

(âŠ¨ :infer-func-undeclared
   #t
   (âˆˆâ‰¡ (âˆˆâœ inf-id) (â†’ (âŠ¤) (âŠ¤))))

; Multi-arg lambda without declaration
(â‰” inf-pair-fn (Î» (x y) (âŸ¨âŸ© x y)))

(âŠ¨ :infer-func-multi-undeclared
   #t
   (âˆˆâ‰¡ (âˆˆâœ inf-pair-fn) (â†’ (âŠ¤) (âŠ¤) (âŠ¤))))

; --- Symbol type ---

(âŠ¨ :infer-symbol
   #t
   (âˆˆâ‰¡ (âˆˆâœ :hello) (âˆˆâœ :world)))

; --- Error type ---

(âŠ¨ :infer-error
   #t
   (âˆˆâ‰¡ (âˆˆâœ (âš  :oops #0)) (âˆˆâœ (âš  :other #1))))

; --- Struct type (user-defined structures) ---

(âŠ™â‰” :inf-point :x :y)
(â‰” p1 (âŠ™ :inf-point #3 #4))

; Struct inference returns type struct with the struct's tag
(âŠ¨ :infer-struct
   #t
   (âˆˆâ‰¡ (âˆˆâœ p1) (âˆˆâœ (âŠ™ :inf-point #7 #8))))

; ============================================================================
; Part 2: âˆˆâœ for named bindings (uses annotation registry)
; ============================================================================

(â‰‹ "\nTesting âˆˆâœ for named bindings...")

; Annotated binding - use annotation
(â‰” typed-x #42)
(âˆˆ typed-x (â„¤))

(âŠ¨ :infer-named-annotated
   #t
   (âˆˆâ‰¡ (âˆˆâœ typed-x) (â„¤)))

; Annotated function
(â‰” typed-inc (Î» (n) (âŠ• n #1)))
(âˆˆ typed-inc (â†’ (â„¤) (â„¤)))

(âŠ¨ :infer-named-func-annotated
   #t
   (âˆˆâ‰¡ (âˆˆâœ typed-inc) (â†’ (â„¤) (â„¤))))

; Unannotated binding - infer from value
(â‰” untyped-y "hello")

(âŠ¨ :infer-named-unannotated
   #t
   (âˆˆâ‰¡ (âˆˆâœ untyped-y) (ğ•Š)))

; ============================================================================
; Part 3: âˆˆâœâŠ• (Primitive Type Signatures)
; ============================================================================

(â‰‹ "\nTesting âˆˆâœâŠ• (primitive type signatures)...")

; --- Arithmetic primitives ---

(âŠ¨ :sig-add
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :âŠ•) (â†’ (â„¤) (â„¤) (â„¤))))

(âŠ¨ :sig-sub
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :âŠ–) (â†’ (â„¤) (â„¤) (â„¤))))

(âŠ¨ :sig-mul
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :âŠ—) (â†’ (â„¤) (â„¤) (â„¤))))

(âŠ¨ :sig-div
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :âŠ˜) (â†’ (â„¤) (â„¤) (â„¤))))

(âŠ¨ :sig-mod
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :%) (â†’ (â„¤) (â„¤) (â„¤))))

; --- Comparison primitives ---

(âŠ¨ :sig-eq
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :â‰¡) (â†’ (âŠ¤) (âŠ¤) (ğ”¹))))

(âŠ¨ :sig-neq
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :â‰¢) (â†’ (âŠ¤) (âŠ¤) (ğ”¹))))

(âŠ¨ :sig-lt
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :<) (â†’ (â„¤) (â„¤) (ğ”¹))))

(âŠ¨ :sig-gt
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :>) (â†’ (â„¤) (â„¤) (ğ”¹))))

(âŠ¨ :sig-le
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :â‰¤) (â†’ (â„¤) (â„¤) (ğ”¹))))

(âŠ¨ :sig-ge
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :â‰¥) (â†’ (â„¤) (â„¤) (ğ”¹))))

; --- Logic primitives ---

(âŠ¨ :sig-and
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :âˆ§) (â†’ (ğ”¹) (ğ”¹) (ğ”¹))))

(âŠ¨ :sig-or
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :âˆ¨) (â†’ (ğ”¹) (ğ”¹) (ğ”¹))))

(âŠ¨ :sig-not
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :Â¬) (â†’ (ğ”¹) (ğ”¹))))

; --- List primitives ---

(âŠ¨ :sig-cons
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :âŸ¨âŸ©) (â†’ (âŠ¤) (âŠ¤) (âŠ¤))))

(âŠ¨ :sig-car
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :â—) (â†’ (âŠ¤) (âŠ¤))))

(âŠ¨ :sig-cdr
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :â–·) (â†’ (âŠ¤) (âŠ¤))))

; --- Type primitives ---

(âŠ¨ :sig-typeof
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :âˆˆâŠ™) (â†’ (âŠ¤) (âŠ¤))))

; --- Error primitives ---

(âŠ¨ :sig-is-error
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :âš ?) (â†’ (âŠ¤) (ğ”¹))))

; --- String primitives ---

(âŠ¨ :sig-str-len
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :â‰ˆ#) (â†’ (ğ•Š) (â„¤))))

(âŠ¨ :sig-str-cat
   #t
   (âˆˆâ‰¡ (âˆˆâœâŠ• :â‰ˆâŠ•) (â†’ (ğ•Š) (ğ•Š) (ğ•Š))))

; Unknown primitive returns nil
(âŠ¨ :sig-unknown
   #t
   (â‰¡ (âˆˆâœâŠ• :nonexistent-prim) âˆ…))

; ============================================================================
; Part 4: âˆˆâœ* (Expression Type Inference - without evaluation)
; ============================================================================

(â‰‹ "\nTesting âˆˆâœ* (expression type inference)...")

; --- Literal inference ---

(âŠ¨ :expr-infer-number
   #t
   (âˆˆâ‰¡ (âˆˆâœ* #42) (â„¤)))

(âŠ¨ :expr-infer-bool
   #t
   (âˆˆâ‰¡ (âˆˆâœ* #t) (ğ”¹)))

(âŠ¨ :expr-infer-string
   #t
   (âˆˆâ‰¡ (âˆˆâœ* "hello") (ğ•Š)))

(âŠ¨ :expr-infer-nil
   #t
   (âˆˆâ‰¡ (âˆˆâœ* âˆ…) (âˆ…â‚œ)))

; --- Symbol inference (uses annotation registry) ---

(â‰” expr-typed-val #42)
(âˆˆ expr-typed-val (â„¤))

(âŠ¨ :expr-infer-symbol-annotated
   #t
   (âˆˆâ‰¡ (âˆˆâœ* expr-typed-val) (â„¤)))

; Unannotated symbol â†’ infer from current value
(â‰” expr-untyped-val "world")

(âŠ¨ :expr-infer-symbol-unannotated
   #t
   (âˆˆâ‰¡ (âˆˆâœ* expr-untyped-val) (ğ•Š)))

; --- Primitive application inference ---

(âŠ¨ :expr-infer-add
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (âŠ• #1 #2)) (â„¤)))

(âŠ¨ :expr-infer-sub
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (âŠ– #5 #3)) (â„¤)))

(âŠ¨ :expr-infer-mul
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (âŠ— #2 #3)) (â„¤)))

(âŠ¨ :expr-infer-lt
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (< #1 #2)) (ğ”¹)))

(âŠ¨ :expr-infer-eq
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (â‰¡ #1 #2)) (ğ”¹)))

(âŠ¨ :expr-infer-and
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (âˆ§ #t #f)) (ğ”¹)))

(âŠ¨ :expr-infer-not
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (Â¬ #t)) (ğ”¹)))

(âŠ¨ :expr-infer-str-cat
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (â‰ˆâŠ• "a" "b")) (ğ•Š)))

(âŠ¨ :expr-infer-str-len
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (â‰ˆ# "hello")) (â„¤)))

; --- Conditional inference (union of branches) ---

(âŠ¨ :expr-infer-cond-same
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (? #t #1 #2)) (â„¤)))

(âŠ¨ :expr-infer-cond-different
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (? #t #1 "hello")) (âˆªâ‚œ (â„¤) (ğ•Š))))

(âŠ¨ :expr-infer-cond-bool
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (? #t #t #f)) (ğ”¹)))

; --- Lambda inference ---

(âŠ¨ :expr-infer-lambda-simple
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (Î» (x) #42)) (â†’ (âŠ¤) (â„¤))))

(âŠ¨ :expr-infer-lambda-multi
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (Î» (x y) (âŠ• x y))) (â†’ (âŠ¤) (âŠ¤) (â„¤))))

(âŠ¨ :expr-infer-lambda-bool-body
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (Î» (x) (< x #0))) (â†’ (âŠ¤) (ğ”¹))))

; --- Nested expression inference ---

(âŠ¨ :expr-infer-nested-arith
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (âŠ• (âŠ— #2 #3) #1)) (â„¤)))

(âŠ¨ :expr-infer-nested-compare
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (âˆ§ (< #1 #2) (> #3 #0))) (ğ”¹)))

; --- Function application inference ---

(â‰” my-inc (Î» (n) (âŠ• n #1)))
(âˆˆ my-inc (â†’ (â„¤) (â„¤)))

(âŠ¨ :expr-infer-user-func-call
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (my-inc #5)) (â„¤)))

; Unannotated function application â†’ âŠ¤
(â‰” my-id (Î» (x) x))

(âŠ¨ :expr-infer-untyped-func-call
   #t
   (âˆˆâ‰¡ (âˆˆâœ* (my-id #5)) (âŠ¤)))

; ============================================================================
; Summary
; ============================================================================

(â‰‹ "\nType Inference tests complete!")
