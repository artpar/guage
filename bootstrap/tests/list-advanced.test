; Test Suite: Advanced List Utilities
; Tests for ⊽, ⊤⊥, ⊟, ↦⊟, ↑?, ↓?, ⊠, ⊡, ⋈, ∪, ⊳, ⊳#, ⊴, ⊴<

; Load required modules
(load "bootstrap/stdlib/list.scm")

; ============================================================================
; List Transformation Tests
; ============================================================================

; ⊽ (unzip) - Split paired list into two lists
(test-case :unzip-basic
   (cons (cons #1 (cons #3 nil)) (cons #2 (cons #4 nil)))
   (⊽ (cons (cons #1 #2) (cons (cons #3 #4) nil))))

(test-case :unzip-single
   (cons (cons #1 nil) (cons #2 nil))
   (⊽ (cons (cons #1 #2) nil)))

(test-case :unzip-empty
   (cons nil nil)
   (⊽ nil))

; ⊤⊥ (transpose) - Rotate matrix of lists
(test-case :transpose-2x2
   (cons (cons #1 (cons #3 nil)) (cons (cons #2 (cons #4 nil)) nil))
   (⊤⊥ (cons (cons #1 (cons #2 nil)) (cons (cons #3 (cons #4 nil)) nil))))

(test-case :transpose-3x2
   (cons (cons #1 (cons #4 nil)) (cons (cons #2 (cons #5 nil)) (cons (cons #3 (cons #6 nil)) nil)))
   (⊤⊥ (cons (cons #1 (cons #2 (cons #3 nil))) (cons (cons #4 (cons #5 (cons #6 nil))) nil))))

(test-case :transpose-empty
   nil
   (⊤⊥ nil))

; deque (flatten) - Deep list flattening
(test-case :flatten-basic
   (cons #1 (cons #2 (cons #3 nil)))
   (deque (cons (cons #1 (cons #2 nil)) (cons (cons #3 nil) nil))))

(test-case :flatten-single
   (cons #1 (cons #2 nil))
   (deque (cons (cons #1 (cons #2 nil)) nil)))

(test-case :flatten-empty
   nil
   (deque nil))

(test-case :flatten-mixed
   (cons #1 (cons #2 (cons #3 (cons #4 nil))))
   (deque (cons (cons #1 nil) (cons (cons #2 (cons #3 nil)) (cons (cons #4 nil) nil)))))

; ↦⊟ (flat-map) - map + flatten
(test-case :flatmap-basic
   (cons #1 (cons #1 (cons #2 (cons #2 (cons #3 (cons #3 nil))))))
   ((↦⊟ (lambda (x) (cons x (cons x nil)))) (cons #1 (cons #2 (cons #3 nil)))))

(test-case :flatmap-empty
   nil
   ((↦⊟ (lambda (x) (cons x nil))) nil))

; ============================================================================
; Conditional List Operations Tests
; ============================================================================

; ↑? (take-while) - Take elements while predicate true
(test-case :takewhile-basic
   (cons #1 (cons #2 nil))
   ((↑? (lambda (x) (< x #5))) (cons #1 (cons #2 (cons #7 (cons #8 nil))))))

(test-case :takewhile-all
   (cons #1 (cons #2 (cons #3 nil)))
   ((↑? (lambda (x) (< x #10))) (cons #1 (cons #2 (cons #3 nil)))))

(test-case :takewhile-none
   nil
   ((↑? (lambda (x) (< x #1))) (cons #1 (cons #2 (cons #3 nil)))))

(test-case :takewhile-empty
   nil
   ((↑? (lambda (x) #t)) nil))

; ↓? (drop-while) - Drop elements while predicate true
(test-case :dropwhile-basic
   (cons #7 (cons #8 nil))
   ((↓? (lambda (x) (< x #5))) (cons #1 (cons #2 (cons #7 (cons #8 nil))))))

(test-case :dropwhile-all
   nil
   ((↓? (lambda (x) (< x #10))) (cons #1 (cons #2 (cons #3 nil)))))

(test-case :dropwhile-none
   (cons #1 (cons #2 (cons #3 nil)))
   ((↓? (lambda (x) (< x #1))) (cons #1 (cons #2 (cons #3 nil)))))

(test-case :dropwhile-empty
   nil
   ((↓? (lambda (x) #t)) nil))

; ⊠ (partition) - Split into [true, false] by predicate
(test-case :partition-evens
   (cons (cons #2 (cons #4 nil)) (cons #1 (cons #3 nil)))
   ((⊠ (lambda (x) (equal? (% x #2) #0))) (cons #1 (cons #2 (cons #3 (cons #4 nil))))))

(test-case :partition-all-true
   (cons (cons #1 (cons #2 nil)) nil)
   ((⊠ (lambda (x) #t)) (cons #1 (cons #2 nil))))

(test-case :partition-all-false
   (cons nil (cons #1 (cons #2 nil)))
   ((⊠ (lambda (x) #f)) (cons #1 (cons #2 nil))))

(test-case :partition-empty
   (cons nil nil)
   ((⊠ (lambda (x) #t)) nil))

; apply-primitive (group-by) - Group elements by key function
(test-case :groupby-modulo
   (cons (cons #1 (cons #3 (cons #1 nil))) (cons (cons #0 (cons #4 (cons #2 nil))) nil))
   ((apply-primitive (lambda (x) (% x #2))) (cons #1 (cons #2 (cons #3 (cons #4 nil))))))

(test-case :groupby-identity
   (cons (cons #1 (cons #1 nil)) (cons (cons #2 (cons #2 nil)) (cons (cons #3 (cons #3 nil)) nil)))
   ((apply-primitive (lambda (x) x)) (cons #1 (cons #2 (cons #3 nil)))))

(test-case :groupby-empty
   nil
   ((apply-primitive (lambda (x) x)) nil))

; ============================================================================
; List Manipulation Tests
; ============================================================================

; ⋈ (interleave) - Merge lists alternating elements
(test-case :interleave-same-length
   (cons #1 (cons #3 (cons #2 (cons #4 nil))))
   ((⋈ (cons #1 (cons #2 nil))) (cons #3 (cons #4 nil))))

(test-case :interleave-first-longer
   (cons #1 (cons #3 (cons #2 nil)))
   ((⋈ (cons #1 (cons #2 nil))) (cons #3 nil)))

(test-case :interleave-second-longer
   (cons #1 (cons #3 (cons #4 nil)))
   ((⋈ (cons #1 nil)) (cons #3 (cons #4 nil))))

(test-case :interleave-first-empty
   (cons #1 (cons #2 nil))
   ((⋈ nil) (cons #1 (cons #2 nil))))

(test-case :interleave-both-empty
   nil
   ((⋈ nil) nil))

; ∪ (deduplicate) - Remove duplicates
(test-case :dedup-basic
   (cons #1 (cons #2 (cons #3 nil)))
   (∪ (cons #1 (cons #2 (cons #1 (cons #3 (cons #2 nil)))))))

(test-case :dedup-no-duplicates
   (cons #1 (cons #2 (cons #3 nil)))
   (∪ (cons #1 (cons #2 (cons #3 nil)))))

(test-case :dedup-all-same
   (cons #1 nil)
   (∪ (cons #1 (cons #1 (cons #1 nil)))))

(test-case :dedup-empty
   nil
   (∪ nil))

; generic-param (find) - First element matching predicate
(test-case :find-exists
   #3
   ((generic-param (lambda (x) (> x #2))) (cons #1 (cons #2 (cons #3 (cons #4 nil))))))

(test-case :find-not-found
   nil
   ((generic-param (lambda (x) (> x #10))) (cons #1 (cons #2 (cons #3 nil)))))

(test-case :find-empty
   nil
   ((generic-param (lambda (x) #t)) nil))

(test-case :find-first
   #1
   ((generic-param (lambda (x) #t)) (cons #1 (cons #2 nil))))

; ⊳# (index-of) - Position of first matching element
(test-case :indexof-found
   #2
   ((⊳# #3) (cons #1 (cons #2 (cons #3 (cons #4 nil))))))

(test-case :indexof-first
   #0
   ((⊳# #1) (cons #1 (cons #2 (cons #3 nil)))))

(test-case :indexof-last
   #2
   ((⊳# #3) (cons #1 (cons #2 (cons #3 nil)))))

(test-case :indexof-not-found
   nil
   ((⊳# #99) (cons #1 (cons #2 (cons #3 nil)))))

(test-case :indexof-empty
   nil
   ((⊳# #1) nil))

; ============================================================================
; Sorting Tests
; ============================================================================

; ⊴ (sort) - Sort with comparison function (use wrapped primitives)
(test-case :sort-ascending
   (cons #1 (cons #2 (cons #3 (cons #4 nil))))
   ((⊴ <′) (cons #3 (cons #1 (cons #4 (cons #2 nil))))))

(test-case :sort-descending
   (cons #4 (cons #3 (cons #2 (cons #1 nil))))
   ((⊴ >′) (cons #3 (cons #1 (cons #4 (cons #2 nil))))))

(test-case :sort-already-sorted
   (cons #1 (cons #2 (cons #3 nil)))
   ((⊴ <′) (cons #1 (cons #2 (cons #3 nil)))))

(test-case :sort-single
   (cons #1 nil)
   ((⊴ <′) (cons #1 nil)))

(test-case :sort-empty
   nil
   ((⊴ <′) nil))

(test-case :sort-duplicates
   (cons #1 (cons #1 (cons #2 (cons #3 (cons #3 nil)))))
   ((⊴ <′) (cons #3 (cons #1 (cons #2 (cons #3 (cons #1 nil)))))))

; ⊴< (sort-by) - Sort by key function
(test-case :sortby-modulo
   (cons #3 (cons #1 (cons #4 (cons #2 nil))))
   ((⊴< (lambda (x) (% x #3))) (cons #1 (cons #2 (cons #3 (cons #4 nil))))))

(test-case :sortby-identity
   (cons #1 (cons #2 (cons #3 nil)))
   ((⊴< (lambda (x) x)) (cons #3 (cons #1 (cons #2 nil)))))

(test-case :sortby-empty
   nil
   ((⊴< (lambda (x) x)) nil))

; ============================================================================
; Real-World Examples
; ============================================================================

; CSV-like data processing
(test-case :realworld-csv
   (cons (cons #25 (cons #30 nil)) (cons #20 nil))
   ((lambda (data) ((lambda (partitioned)
     (cons ((list-map (lambda (row) (cdr row))) (car partitioned))
         ((list-map (lambda (row) (cdr row))) (cdr partitioned))))
    ((⊠ (lambda (row) (> (car row) #25))) data)))
   (cons (cons #30 #25) (cons (cons #20 #20) (cons (cons #35 #30) nil)))))

; Matrix operations - DISABLED: transpose doesn't work on pairs
; TODO: Fix this test or implement proper matrix transpose for pairs
; (test-case :realworld-matrix
;    (cons #14 (cons #32 nil))
;    ((lambda (m1) ((lambda (m2) ((lambda (transposed)
;      ((list-map (lambda (row) (((fold-left +) #0) row))) transposed))
;     (⊤⊥ ((⊼ m2) m1))))
;    (cons #5 (cons #6 nil))))
;    (cons #9 (cons #26 nil))))

; Data analysis pipeline
(test-case :realworld-pipeline
   (cons #2 (cons #4 (cons #6 nil)))
   ((lambda (numbers)
     ((lambda (deduped) ((lambda (sorted)
       ((list-filter (lambda (x) (equal? (% x #2) #0))) sorted))
      ((⊴ <′) deduped)))
     (∪ numbers)))
   (cons #3 (cons #1 (cons #4 (cons #1 (cons #5 (cons #9 (cons #2 (cons #6 nil))))))))))

(print "All advanced list tests passed! ✨")
