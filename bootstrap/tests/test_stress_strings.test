;;; Stress: String Operations
;;; Tier 1 â€” String manipulation at scale

;;; --- 1. Build 10,000-char string via concatenation loop ---

(define build-str (lambda (n acc)
  (if (equal? n #0) acc
     (build-str (- n #1) (string-append acc "abcdefghij")))))

(define big-str (build-str #10000 ""))

(test-case :str-build-len #100000 (string-length big-str))

;;; --- 2. Reverse string, double-reverse equals original ---

(define short-str (build-str #100 ""))
(define reversed (string-reverse short-str))
(define double-rev (string-reverse reversed))

(test-case :str-double-reverse #t (equal? short-str double-rev))

;;; --- 3. Contains search in large string ---

(define haystack (build-str #1000 ""))

(define search-loop (lambda (n acc)
  (if (equal? n #0) acc
     (search-loop (- n #1)
       (+ acc (if (string-contains? haystack "efghij") #1 #0))))))

(test-case :str-contains-1k #1000 (search-loop #1000 #0))

;;; --- 4. String repeat and verify length ---

(define repeated (string-repeat "X" #50000))
(test-case :str-repeat-50k #50000 (string-length repeated))

;;; --- 5. Concatenation loop building string char by char ---

(define char-build (lambda (n acc)
  (if (equal? n #0) acc
     (char-build (- n #1) (string-append acc "a")))))

(define char-str (char-build #5000 ""))
(test-case :str-char-build-5k #5000 (string-length char-str))

;;; --- 6. String split on large string ---

(define split-str (build-str #1000 ""))
;; "abcdefghij" repeated 1000 times = 10000 chars
;; Split on "f" â€” appears every 10 chars

(define parts (string-split split-str "f"))

;; Count parts
(define count-parts (lambda (lst n)
  (if (null? lst) n
     (count-parts (cdr lst) (+ n #1)))))

(test-case :str-split-parts-positive #t (> (count-parts parts #0) #0))

;;; --- 7. String comparison loop ---

(define cmp-loop (lambda (n acc)
  (if (equal? n #0) acc
     (cmp-loop (- n #1)
       (+ acc (if (equal? "hello" "hello") #1 #0))))))

(test-case :str-cmp-10k #10000 (cmp-loop #10000 #0))

;;; --- 8. Number-to-string conversion loop ---

(define num-str-loop (lambda (n acc)
  (if (equal? n #0) acc
     (num-str-loop (- n #1)
       (+ acc (string-length (string n)))))))

;; Each number converted to string; just verify it completes and sum > 0
(define num-str-result (num-str-loop #10000 #0))
(test-case :str-num-convert-10k #t (> num-str-result #0))
