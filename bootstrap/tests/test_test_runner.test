;;; Day 123: First-Class Test Runner — Trie-Backed Registry
;;; Tests: Result accumulation, counting, reset, trie registration,
;;;        registry runner, HashMap results, SortedMap timing,
;;;        tag filtering, iterator pipelines.
;;; Uses assert (assert) for state checks to avoid polluting test runner state.

;;; ═══════════════════════════════════════════
;;; Section 1: Result Accumulation via test-case
;;; ═══════════════════════════════════════════

(test-reset)

;; Run a passing test — test-case stores result
(test-case (quote :accum:pass1) #1 #1)

;; Use assert to check state without polluting results
(assert (pair? (test-results)) :accum-results-exist)

;; Head of results is a HashMap
(assert (hashmap? (car (test-results))) :accum-result-is-hashmap)

;; Result has correct :name
(assert (equal? (hashmap-get (car (test-results)) :name) :accum:pass1) :accum-result-has-name)

;; Result has :status :pass
(assert (equal? (hashmap-get (car (test-results)) :status) :pass) :accum-result-status-pass)

;; :elapsed is a number
(assert (number? (hashmap-get (car (test-results)) :elapsed)) :accum-result-has-elapsed)

;;; ═══════════════════════════════════════════
;;; Section 2: Count Tracking via test-count
;;; ═══════════════════════════════════════════

(test-reset)
(test-case (quote :count:test1) #1 #1)
(test-case (quote :count:test2) #2 #2)
(test-case (quote :count:test3) #3 #3)

(define counts (test-count))
(assert (equal? (car counts) #3) :count-pass-is-3)
(assert (equal? (car (cdr counts)) #0) :count-fail-is-0)
(assert (equal? (car (cdr (cdr counts))) #3) :count-total-is-3)

;;; ═══════════════════════════════════════════
;;; Section 3: Reset via test-reset
;;; ═══════════════════════════════════════════

(test-reset)
(define counts-after-reset (test-count))

(assert (equal? (car counts-after-reset) #0) :reset-pass-zero)
(assert (equal? (car (cdr counts-after-reset)) #0) :reset-fail-zero)
(assert (equal? (car (cdr (cdr counts-after-reset))) #0) :reset-total-zero)
(assert (null? (test-results)) :reset-results-nil)

;;; ═══════════════════════════════════════════
;;; Section 4: Trie Registration via test-register
;;; ═══════════════════════════════════════════

(test-reset)

;; Register tests
(assert (test-register :math:add:basic (lambda () (test-case (quote :math:add:basic) #5 (+ #2 #3)))) :reg-returns-true)
(test-register :math:add:zero (lambda () (test-case (quote :math:add:zero) #0 (+ #0 #0))))
(assert (test-register :math:mul:basic (lambda () (test-case (quote :math:mul:basic) #6 (* #2 #3))) :fast :pure) :reg-with-tags)
(test-register :string:concat (lambda () (test-case (quote :string:concat) "ab" (string-append "a" "b"))))

;;; ═══════════════════════════════════════════
;;; Section 5: Run Registry via test-run-registry
;;; ═══════════════════════════════════════════

(test-reset)
(define all-results (test-run-registry))

(assert (hashmap? all-results) :run-result-is-hashmap)
(assert (equal? (hashmap-get all-results :total) #4) :run-total-count)
(assert (equal? (hashmap-get all-results :passed) #4) :run-all-passed)
(assert (equal? (hashmap-get all-results :failed) #0) :run-zero-failures)
(assert (number? (hashmap-get all-results :elapsed)) :run-elapsed-is-number)

;;; ═══════════════════════════════════════════
;;; Section 6: Prefix Filtering via test-run-registry
;;; ═══════════════════════════════════════════

(test-reset)
(define math-results (test-run-registry :math))

(assert (equal? (hashmap-get math-results :total) #3) :prefix-math-total)
(assert (equal? (hashmap-get math-results :passed) #3) :prefix-math-all-passed)

(test-reset)
(define str-results (test-run-registry :string))
(assert (equal? (hashmap-get str-results :total) #1) :prefix-string-total)

;;; ═══════════════════════════════════════════
;;; Section 7: Results are HashMaps
;;; ═══════════════════════════════════════════

(define result-list (hashmap-get math-results :results))

(assert (pair? result-list) :hashmap-results-is-list)
(assert (hashmap? (car result-list)) :hashmap-first-is-hashmap)

(define first-result (car result-list))
(assert (hashmap-has? first-result :name) :hashmap-has-name)
(assert (hashmap-has? first-result :status) :hashmap-has-status)
(assert (hashmap-has? first-result :elapsed) :hashmap-has-elapsed)
(assert (equal? (hashmap-get first-result :status) :pass) :hashmap-status-is-pass)

;;; ═══════════════════════════════════════════
;;; Section 8: Timing is SortedMap
;;; ═══════════════════════════════════════════

(define timing (hashmap-get math-results :timing))

(assert (sorted-map? timing) :timing-is-sorted-map)
(assert (> (sorted-map-size timing) #0) :timing-has-entries)

(define slowest (sorted-map-max timing))
(assert (pair? slowest) :timing-slowest-is-pair)
(assert (number? (car slowest)) :timing-slowest-key-is-number)

;;; ═══════════════════════════════════════════
;;; Section 9: Iterator Pipeline on Results
;;; ═══════════════════════════════════════════

(define results-iter (iter (hashmap-get math-results :results)))
(assert (iter? results-iter) :iter-is-iterator)

;; Filter for :pass status
(define pass-iter (iter-filter results-iter (lambda (r) (equal? (hashmap-get r :status) :pass))))
(assert (iter? pass-iter) :iter-filter-is-iterator)

;; Collect filtered results
(define pass-list (iter-collect pass-iter))
(assert (pair? pass-list) :iter-collected-is-list)

;; Map to extract names
(define name-iter (iter-map (iter (hashmap-get math-results :results)) (lambda (r) (hashmap-get r :name))))
(define name-list (iter-collect name-iter))
(assert (pair? name-list) :iter-map-extracts-names)
(assert (symbol? (car name-list)) :iter-names-are-symbols)

;;; ═══════════════════════════════════════════
;;; Section 10: Tag Filtering
;;; ═══════════════════════════════════════════

(test-register :tagged:fast-test (lambda () (test-case (quote :tagged:fast-test) #1 #1)) :fast)
(test-register :tagged:slow-test (lambda () (test-case (quote :tagged:slow-test) #2 #2)) :slow)
(test-register :tagged:fast-pure (lambda () (test-case (quote :tagged:fast-pure) #3 #3)) :fast :pure)

;; Run :tagged with tag :fast
(test-reset)
(define fast-results (test-run-registry :tagged :fast))
(assert (equal? (hashmap-get fast-results :total) #2) :tag-fast-count)

;; Run :tagged with tag :slow
(test-reset)
(define slow-results (test-run-registry :tagged :slow))
(assert (equal? (hashmap-get slow-results :total) #1) :tag-slow-count)

;; Run :tagged with tag :pure
(test-reset)
(define pure-results (test-run-registry :tagged :pure))
(assert (equal? (hashmap-get pure-results :total) #1) :tag-pure-count)

;;; ═══════════════════════════════════════════
;;; Section 11: Failing Test Results
;;; ═══════════════════════════════════════════

;; Register a test that returns an error (simulates failure without printing ✗ FAIL)
(test-register :fail:intentional (lambda () (error :intentional-fail #0)))

(test-reset)
(define fail-results (test-run-registry :fail))

(assert (equal? (hashmap-get fail-results :failed) #1) :fail-has-failure)
(assert (pair? (hashmap-get fail-results :failures)) :fail-failures-list)
(assert (equal? (hashmap-get (car (hashmap-get fail-results :failures)) :status) :fail) :fail-failure-status)

;;; ═══════════════════════════════════════════
;;; Section 12: Multiple Resets are Idempotent
;;; ═══════════════════════════════════════════

(test-reset)
(test-reset)
(test-reset)

(assert (null? (test-results)) :reset-triple-ok)
(define triple-counts (test-count))
(assert (equal? (car triple-counts) #0) :reset-triple-pass-zero)
