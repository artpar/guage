;;;
;;; Tests for Environment Module (eval-env.scm)
;;;

(load "bootstrap/stdlib/eval-env.scm")

;;; Test 1: Empty environment
(test-case :env-empty-is-nil
   nil
   (env-empty))

;;; Test 2: Extend environment with single binding
(define env1 (((env-extend (env-empty)) :x) #42))
(test-case :env-extend-single
   #42
   ((env-lookup env1) :x))

;;; Test 3: Extend environment with multiple bindings
(define env2 (((env-extend env1) :y) #100))
(test-case :env-extend-multiple-first
   #42
   ((env-lookup env2) :x))
(test-case :env-extend-multiple-second
   #100
   ((env-lookup env2) :y))

;;; Test 4: Lookup undefined variable returns error
(define result-undefined ((env-lookup env1) :undefined))
(test-case :env-lookup-undefined-is-error
   #t
   (error? result-undefined))

;;; Test 5: Shadowing - newer binding takes precedence
(define env3 (((env-extend env1) :x) #999))
(test-case :env-shadowing
   #999
   ((env-lookup env3) :x))

;;; Test 6: env-has? returns true for bound symbols
(test-case :env-has-true
   #t
   ((env-has? env1) :x))

;;; Test 7: env-has? returns false for unbound symbols
(test-case :env-has-false
   #f
   ((env-has? env1) :undefined))

;;; Test 8: env-from-list creates environment from bindings
(define bindings (cons (cons :a #1) (cons (cons :b #2) (cons (cons :c #3) nil))))
(define env4 (env-from-list bindings))
(test-case :env-from-list-a
   #1
   ((env-lookup env4) :a))
(test-case :env-from-list-b
   #2
   ((env-lookup env4) :b))
(test-case :env-from-list-c
   #3
   ((env-lookup env4) :c))

;;; Test 9: Chained lookups work correctly
(define env-chain
  (((env-extend
    (((env-extend
      (((env-extend (env-empty)) :x) #1))
     :y) #2))
   :z) #3))
(test-case :env-chain-x #1 ((env-lookup env-chain) :x))
(test-case :env-chain-y #2 ((env-lookup env-chain) :y))
(test-case :env-chain-z #3 ((env-lookup env-chain) :z))
