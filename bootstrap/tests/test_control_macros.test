; ═══════════════════════════════════════════════════════════════
; Test Suite: Control Flow Macros (Day 77)
; ═══════════════════════════════════════════════════════════════
; Tests for short-circuit logical operators and control flow macros
; - ∧* (and*) - short-circuit AND
; - ∨* (or*) - short-circuit OR
; - ⇒ (when) - conditional execution
; - ⇏ (unless) - negative conditional
; ═══════════════════════════════════════════════════════════════

; Load the control macros
(load "bootstrap/stdlib/macros_control.scm")

; ═══════════════════════════════════════════════════════════════
; ∧* (short-circuit AND) tests
; ═══════════════════════════════════════════════════════════════

; Basic two-arg AND
(test-case (quote :and*-tt) #t (∧* #t #t))
(test-case (quote :and*-tf) #f (∧* #t #f))
(test-case (quote :and*-ft) #f (∧* #f #t))
(test-case (quote :and*-ff) #f (∧* #f #f))

; Three-arg AND
(test-case (quote :and*-ttt) #t (∧* #t #t #t))
(test-case (quote :and*-ttf) #f (∧* #t #t #f))
(test-case (quote :and*-tft) #f (∧* #t #f #t))
(test-case (quote :and*-ftt) #f (∧* #f #t #t))

; Four-arg AND
(test-case (quote :and*-4-all-true) #t (∧* #t #t #t #t))
(test-case (quote :and*-4-last-false) #f (∧* #t #t #t #f))

; Single-arg AND (identity)
(test-case (quote :and*-single-t) #t (∧* #t))
(test-case (quote :and*-single-f) #f (∧* #f))

; AND returns last value if all truthy (Lisp semantics)
(test-case (quote :and*-returns-last) #42 (∧* #t #t #42))
(test-case (quote :and*-returns-value) :done (∧* #t :done))

; AND short-circuits - doesn't evaluate after false
; We use a side-effect-free test: if short-circuit works,
; the error won't be evaluated
(test-case (quote :and*-shortcircuit) #f (∧* #f (/ #1 #0)))

; ═══════════════════════════════════════════════════════════════
; ∨* (short-circuit OR) tests
; ═══════════════════════════════════════════════════════════════

; Basic two-arg OR
(test-case (quote :or*-tt) #t (∨* #t #t))
(test-case (quote :or*-tf) #t (∨* #t #f))
(test-case (quote :or*-ft) #t (∨* #f #t))
(test-case (quote :or*-ff) #f (∨* #f #f))

; Three-arg OR
(test-case (quote :or*-fff) #f (∨* #f #f #f))
(test-case (quote :or*-fft) #t (∨* #f #f #t))
(test-case (quote :or*-ftf) #t (∨* #f #t #f))
(test-case (quote :or*-tff) #t (∨* #t #f #f))

; Four-arg OR
(test-case (quote :or*-4-all-false) #f (∨* #f #f #f #f))
(test-case (quote :or*-4-first-true) #t (∨* #t #f #f #f))

; Single-arg OR (identity)
(test-case (quote :or*-single-t) #t (∨* #t))
(test-case (quote :or*-single-f) #f (∨* #f))

; OR returns first truthy value (Lisp semantics)
(test-case (quote :or*-returns-first-truthy) #42 (∨* #f #42 #99))
(test-case (quote :or*-returns-value) :found (∨* #f :found))

; OR short-circuits - doesn't evaluate after true
(test-case (quote :or*-shortcircuit) #t (∨* #t (/ #1 #0)))

; ═══════════════════════════════════════════════════════════════
; ⇒ (when) tests - execute body if condition true
; ═══════════════════════════════════════════════════════════════

; When with true condition - returns body result
(test-case (quote :when-true-simple) :yes (⇒ #t :yes))
(test-case (quote :when-true-expr) #42 (⇒ (equal? #1 #1) (+ #40 #2)))

; When with false condition - returns nil
(test-case (quote :when-false) nil (⇒ #f :never))
(test-case (quote :when-false-expr) nil (⇒ (equal? #1 #2) :never))

; When doesn't evaluate body on false
(test-case (quote :when-short-circuit) nil (⇒ #f (/ #1 #0)))

; When with complex condition
(test-case (quote :when-complex-cond) :big (⇒ (> #10 #5) :big))

; ═══════════════════════════════════════════════════════════════
; ⇏ (unless) tests - execute body if condition false
; ═══════════════════════════════════════════════════════════════

; Unless with false condition - returns body result
(test-case (quote :unless-false-simple) :yes (⇏ #f :yes))
(test-case (quote :unless-false-expr) #42 (⇏ (equal? #1 #2) (+ #40 #2)))

; Unless with true condition - returns nil
(test-case (quote :unless-true) nil (⇏ #t :never))
(test-case (quote :unless-true-expr) nil (⇏ (equal? #1 #1) :never))

; Unless doesn't evaluate body on true
(test-case (quote :unless-short-circuit) nil (⇏ #t (/ #1 #0)))

; Unless with complex condition
(test-case (quote :unless-complex-cond) :small (⇏ (> #5 #10) :small))

; ═══════════════════════════════════════════════════════════════
; Combined usage tests
; ═══════════════════════════════════════════════════════════════

; Nested control flow
(test-case (quote :nested-when-and) :both
   (⇒ (∧* #t #t) :both))

(test-case (quote :nested-unless-or) :none
   (⇏ (∨* #f #f) :none))

; And/or with when/unless
(define check-range (lambda (x)
  (⇒ (∧* (> x #0) (< x #100))
      :in-range)))

(test-case (quote :combined-in-range) :in-range (check-range #50))
(test-case (quote :combined-out-range) nil (check-range #150))

; ═══════════════════════════════════════════════════════════════
"✓ Control macros test suite complete"
