;; Test Suite: As-Patterns for Pattern Matching (Day 59)
;; As-patterns bind both the whole value AND its parts
;; Syntax: name@pattern
;; Example: pair@(cons a b) binds pair, a, and b

;; ============================================================================
;; Basic As-Patterns
;; ============================================================================

;; Test 1: As-pattern with literal
;; Pattern: x@#42
;; Value: #42
;; Expected: Binds x -> #42, returns x which is #42
(test-case :as-literal
    #42
    (match #42 (quote (((x @ #42) x)))))

;; Test 2: As-pattern with pair
;; Pattern: pair@(cons a b)
;; Value: ⟨#1 #2⟩
;; Expected: Binds pair -> ⟨#1 #2⟩, a -> #1, b -> #2
;; Result: Return the whole pair
(test-case :as-pair-whole
    (cons #1 #2)
    (match (cons #1 #2) (quote (((pair @ (cons a b)) pair)))))

;; Test 3: As-pattern with pair - access parts
;; Pattern: pair@(cons a b)
;; Value: ⟨#1 #2⟩
;; Expected: Binds pair -> ⟨#1 #2⟩, a -> #1, b -> #2
;; Result: Return first element
(test-case :as-pair-part
    #1
    (match (cons #1 #2) (quote (((pair @ (cons a b)) a)))))

;; Test 4: As-pattern with pair - use all bindings
;; Pattern: pair@(cons a b)
;; Value: ⟨#3 #4⟩
;; Expected: Binds pair -> ⟨#3 #4⟩, a -> #3, b -> #4
;; Result: Return ⟨pair a b⟩
(test-case :as-pair-all-bindings
    (cons (cons #3 #4) (cons #3 #4))
    (match (cons #3 #4) (quote (((pair @ (cons a b)) (cons pair (cons a b)))))))

;; Test 5: As-pattern with variable
;; Pattern: whole@x
;; Value: #99
;; Expected: Binds whole -> #99, x -> #99
(test-case :as-variable
    (cons #99 #99)
    (match #99 (quote (((whole @ x) (cons whole x))))))

;; ============================================================================
;; Nested As-Patterns
;; ============================================================================

;; Test 6: Nested as-patterns - double nesting
;; Pattern: outer@(inner@(cons a b))
;; Value: ⟨#5 #6⟩
;; Expected: outer -> ⟨#5 #6⟩, inner -> ⟨#5 #6⟩, a -> #5, b -> #6
(test-case :nested-as-double
    (cons (cons #5 #6) (cons (cons #5 #6) (cons #5 #6)))
    (match (cons #5 #6) (quote (((outer @ (inner @ (cons a b))) (cons outer (cons inner (cons a b))))))))

;; Test 7: As-pattern on nested pair structure
;; Pattern: lst@(cons h (t@(cons h2 t2)))
;; Value: ⟨#1 ⟨#2 #3⟩⟩
;; Expected: lst -> ⟨#1 ⟨#2 #3⟩⟩, h -> #1, t -> ⟨#2 #3⟩, h2 -> #2, t2 -> #3
(test-case :nested-as-structure
    (cons (cons #1 (cons #2 #3)) (cons #2 #3))
    (match (cons #1 (cons #2 #3)) (quote (((lst @ (cons h (t @ (cons h2 t2)))) (cons lst t))))))

;; ============================================================================
;; As-Patterns with Lists
;; ============================================================================

;; Test 8: As-pattern with single-element list
;; Pattern: lst@(cons x nil)
;; Value: ⟨#42 ∅⟩
;; Expected: lst -> ⟨#42 ∅⟩, x -> #42
(test-case :as-singleton-list
    (cons (cons #42 nil) #42)
    (match (cons #42 nil) (quote (((lst @ (cons x nil)) (cons lst x))))))

;; Test 9: As-pattern with two-element list
;; Pattern: lst@(cons a (cons b nil))
;; Value: ⟨#10 ⟨#20 ∅⟩⟩
;; Expected: lst -> ⟨#10 ⟨#20 ∅⟩⟩, a -> #10, b -> #20
(test-case :as-two-element-list
    (cons (cons #10 (cons #20 nil)) (cons #10 #20))
    (match (cons #10 (cons #20 nil)) (quote (((lst @ (cons a (cons b nil))) (cons lst (cons a b)))))))

;; ============================================================================
;; As-Patterns with Structures (ADTs)
;; ============================================================================

;; Define Option ADT for tests
(adt-define :Option (quote (:None)) (quote (:Some :value)))

;; Test 10: As-pattern with ADT - Some variant
;; Pattern: opt@(adt-create :Option :Some v)
;; Value: ⊚[:Option :Some #100]
;; Expected: opt -> whole value, v -> #100
(test-case :as-adt-some
    #100
    (match (adt-create :Option :Some #100) (quote (((opt @ (adt-create :Option :Some v)) v)))))

;; Test 11: As-pattern with ADT - return whole and part
;; Pattern: opt@(adt-create :Option :Some v)
;; Value: ⊚[:Option :Some #50]
;; Expected: opt -> whole value, v -> #50
;; Result: ⟨opt v⟩
(test-case :as-adt-whole-and-part
    #t
    (match (adt-create :Option :Some #50) (quote (((opt @ (adt-create :Option :Some v))
                                   (and (adt? opt :Option :Some) (equal? v #50)))))))

;; Define Result ADT for tests
(adt-define :Result (quote (:Ok :value)) (quote (:Err :error)))

;; Test 12: As-pattern with Result.Ok
;; Pattern: res@(adt-create :Result :Ok val)
;; Value: ⊚[:Result :Ok #42]
;; Expected: res -> whole value, val -> #42
(test-case :as-result-ok
    (cons #t #42)
    (match (adt-create :Result :Ok #42) (quote (((res @ (adt-create :Result :Ok val))
                                (cons (adt? res :Result :Ok) val))))))

;; Test 13: As-pattern with Result.Err
;; Pattern: res@(adt-create :Result :Err e)
;; Value: ⊚[:Result :Err :failure]
;; Expected: res -> whole value, e -> :failure
(test-case :as-result-err
    :failure
    (match (adt-create :Result :Err :failure) (quote (((res @ (adt-create :Result :Err e)) e)))))

;; ============================================================================
;; As-Patterns with Leaf Structures
;; ============================================================================

;; Define Point structure for tests
(struct-define :Point :x :y)

;; Test 14: As-pattern with leaf structure
;; Pattern: pt@(struct-create :Point x y)
;; Value: ⊙[:Point #3 #4]
;; Expected: pt -> whole point, x -> #3, y -> #4
(test-case :as-leaf-structure
    (cons #t (cons #3 #4))
    (match (struct-create :Point #3 #4) (quote (((pt @ (struct-create :Point x y))
                             (cons (struct? pt :Point) (cons x y)))))))

;; ============================================================================
;; As-Patterns with Multiple Clauses
;; ============================================================================

;; Test 15: As-patterns in multiple clauses
;; Pattern matching with fallback
(test-case :as-multiple-clauses-first
    :matched-some
    (match (adt-create :Option :Some #42) (quote (((opt @ (adt-create :Option :Some v)) :matched-some)
                                  ((opt @ (adt-create :Option :None)) :matched-none)))))

(test-case :as-multiple-clauses-second
    :matched-none
    (match (adt-create :Option :None) (quote (((opt @ (adt-create :Option :Some v)) :matched-some)
                             ((opt @ (adt-create :Option :None)) :matched-none)))))

;; ============================================================================
;; As-Patterns with Guards (Combination)
;; ============================================================================

;; Test 16: As-pattern combined with guard condition
;; Pattern: (pair@(cons a b) | (> a #0))
;; Tests that a > 0, returns pair if true
(test-case :as-with-guard-pass
    (cons #5 #10)
    (match (cons #5 #10) (quote ((((pair @ (cons a b)) | (> a #0)) pair)
                       (_ :failed)))))

(test-case :as-with-guard-fail
    :failed
    (match (cons #-5 #10) (quote ((((pair @ (cons a b)) | (> a #0)) pair)
                        (_ :failed)))))

;; Test 17: As-pattern with complex guard - sum check
;; Pattern: (pair@(cons a b) | (equal? (+ a b) #10))
;; Tests that a + b = 10
(test-case :as-guard-sum-check-pass
    (cons #3 #7)
    (match (cons #3 #7) (quote ((((pair @ (cons a b)) | (equal? (+ a b) #10)) pair)
                      (_ :failed)))))

(test-case :as-guard-sum-check-fail
    :failed
    (match (cons #3 #8) (quote ((((pair @ (cons a b)) | (equal? (+ a b) #10)) pair)
                      (_ :failed)))))

;; ============================================================================
;; Edge Cases
;; ============================================================================

;; Test 18: As-pattern with wildcard subpattern
;; Pattern: x@_
;; Value: #42
;; Expected: x -> #42
(test-case :as-wildcard
    #42
    (match #42 (quote (((x @ _) x)))))

;; Test 19: As-pattern with nil
;; Pattern: empty@∅
;; Value: nil
;; Expected: empty -> nil
(test-case :as-nil
    #t
    (match nil (quote (((empty @ nil) (null? empty))))))

;; Test 20: As-pattern match failure
;; Pattern: pair@(cons a b)
;; Value: #42 (not a pair)
;; Expected: No match, fallback to wildcard
(test-case :as-match-failure
    :not-matched
    (match #42 (quote (((pair @ (cons a b)) :matched)
               (_ :not-matched)))))

;; Test 21: As-pattern with boolean
;; Pattern: flag@#t
;; Value: #t
;; Expected: flag -> #t
(test-case :as-boolean
    #t
    (match #t (quote (((flag @ #t) flag)))))

;; Test 22: As-pattern with symbol
;; Pattern: sym@:hello
;; Value: :hello
;; Expected: sym -> :hello
(test-case :as-symbol
    :hello
    (match :hello (quote (((sym @ :hello) sym)))))

;; ============================================================================
;; Real-World Examples
;; ============================================================================

;; Test 23: Clone a list node with as-pattern
;; Returns both the head and the original node
(test-case :realworld-clone-node
    (cons #42 (cons #42 (cons #99 nil)))
    (match (cons #42 (cons #99 nil)) (quote (((node @ (cons h t)) (cons h node))))))

;; Test 24: Validate and extract from Result with as-pattern
;; Use the whole Result value and its inner value
(test-case :realworld-result-validation
    :valid
    (match (adt-create :Result :Ok #100) (quote ((((res @ (adt-create :Result :Ok v)) | (> v #50)) :valid)
                                 ((res @ (adt-create :Result :Ok v)) :invalid)
                                 ((res @ (adt-create :Result :Err e)) :error)))))

;; Test 25: Nested structure extraction with multiple as-patterns
;; Extract multiple levels with as-patterns for clarity
(test-case :realworld-nested-extraction
    (cons (cons (cons #1 (cons #2 #3)) (cons #2 #3)) #1)
    (match (cons #1 (cons #2 #3))
       (quote (((outer @ (cons h (inner @ (cons h2 t2)))) (cons (cons outer inner) h))))))
