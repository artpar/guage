;;;
;;; Deep Integration: HashMap + Vector + Closures + Recursion + Box + Pattern Matching
;;;

;;; --- Build HashMap imperatively from list of pairs ---

(define m1 (hashmap (cons :a #1) (cons :b #2) (cons :c #3)))

(test-case :map-from-list-size #3 (hashmap-size m1))
(test-case :map-from-list-a    #1 (hashmap-get m1 :a))
(test-case :map-from-list-c    #3 (hashmap-get m1 :c))

;;; --- Vector as stack: push 3, pop 3 in LIFO order ---

(define v1 (vector))
(vector-push! v1 #10)
(vector-push! v1 #20)
(vector-push! v1 #30)

(test-case :vec-stack-size #3 (vector-length v1))
(define p3 (vector-pop! v1))
(define p2 (vector-pop! v1))
(define p1 (vector-pop! v1))
(test-case :vec-lifo-order (cons #30 (cons #20 (cons #10 nil)))
  (cons p3 (cons p2 (cons p1 nil))))

;;; --- Box containing HashMap for mutable key-value store ---

(define store-map (hashmap))
(define store (box store-map))
(hashmap-put (unbox store) :x #10)
(hashmap-put (unbox store) :y #20)

(test-case :box-map-x #10 (hashmap-get (unbox store) :x))
(test-case :box-map-y #20 (hashmap-get (unbox store) :y))

;;; --- Count occurrences in list -> HashMap of frequencies ---

(define freq-map (hashmap))
(define freq-loop (lambda (l)
  (if (null? l) freq-map
     (begin
       (define fk (car l))
       (define fold (hashmap-get freq-map fk))
       (hashmap-put freq-map fk (if (null? fold) #1 (+ fold #1)))
       (freq-loop (cdr l))))))

(freq-loop (cons :a (cons :b (cons :a (cons :c (cons :a (cons :b nil)))))))

(test-case :freq-a #3 (hashmap-get freq-map :a))
(test-case :freq-b #2 (hashmap-get freq-map :b))
(test-case :freq-c #1 (hashmap-get freq-map :c))

;;; --- Vector collects range of numbers ---

(define vr (vector))
(define range-loop (lambda (i n)
  (if (> i n) vr
     (begin (vector-push! vr i) (range-loop (+ i #1) n)))))

(range-loop #1 #5)

(test-case :vec-range-size  #5 (vector-length vr))
(test-case :vec-range-first #1 (vector-ref vr #0))
(test-case :vec-range-last  #5 (vector-ref vr #4))

;;; --- HashMap lookup with nil-check fallback ---

(define get-or-default (lambda (m key default)
  (begin
    (define gov (hashmap-get m key))
    (if (null? gov) default gov))))

(define m2 (hashmap))
(hashmap-put m2 :name "alice")

(test-case :get-found   "alice"   (get-or-default m2 :name "unknown"))
(test-case :get-missing "unknown" (get-or-default m2 :age "unknown"))

;;; --- Recursive list-to-vector conversion ---

(define l2v (vector))
(define list-to-vec (lambda (lst)
  (if (null? lst) l2v
     (begin (vector-push! l2v (car lst)) (list-to-vec (cdr lst))))))

(list-to-vec (cons #100 (cons #200 (cons #300 nil))))

(test-case :list-to-vec-size #3 (vector-length l2v))
(test-case :list-to-vec-0 #100 (vector-ref l2v #0))
(test-case :list-to-vec-2 #300 (vector-ref l2v #2))
