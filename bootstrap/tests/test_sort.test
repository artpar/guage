; ═══════════════════════════════════════════════════════════════
; Guage Standard Library Tests: Sorting Algorithms
; ═══════════════════════════════════════════════════════════════

; Load sorting library
(load "bootstrap/stdlib/sort.scm")

; ────────────────────────────────────────────────────────────────
; HELPER: List equality
; ────────────────────────────────────────────────────────────────

(define list-equal? (lambda (lst1) (lambda (lst2)
  (if (null? lst1)
     (null? lst2)
     (if (null? lst2)
        #f
        (if (equal? (car lst1) (car lst2))
           ((list-equal? (cdr lst1)) (cdr lst2))
           #f))))))

; ────────────────────────────────────────────────────────────────
; TEST DATA
; ────────────────────────────────────────────────────────────────

(define empty-list nil)
(define single-list (cons #5 nil))
(define sorted-list (cons #1 (cons #2 (cons #3 (cons #4 (cons #5 nil))))))
(define reverse-list (cons #5 (cons #4 (cons #3 (cons #2 (cons #1 nil))))))
(define random-list (cons #3 (cons #1 (cons #4 (cons #1 (cons #5 (cons #9 nil)))))))
(define duplicates-list (cons #3 (cons #3 (cons #1 (cons #1 (cons #2 (cons #2 nil)))))))

; ────────────────────────────────────────────────────────────────
; UTILITY TESTS
; ────────────────────────────────────────────────────────────────

; Test is-sorted on empty list
(test-case :is-sorted-empty
   #t
   (⊙⊢ empty-list))

; Test is-sorted on single element
(test-case :is-sorted-single
   #t
   (⊙⊢ single-list))

; Test is-sorted on sorted list
(test-case :is-sorted-sorted
   #t
   (⊙⊢ sorted-list))

; Test is-sorted on reverse list
(test-case :is-sorted-reverse
   #f
   (⊙⊢ reverse-list))

; Test is-sorted on random list
(test-case :is-sorted-random
   #f
   (⊙⊢ random-list))

; Test is-sorted with custom comparator (descending)
(test-case :is-sorted-desc
   #t
   ((⊙⊢→ ⊙≥) reverse-list))

; ────────────────────────────────────────────────────────────────
; BUBBLE SORT TESTS
; ────────────────────────────────────────────────────────────────

; Bubble sort: empty list
(test-case :bubble-empty
   #t
   ((list-equal? empty-list) (⊙bubble empty-list)))

; Bubble sort: single element
(test-case :bubble-single
   #t
   ((list-equal? single-list) (⊙bubble single-list)))

; Bubble sort: already sorted
(test-case :bubble-sorted
   #t
   ((list-equal? sorted-list) (⊙bubble sorted-list)))

; Bubble sort: reverse sorted
(test-case :bubble-reverse
   #t
   ((list-equal? sorted-list) (⊙bubble reverse-list)))

; Bubble sort: random list
(test-case :bubble-random
   #t
   ((list-equal? (cons #1 (cons #1 (cons #3 (cons #4 (cons #5 (cons #9 nil))))))) (⊙bubble random-list)))

; Bubble sort: with duplicates
(test-case :bubble-duplicates
   #t
   ((list-equal? (cons #1 (cons #1 (cons #2 (cons #2 (cons #3 (cons #3 nil))))))) (⊙bubble duplicates-list)))

; Bubble sort: descending
(test-case :bubble-desc
   #t
   ((list-equal? reverse-list) ((⊙bubble→ ⊙≥) sorted-list)))

; ────────────────────────────────────────────────────────────────
; INSERTION SORT TESTS
; ────────────────────────────────────────────────────────────────

; Insertion sort: empty list
(test-case :insertion-empty
   #t
   ((list-equal? empty-list) (⊙insertion empty-list)))

; Insertion sort: single element
(test-case :insertion-single
   #t
   ((list-equal? single-list) (⊙insertion single-list)))

; Insertion sort: already sorted
(test-case :insertion-sorted
   #t
   ((list-equal? sorted-list) (⊙insertion sorted-list)))

; Insertion sort: reverse sorted
(test-case :insertion-reverse
   #t
   ((list-equal? sorted-list) (⊙insertion reverse-list)))

; Insertion sort: random list
(test-case :insertion-random
   #t
   ((list-equal? (cons #1 (cons #1 (cons #3 (cons #4 (cons #5 (cons #9 nil))))))) (⊙insertion random-list)))

; Insertion sort: with duplicates
(test-case :insertion-duplicates
   #t
   ((list-equal? (cons #1 (cons #1 (cons #2 (cons #2 (cons #3 (cons #3 nil))))))) (⊙insertion duplicates-list)))

; Insertion sort: descending
(test-case :insertion-desc
   #t
   ((list-equal? reverse-list) ((⊙insertion→ ⊙≥) sorted-list)))

; ────────────────────────────────────────────────────────────────
; MERGE SORT TESTS
; ────────────────────────────────────────────────────────────────

; Merge sort: empty list
(test-case :merge-empty
   #t
   ((list-equal? empty-list) (⊙mergesort empty-list)))

; Merge sort: single element
(test-case :merge-single
   #t
   ((list-equal? single-list) (⊙mergesort single-list)))

; Merge sort: already sorted
(test-case :merge-sorted
   #t
   ((list-equal? sorted-list) (⊙mergesort sorted-list)))

; Merge sort: reverse sorted
(test-case :merge-reverse
   #t
   ((list-equal? sorted-list) (⊙mergesort reverse-list)))

; Merge sort: random list
(test-case :merge-random
   #t
   ((list-equal? (cons #1 (cons #1 (cons #3 (cons #4 (cons #5 (cons #9 nil))))))) (⊙mergesort random-list)))

; Merge sort: with duplicates
(test-case :merge-duplicates
   #t
   ((list-equal? (cons #1 (cons #1 (cons #2 (cons #2 (cons #3 (cons #3 nil))))))) (⊙mergesort duplicates-list)))

; Merge sort: descending
(test-case :merge-desc
   #t
   ((list-equal? reverse-list) ((⊙mergesort→ ⊙≥) sorted-list)))

; ────────────────────────────────────────────────────────────────
; QUICKSORT TESTS
; ────────────────────────────────────────────────────────────────

; Quicksort: empty list
(test-case :quick-empty
   #t
   ((list-equal? empty-list) (⊙quicksort empty-list)))

; Quicksort: single element
(test-case :quick-single
   #t
   ((list-equal? single-list) (⊙quicksort single-list)))

; Quicksort: already sorted
(test-case :quick-sorted
   #t
   ((list-equal? sorted-list) (⊙quicksort sorted-list)))

; Quicksort: reverse sorted
(test-case :quick-reverse
   #t
   ((list-equal? sorted-list) (⊙quicksort reverse-list)))

; Quicksort: random list
(test-case :quick-random
   #t
   ((list-equal? (cons #1 (cons #1 (cons #3 (cons #4 (cons #5 (cons #9 nil))))))) (⊙quicksort random-list)))

; Quicksort: with duplicates
(test-case :quick-duplicates
   #t
   ((list-equal? (cons #1 (cons #1 (cons #2 (cons #2 (cons #3 (cons #3 nil))))))) (⊙quicksort duplicates-list)))

; Quicksort: descending
(test-case :quick-desc
   #t
   ((list-equal? reverse-list) ((⊙quicksort→ ⊙≥) sorted-list)))

; ────────────────────────────────────────────────────────────────
; DEFAULT SORT TESTS
; ────────────────────────────────────────────────────────────────

; Default sort: empty list
(test-case :sort-empty
   #t
   ((list-equal? empty-list) (⊙sort empty-list)))

; Default sort: single element
(test-case :sort-single
   #t
   ((list-equal? single-list) (⊙sort single-list)))

; Default sort: already sorted
(test-case :sort-sorted
   #t
   ((list-equal? sorted-list) (⊙sort sorted-list)))

; Default sort: reverse sorted
(test-case :sort-reverse
   #t
   ((list-equal? sorted-list) (⊙sort reverse-list)))

; Default sort: random list
(test-case :sort-random
   #t
   ((list-equal? (cons #1 (cons #1 (cons #3 (cons #4 (cons #5 (cons #9 nil))))))) (⊙sort random-list)))

; Default sort: with duplicates
(test-case :sort-duplicates
   #t
   ((list-equal? (cons #1 (cons #1 (cons #2 (cons #2 (cons #3 (cons #3 nil))))))) (⊙sort duplicates-list)))

; ────────────────────────────────────────────────────────────────
; MERGE HELPER TESTS
; ────────────────────────────────────────────────────────────────

; Test merge on two empty lists
(test-case :merge-both-empty
   #t
   ((list-equal? empty-list) (((⊙merge ⊙≤) empty-list) empty-list)))

; Test merge on one empty list
(test-case :merge-one-empty
   #t
   ((list-equal? sorted-list) (((⊙merge ⊙≤) sorted-list) empty-list)))

; Test merge on two sorted lists
(test-case :merge-two-sorted
   #t
   ((list-equal? (cons #1 (cons #2 (cons #3 (cons #4 (cons #5 (cons #6 nil)))))))
    (((⊙merge ⊙≤) (cons #1 (cons #3 (cons #5 nil)))) (cons #2 (cons #4 (cons #6 nil))))))

; ────────────────────────────────────────────────────────────────
; PARTITION TESTS
; ────────────────────────────────────────────────────────────────

; Test partition with all less than pivot
(test-case :partition-all-less
   #t
   ((lambda (result)
      (and ((list-equal? (car result)) (cons #1 (cons #2 (cons #3 nil))))
          ((list-equal? (cdr result)) empty-list)))
    (((⊙partition ⊙≤) #10) (cons #1 (cons #2 (cons #3 nil))))))

; Test partition with all greater than pivot
(test-case :partition-all-greater
   #t
   ((lambda (result)
      (and ((list-equal? (car result)) empty-list)
          ((list-equal? (cdr result)) (cons #1 (cons #2 (cons #3 nil))))))
    (((⊙partition ⊙≤) #0) (cons #1 (cons #2 (cons #3 nil))))))

; Test partition with mixed elements
(test-case :partition-mixed
   #t
   ((lambda (result)
      (and ((list-equal? (car result)) (cons #1 (cons #2 nil)))
          ((list-equal? (cdr result)) (cons #4 (cons #5 nil)))))
    (((⊙partition ⊙≤) #3) (cons #1 (cons #4 (cons #2 (cons #5 nil)))))))

; ────────────────────────────────────────────────────────────────
; VERIFICATION: All algorithms produce same result
; ────────────────────────────────────────────────────────────────

(define test-list (cons #7 (cons #2 (cons #9 (cons #1 (cons #5 nil))))))
(define expected (cons #1 (cons #2 (cons #5 (cons #7 (cons #9 nil))))))

; Verify all algorithms agree
(test-case :verify-bubble-matches
   #t
   ((list-equal? expected) (⊙bubble test-list)))

(test-case :verify-insertion-matches
   #t
   ((list-equal? expected) (⊙insertion test-list)))

(test-case :verify-merge-matches
   #t
   ((list-equal? expected) (⊙mergesort test-list)))

(test-case :verify-quick-matches
   #t
   ((list-equal? expected) (⊙quicksort test-list)))

(test-case :verify-sort-matches
   #t
   ((list-equal? expected) (⊙sort test-list)))

; ────────────────────────────────────────────────────────────────
; INTEGRATION TESTS
; ────────────────────────────────────────────────────────────────

; Sort then verify sorted
(test-case :sort-then-check
   #t
   (⊙⊢ (⊙sort random-list)))

; Sort descending then verify
(test-case :sort-desc-then-check
   #t
   ((⊙⊢→ ⊙≥) ((⊙sort→ ⊙≥) random-list)))

; Sort preserves length
(define count-length (lambda (lst)
  (if (null? lst) #0 (+ #1 (count-length (cdr lst))))))

(test-case :sort-preserves-length
   #t
   (equal? (count-length random-list) (count-length (⊙sort random-list))))

; ═══════════════════════════════════════════════════════════════
; END OF TESTS
; ═══════════════════════════════════════════════════════════════
