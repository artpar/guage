; Mutation Testing - Working Test Suite
; Tests mutation-test with functions that avoid #0 and #1 constants
; (due to De Bruijn heuristic limitation)

; Test 1: Simple arithmetic with constant > 1
(define double (lambda (n) (* n #2)))
(define r1 (mutation-test :double))
(test-case :double-sum-formula #t (equal? (+ (car r1) (car (cdr r1))) (car (cdr (cdr r1)))))

; Test 2: Function with larger constants
(define triple (lambda (n) (* n #3)))
(define r2 (mutation-test :triple))
(test-case :triple-sum-formula #t (equal? (+ (car r2) (car (cdr r2))) (car (cdr (cdr r2)))))
(test-case :triple-has-muts #t (> (car (cdr (cdr r2))) #0))

; Test 3: Multiple operators
(define combo (lambda (x) (+ (* x #2) #3)))
(define r3 (mutation-test :combo))
(test-case :combo-sum-formula #t (equal? (+ (car r3) (car (cdr r3))) (car (cdr (cdr r3)))))
(test-case :combo-multi-muts #t (> (car (cdr (cdr r3))) #1))

; Test 4: Error on non-existent function
(test-case :nonexistent-error #t (error? (mutation-test :does-not-exist)))

; Test 5: Result structure
(test-case :result-is-pair #t (pair? r1))
(test-case :result-3-elements #t (pair? (cdr (cdr r1))))
