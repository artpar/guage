; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Extended List Operations Tests - Day 36
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Testing 20 new list utilities with comprehensive test coverage
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

; Load the extended list operations
(load "bootstrap/stdlib/list_extended.scm")

; â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
; ZIP OPERATIONS (6 tests)
; â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

; Test basic zip
(test-case :test-zip-basic
   (cons (cons #1 #4) (cons (cons #2 #5) (cons (cons #3 #6) nil)))
   (âŠ•âŠ™ (cons #1 (cons #2 (cons #3 nil))) (cons #4 (cons #5 (cons #6 nil)))))

; Test zip with different lengths (stops at shorter)
(test-case :test-zip-different-length
   (cons (cons #1 #4) (cons (cons #2 #5) nil))
   (âŠ•âŠ™ (cons #1 (cons #2 nil)) (cons #4 (cons #5 (cons #6 nil)))))

; Test zip with empty list
(test-case :test-zip-empty
   nil
   (âŠ•âŠ™ nil (cons #1 (cons #2 nil))))

; Test zip-with addition (wrap primitive in curried lambda)
(test-case :test-zip-with-add
   (cons #4 (cons #6 nil))
   ((âŠ•âŠ™â†’ (lambda (a) (lambda (b) (+ a b)))) (cons #1 (cons #2 nil)) (cons #3 (cons #4 nil))))

; Test zip-with multiplication (wrap primitive in curried lambda)
(test-case :test-zip-with-mul
   (cons #10 (cons #20 (cons #30 nil)))
   ((âŠ•âŠ™â†’ (lambda (a) (lambda (b) (* a b)))) (cons #2 (cons #4 (cons #5 nil))) (cons #5 (cons #5 (cons #6 nil)))))

; Test zip-with empty (wrap primitive in curried lambda)
(test-case :test-zip-with-empty
   nil
   ((âŠ•âŠ™â†’ (lambda (a) (lambda (b) (+ a b)))) nil (cons #1 nil)))

; â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
; CONDITIONAL OPERATIONS (8 tests)
; â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

; Test take-while
(test-case :test-take-while-basic
   (cons #1 (cons #2 (cons #3 nil)))
   ((âŠ™â–·â†’ (lambda (ğ•©) (< ğ•© #4))) (cons #1 (cons #2 (cons #3 (cons #5 nil))))))

; Test take-while all
(test-case :test-take-while-all
   (cons #1 (cons #2 (cons #3 nil)))
   ((âŠ™â–·â†’ (lambda (ğ•©) (< ğ•© #10))) (cons #1 (cons #2 (cons #3 nil)))))

; Test take-while none
(test-case :test-take-while-none
   nil
   ((âŠ™â–·â†’ (lambda (ğ•©) (> ğ•© #10))) (cons #1 (cons #2 nil))))

; Test drop-while
(test-case :test-drop-while-basic
   (cons #5 (cons #6 nil))
   ((âŠ™â—â†’ (lambda (ğ•©) (< ğ•© #5))) (cons #1 (cons #2 (cons #5 (cons #6 nil))))))

; Test drop-while all
(test-case :test-drop-while-all
   nil
   ((âŠ™â—â†’ (lambda (ğ•©) (< ğ•© #10))) (cons #1 (cons #2 (cons #3 nil)))))

; Test drop-while none
(test-case :test-drop-while-none
   (cons #1 (cons #2 nil))
   ((âŠ™â—â†’ (lambda (ğ•©) (> ğ•© #10))) (cons #1 (cons #2 nil))))

; Test span (split)
(test-case :test-span-basic
   (cons (cons #1 (cons #2 (cons #3 nil))) (cons #5 (cons #6 nil)))
   ((âŠ™âŠ‚â†’ (lambda (ğ•©) (< ğ•© #5))) (cons #1 (cons #2 (cons #3 (cons #5 (cons #6 nil)))))))

; Test span all true
(test-case :test-span-all
   (cons (cons #1 (cons #2 nil)) nil)
   ((âŠ™âŠ‚â†’ (lambda (ğ•©) (< ğ•© #10))) (cons #1 (cons #2 nil))))

; â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
; SET-LIKE OPERATIONS (10 tests)
; â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

; Test elem present
(test-case :test-elem-present
   #t
   ((âŠ™âŠ†â†’ #3) (cons #1 (cons #2 (cons #3 (cons #4 nil))))))

; Test elem absent
(test-case :test-elem-absent
   #f
   ((âŠ™âŠ†â†’ #5) (cons #1 (cons #2 (cons #3 nil)))))

; Test unique with duplicates
(test-case :test-unique-basic
   (cons #1 (cons #2 (cons #3 nil)))
   (âŠ™â‰¡â†’ (cons #1 (cons #2 (cons #1 (cons #3 (cons #2 nil)))))))

; Test unique no duplicates
(test-case :test-unique-no-dup
   (cons #1 (cons #2 (cons #3 nil)))
   (âŠ™â‰¡â†’ (cons #1 (cons #2 (cons #3 nil)))))

; Test unique empty
(test-case :test-unique-empty
   nil
   (âŠ™â‰¡â†’ nil))

; Test difference
(test-case :test-difference-basic
   (cons #1 (cons #3 nil))
   ((âŠ™âŠ–â†’ (cons #1 (cons #2 (cons #3 nil)))) (cons #2 (cons #4 nil))))

; Test difference empty
(test-case :test-difference-empty
   nil
   ((âŠ™âŠ–â†’ (cons #1 (cons #2 nil))) (cons #1 (cons #2 (cons #3 nil)))))

; Test intersection
(test-case :test-intersection-basic
   (cons #2 (cons #3 nil))
   ((âŠ™âŠ—â†’ (cons #1 (cons #2 (cons #3 nil)))) (cons #2 (cons #3 (cons #4 nil)))))

; Test intersection empty
(test-case :test-intersection-empty
   nil
   ((âŠ™âŠ—â†’ (cons #1 (cons #2 nil))) (cons #3 (cons #4 nil))))

; Test intersection all
(test-case :test-intersection-all
   (cons #1 (cons #2 nil))
   ((âŠ™âŠ—â†’ (cons #1 (cons #2 nil))) (cons #1 (cons #2 (cons #3 nil)))))

; â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
; PREDICATES (6 tests)
; â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

; Test all true
(test-case :test-all-true
   #t
   ((âŠ™âˆ§â†’ (lambda (ğ•©) (< ğ•© #10))) (cons #1 (cons #2 (cons #3 nil)))))

; Test all false
(test-case :test-all-false
   #f
   ((âŠ™âˆ§â†’ (lambda (ğ•©) (< ğ•© #2))) (cons #1 (cons #2 (cons #3 nil)))))

; Test all empty
(test-case :test-all-empty
   #t
   ((âŠ™âˆ§â†’ (lambda (ğ•©) (< ğ•© #10))) nil))

; Test any true
(test-case :test-any-true
   #t
   ((âŠ™âˆ¨â†’ (lambda (ğ•©) (> ğ•© #5))) (cons #1 (cons #7 (cons #3 nil)))))

; Test any false
(test-case :test-any-false
   #f
   ((âŠ™âˆ¨â†’ (lambda (ğ•©) (> ğ•© #10))) (cons #1 (cons #2 (cons #3 nil)))))

; Test any empty
(test-case :test-any-empty
   #f
   ((âŠ™âˆ¨â†’ (lambda (ğ•©) (> ğ•© #10))) nil))

; â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
; PARTITIONING (4 tests)
; â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

; Test partition evens/odds
(test-case :test-partition-even-odd
   (cons (cons #2 (cons #4 nil)) (cons #1 (cons #3 nil)))
   ((âŠ™âŠ²âŠ²â†’ (lambda (ğ•©) (equal? (% ğ•© #2) #0))) (cons #1 (cons #2 (cons #3 (cons #4 nil))))))

; Test partition all true
(test-case :test-partition-all-true
   (cons (cons #1 (cons #2 nil)) nil)
   ((âŠ™âŠ²âŠ²â†’ (lambda (ğ•©) (< ğ•© #10))) (cons #1 (cons #2 nil))))

; Test partition all false
(test-case :test-partition-all-false
   (cons nil (cons #1 (cons #2 nil)))
   ((âŠ™âŠ²âŠ²â†’ (lambda (ğ•©) (> ğ•© #10))) (cons #1 (cons #2 nil))))

; Test partition empty
(test-case :test-partition-empty
   (cons nil nil)
   ((âŠ™âŠ²âŠ²â†’ (lambda (ğ•©) (> ğ•© #10))) nil))

; â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
; LIST MANIPULATION (12 tests)
; â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

; Test concat
(test-case :test-concat-basic
   (cons #1 (cons #2 (cons #3 (cons #4 nil))))
   (âŠ™âŠ•âŠ•â†’ (cons (cons #1 (cons #2 nil)) (cons (cons #3 (cons #4 nil)) nil))))

; Test concat empty
(test-case :test-concat-empty
   nil
   (âŠ™âŠ•âŠ•â†’ nil))

; Test concat single
(test-case :test-concat-single
   (cons #1 (cons #2 nil))
   (âŠ™âŠ•âŠ•â†’ (cons (cons #1 (cons #2 nil)) nil)))

; Test interleave
(test-case :test-interleave-basic
   (cons #1 (cons #4 (cons #2 (cons #5 (cons #3 (cons #6 nil))))))
   ((âŠ™â‹ˆâ†’ (cons #1 (cons #2 (cons #3 nil)))) (cons #4 (cons #5 (cons #6 nil)))))

; Test interleave different lengths
(test-case :test-interleave-diff
   (cons #1 (cons #4 (cons #2 (cons #5 nil))))
   ((âŠ™â‹ˆâ†’ (cons #1 (cons #2 nil))) (cons #4 (cons #5 (cons #6 nil)))))

; Test rotate left
(test-case :test-rotate-left-basic
   (cons #3 (cons #4 (cons #5 (cons #1 (cons #2 nil)))))
   ((âŠ™â‰ªâ†’ #2) (cons #1 (cons #2 (cons #3 (cons #4 (cons #5 nil)))))))

; Test rotate left zero
(test-case :test-rotate-left-zero
   (cons #1 (cons #2 (cons #3 nil)))
   ((âŠ™â‰ªâ†’ #0) (cons #1 (cons #2 (cons #3 nil)))))

; Test safe head success
(test-case :test-safe-head-ok
   #1
   (âŠ™âŠ³â†’ (cons #1 (cons #2 nil))))

; Test safe head error
(test-case :test-safe-head-err
   #t
   (error? (âŠ™âŠ³â†’ nil)))

; Test safe tail success
(test-case :test-safe-tail-ok
   (cons #2 (cons #3 nil))
   (âŠ™âŠ´â†’ (cons #1 (cons #2 (cons #3 nil)))))

; Test safe tail error
(test-case :test-safe-tail-err
   #t
   (error? (âŠ™âŠ´â†’ nil)))

; Test length
(test-case :test-length-basic
   #5
   (âŠ™#â†’ (cons #1 (cons #2 (cons #3 (cons #4 (cons #5 nil)))))))

; Test length empty
(test-case :test-length-empty
   #0
   (âŠ™#â†’ nil))

; â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
; INTEGRATION TESTS (4 tests)
; â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

; Test pipeline: unique, then partition evens, check first part
(test-case :test-integration-pipeline
   (cons #2 (cons #4 nil))
   (car ((âŠ™âŠ²âŠ²â†’ (lambda (ğ•©) (equal? (% ğ•© #2) #0)))
       (âŠ™â‰¡â†’ (cons #1 (cons #2 (cons #1 (cons #4 (cons #2 nil))))))))

; Test: take while < 5, then count length
(test-case :test-integration-take-count
   #4
   (âŠ™#â†’ ((âŠ™â–·â†’ (lambda (ğ•©) (< ğ•© #5))) (cons #1 (cons #2 (cons #3 (cons #4 (cons #10 nil))))))))

; Test: interleave then unique
(test-case :test-integration-interleave-unique
   (cons #1 (cons #2 (cons #3 nil)))
   (âŠ™â‰¡â†’ ((âŠ™â‹ˆâ†’ (cons #1 (cons #2 nil))) (cons #2 (cons #3 nil)))))

; Test: all and any together
(test-case :test-integration-all-any
   #t
   (and ((âŠ™âˆ§â†’ (lambda (ğ•©) (< ğ•© #10))) (cons #1 (cons #2 (cons #3 nil))))
      ((âŠ™âˆ¨â†’ (lambda (ğ•©) (> ğ•© #1))) (cons #1 (cons #2 (cons #3 nil))))))

; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
(print "âœ“ 50 extended list operation tests complete!")
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
