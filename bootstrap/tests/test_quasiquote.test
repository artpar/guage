; Test file for quasiquote (quasiquote-tilde) and unquote (~)
; Day 32 Part 2: Macro System - Quote Templates

; ============ Basic Quasiquote Tests ============

; Test 1: Quasiquote without unquote acts like quote
(test-case :qq-like-quote
   (quote (+ #1 #2))
   (quasiquote-tilde (+ #1 #2)))

; Test 2: Simple unquote - single value
(define x #42)
(test-case :qq-simple-unquote
   #42
   (quasiquote-tilde (~ x)))

; Test 3: Unquote in list structure
(define y #5)
(test-case :qq-unquote-in-list
   (quote (+ #1 #5))
   (quasiquote-tilde (+ #1 (~ y))))

; ============ Multiple Unquotes ============

; Test 4: Multiple unquotes
(define a #10)
(define b #20)
(test-case :qq-multiple-unquotes
   (quote (+ #10 #20))
   (quasiquote-tilde (+ (~ a) (~ b))))

; Test 5: Unquote in different positions
(define op :+)
(test-case :qq-unquote-operator
   (quote (:+ #3 #4))
   (quasiquote-tilde ((~ op) #3 #4)))

; ============ Nested Structures ============

; Test 6: Nested lists with unquote
(define inner #99)
(test-case :qq-nested-list
   (quote (cons #1 (cons #99 nil)))
   (quasiquote-tilde (cons #1 (cons (~ inner) nil))))

; Test 7: Unquote in nested expression
(define val #7)
(test-case :qq-nested-expr
   (quote (* (+ #1 #7) #2))
   (quasiquote-tilde (* (+ #1 (~ val)) #2)))

; ============ Evaluated Expressions ============

; Test 8: Unquote evaluates expression
(define n #5)
(test-case :qq-eval-expr
   (quote (result #10))
   (quasiquote-tilde (result (~ (* n #2)))))

; Test 9: Unquote with function call
(define double (lambda (x) (* x #2)))
(define num #21)
(test-case :qq-function-call
   (quote (value #42))
   (quasiquote-tilde (value (~ (double num)))))

; ============ Mixed Quoted and Unquoted ============

; Test 10: Mix quoted and unquoted parts
(define x1 #100)
(test-case :qq-mixed
   (quote (:constant #100 :another-constant))
   (quasiquote-tilde (:constant (~ x1) :another-constant)))

; Test 11: Symbol quoted, value unquoted
(define tag :error)
(define code #404)
(test-case :qq-symbol-value-mix
   (quote (:response :error #404))
   (quasiquote-tilde (:response (~ tag) (~ code))))

; ============ Edge Cases ============

; Test 12: Empty unquote should error (handle gracefully)
; (quasiquote-tilde (~))  ; Would error - unquote needs argument

; Test 13: Nested quasiquotes (advanced)
(define depth #2)
(test-case :qq-nested-qq
   (quote (level #2))
   (quasiquote-tilde (level (~ depth))))

; Test 14: Unquote nil
(define empty nil)
(test-case :qq-unquote-nil
   nil
   (quasiquote-tilde (~ empty)))

; Test 15: Unquote boolean
(define flag #t)
(test-case :qq-unquote-bool
   #t
   (quasiquote-tilde (~ flag)))

; ============ Real-World Usage ============

; Test 16: Build expression programmatically
(define build-add (lambda (x) (lambda (y)
  (quasiquote-tilde (+ (~ x) (~ y))))))

(test-case :qq-build-expr
   (quote (+ #3 #4))
   ((build-add #3) #4))

; Test 17: Conditional expression building
(define make-test (lambda (val) (lambda (expected)
  (quasiquote-tilde (equal? (~ val) (~ expected))))))

(test-case :qq-conditional
   (quote (equal? #42 #42))
   ((make-test #42) #42))

; Test 18: Template with multiple values
(define make-pair (lambda (a) (lambda (b)
  (quasiquote-tilde (cons (~ a) (~ b))))))

(test-case :qq-template
   (quote (cons #1 #2))
   ((make-pair #1) #2))

; ============ Macro-Like Usage ============

; Test 19: Simple comparison builder
(define make-gt (lambda (a) (lambda (b)
  (quasiquote-tilde (> (~ a) (~ b))))))

(test-case :qq-comparison
   (quote (> #10 #5))
   ((make-gt #10) #5))

; Test 20: List constructor
(define make-triple (lambda (a) (lambda (b) (lambda (c)
  (quasiquote-tilde (cons (~ a) (cons (~ b) (cons (~ c) nil))))))))

(test-case :qq-triple
   (quote (cons #1 (cons #2 (cons #3 nil))))
   (((make-triple #1) #2) #3))

(print "âœ“ All quasiquote tests defined")
