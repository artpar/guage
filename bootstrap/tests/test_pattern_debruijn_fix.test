;; Test: Pattern matching with De Bruijn indices in nested lambdas
;; Purpose: Verify bug fix for match dereferencing De Bruijn indices in closures
;; Status: FIXED (Day 57) - Pattern matching now correctly dereferences De Bruijn indices
;;
;; Bug Fixed: When match is used inside a lambda, the value being matched (a De Bruijn index)
;;            is now correctly dereferenced before pattern matching.
;;
;; Known Limitation: Quoted pattern result expressions cannot reference outer lambda parameters
;;                   by name (they were converted to De Bruijn indices). Use ⊚?/⊚→ primitives
;;                   or quasiquote/unquote for such cases.

;; ============================================================
;; Test 1: Original bug - pattern match on lambda parameter
;; ============================================================

(adt-define :Result (quote (:Ok :value)) (quote (:Err :error)))

;; The bug was: (match r ...) where r is De Bruijn index #0 would fail with :no-match:#0
;; FIX: Pattern matcher now evaluates the expression in the correct environment
(define test-debruijn-match (lambda (r)
  (match r (quote (((adt-create :Result :Ok v) :matched-ok)
           ((adt-create :Result :Err e) :matched-err))))))

(test-case :debruijn-ok :matched-ok (test-debruijn-match (adt-create :Result :Ok #42)))
(test-case :debruijn-err :matched-err (test-debruijn-match (adt-create :Result :Err :fail)))

;; ============================================================
;; Test 2: Pattern-bound variables are accessible in results
;; ============================================================

;; Pattern bindings (like v) create named bindings accessible in result expressions
(define extract-value (lambda (r)
  (match r (quote (((adt-create :Result :Ok v) v)
           ((adt-create :Result :Err e) e))))))

(test-case :extract-ok #42 (extract-value (adt-create :Result :Ok #42)))
(test-case :extract-err :error (extract-value (adt-create :Result :Err :error)))

;; ============================================================
;; Test 3: Pattern matching in deeply nested lambdas
;; ============================================================

;; Multiple levels of nesting - value still dereferenced correctly
(define nested-match (lambda (a) (lambda (b) (lambda (r)
  (match r (quote (((adt-create :Result :Ok v) v)
           ((adt-create :Result :Err e) e))))))))

(test-case :nested-ok #99 (((nested-match #1) #2) (adt-create :Result :Ok #99)))
(test-case :nested-err :bad (((nested-match #1) #2) (adt-create :Result :Err :bad)))

;; ============================================================
;; Test 4: Pair destructuring with De Bruijn indices
;; ============================================================

;; Destructure pairs inside lambdas
(define swap-pair (lambda (p)
  (match p (quote (((cons a b) (cons b a)))))))

;; Note: Pattern result (cons b a) references pattern-bound variables a and b
(define test-swap (swap-pair (cons #1 #2)))
(test-case :swap-car #2 (car test-swap))
(test-case :swap-cdr #1 (cdr test-swap))

;; Nested lambda with pair destructuring
(define nested-swap (lambda (x) (lambda (p)
  (match p (quote (((cons a b) (cons b a))))))))

(define test-nested-swap ((nested-swap :ignore) (cons #42 #99)))
(test-case :nested-swap-car #99 (car test-nested-swap))
(test-case :nested-swap-cdr #42 (cdr test-nested-swap))

;; ============================================================
;; Test 5: Multiple pattern clauses in nested lambdas
;; ============================================================

;; Pattern matching with multiple clauses all work correctly
;; Note: Literal patterns (#0) must come BEFORE variable patterns (v) to match correctly
(define classify-result (lambda (r)
  (match r (quote (((adt-create :Result :Ok v) :has-value)
           ((adt-create :Result :Err e) :has-error))))))

(test-case :classify-value :has-value (classify-result (adt-create :Result :Ok #42)))
(test-case :classify-error :has-error (classify-result (adt-create :Result :Err :bad)))

;; ============================================================
;; Test 6: Complex ADT patterns in closures
;; ============================================================

;; Nested structure destructuring
(define extract-double (lambda (r)
  (match r (quote (((adt-create :Result :Ok value) (* value #2))
           ((adt-create :Result :Err e) #0))))))

(test-case :double-ok #84 (extract-double (adt-create :Result :Ok #42)))
(test-case :double-err #0 (extract-double (adt-create :Result :Err :fail)))

(print "✅ All De Bruijn index dereferencing tests passed!")
