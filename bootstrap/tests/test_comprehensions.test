; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Test Suite: List Comprehensions
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Status: CURRENT
; Created: 2026-01-27 (Day 35)
; Purpose: Comprehensive tests for stdlib/comprehensions.scm
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

; Load required modules
(load "bootstrap/stdlib/list.scm")
(load "bootstrap/stdlib/macros.scm")
(load "bootstrap/stdlib/comprehensions.scm")

; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Phase 1: Range Generation Tests
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

; Test 1: Basic range (inclusive)
(test-case :test-range-basic
   (cons #1 (cons #2 (cons #3 (cons #4 (cons #5 nil)))))
   (range-inclusive #1 #5))

; Test 2: Single element range
(test-case :test-range-single
   (cons #3 nil)
   (range-inclusive #3 #3))

; Test 3: Empty range (start > end)
(test-case :test-range-empty
   nil
   (range-inclusive #5 #1))

; Test 4: Longer range
(test-case :test-range-longer
   (cons #1 (cons #2 (cons #3 (cons #4 (cons #5 (cons #6 (cons #7 (cons #8 (cons #9 (cons #10 nil))))))))))
   (range-inclusive #1 #10))

; Test 5: Range starting from 0
(test-case :test-range-zero
   (cons #0 (cons #1 (cons #2 nil)))
   (range-inclusive #0 #2))

; Test 6: Range with step (custom increment)
(test-case :test-range-step-2
   (cons #1 (cons #3 (cons #5 (cons #7 (cons #9 nil)))))
   (range-step #1 #10 #2))

; Test 7: Range with step 3
(test-case :test-range-step-3
   (cons #0 (cons #3 (cons #6 (cons #9 nil))))
   (range-step #0 #10 #3))

; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Phase 2: Basic Comprehension Tests (Map, Filter)
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

; Test 8: Map - double each element
(test-case :test-comp-map-double
   (cons #2 (cons #4 (cons #6 (cons #8 (cons #10 nil)))))
   ((comp-map (lambda (ğ•©) (* ğ•© #2))) (range-inclusive #1 #5)))

; Test 9: Map - square each element
(test-case :test-comp-map-square
   (cons #1 (cons #4 (cons #9 (cons #16 (cons #25 nil)))))
   ((comp-map (lambda (ğ•©) (* ğ•© ğ•©))) (range-inclusive #1 #5)))

; Test 10: Filter - even numbers
(test-case :test-comp-filter-even
   (cons #2 (cons #4 (cons #6 (cons #8 (cons #10 nil)))))
   ((comp-filter (lambda (ğ•©) (equal? (% ğ•© #2) #0))) (range-inclusive #1 #10)))

; Test 11: Filter - greater than 5
(test-case :test-comp-filter-gt
   (cons #6 (cons #7 (cons #8 (cons #9 (cons #10 nil)))))
   ((comp-filter (lambda (ğ•©) (> ğ•© #5))) (range-inclusive #1 #10)))

; Test 12: Filter then map - squares of evens
(test-case :test-comp-filter-map
   (cons #4 (cons #16 (cons #36 (cons #64 (cons #100 nil)))))
   (comp-filter-map (lambda (ğ•©) (equal? (% ğ•© #2) #0)) (lambda (ğ•©) (* ğ•© ğ•©)) (range-inclusive #1 #10)))

; Test 13: Filter then map - double odd numbers
(test-case :test-comp-filter-map-odd
   (cons #2 (cons #6 (cons #10 (cons #14 (cons #18 nil)))))
   (comp-filter-map (lambda (ğ•©) (equal? (% ğ•© #2) #1)) (lambda (ğ•©) (* ğ•© #2)) (range-inclusive #1 #10)))

; Test 14: Filter empty result
(test-case :test-comp-filter-empty
   nil
   ((comp-filter (lambda (ğ•©) (> ğ•© #100))) (range-inclusive #1 #10)))

; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Phase 3: Advanced Comprehension Tests
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

; Test 15: Cartesian product 2x2
(test-case :test-comp-cartesian-2x2
   (cons (cons #1 #3) (cons (cons #1 #4) (cons (cons #2 #3) (cons (cons #2 #4) nil))))
   ((âŠ¡âŠ› (range-inclusive #1 #2)) (range-inclusive #3 #4)))

; Test 16: Cartesian product 3x2
(test-case :test-comp-cartesian-3x2
   (cons (cons #1 #4) (cons (cons #1 #5) (cons (cons #2 #4) (cons (cons #2 #5) (cons (cons #3 #4) (cons (cons #3 #5) nil))))))
   ((âŠ¡âŠ› (range-inclusive #1 #3)) (range-inclusive #4 #5)))

; Test 17: Accumulator - sum
(test-case :test-comp-sum
   #55
   (((âŠ¡âŠ• +) #0) (range-inclusive #1 #10)))

; Test 18: Accumulator - factorial
(test-case :test-comp-factorial
   #120
   (((âŠ¡âŠ• *) #1) (range-inclusive #1 #5)))

; Test 19: Accumulator - count elements
(test-case :test-comp-count
   #10
   (((âŠ¡âŠ• (lambda (ğ•’ _) (+ ğ•’ #1))) #0) (range-inclusive #1 #10)))

; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Phase 4: Macro-Based Comprehension Tests
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

; Test 20: Macro map over range
(test-case :test-macro-map-range
   (cons #2 (cons #4 (cons #6 (cons #8 (cons #10 nil)))))
   (comp-map-to #1 #5 (lambda (ğ•©) (* ğ•© #2))))

; Test 21: Macro map - squares
(test-case :test-macro-map-square
   (cons #1 (cons #4 (cons #9 (cons #16 (cons #25 nil)))))
   (comp-map-to #1 #5 (lambda (ğ•©) (* ğ•© ğ•©))))

; Test 22: Macro filter - evens
(test-case :test-macro-filter-even
   (cons #2 (cons #4 (cons #6 (cons #8 (cons #10 nil)))))
   (comp-filter-to #1 #10 (lambda (ğ•©) (equal? (% ğ•© #2) #0))))

; Test 23: Macro filter and map
(test-case :test-macro-filter-map
   (cons #4 (cons #16 (cons #36 (cons #64 (cons #100 nil)))))
   (comp-filter-map-to #1 #10 (lambda (ğ•©) (equal? (% ğ•© #2) #0)) (lambda (ğ•©) (* ğ•© ğ•©))))

; Test 24: Macro filter - odds doubled
(test-case :test-macro-filter-odd-double
   (cons #2 (cons #6 (cons #10 (cons #14 (cons #18 nil)))))
   (comp-filter-map-to #1 #10 (lambda (ğ•©) (equal? (% ğ•© #2) #1)) (lambda (ğ•©) (* ğ•© #2))))

; Test 25: Macro map with addition
(test-case :test-macro-map-add
   (cons #11 (cons #12 (cons #13 (cons #14 (cons #15 nil)))))
   (comp-map-to #1 #5 (lambda (ğ•©) (+ ğ•© #10))))

; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Phase 5: Integration Tests (Real-World Examples)
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

; Test 26: Sum of squares (1Â² + 2Â² + 3Â² + 4Â² + 5Â² = 55)
(test-case :test-sum-of-squares
   #55
   (((âŠ¡âŠ• +) #0) ((comp-map (lambda (ğ•©) (* ğ•© ğ•©))) (range-inclusive #1 #5))))

; Test 27: Product of evens (2 * 4 * 6 * 8 * 10 = 3840)
(test-case :test-product-evens
   #3840
   (((âŠ¡âŠ• *) #1) ((comp-filter (lambda (ğ•©) (equal? (% ğ•© #2) #0))) (range-inclusive #1 #10))))

; Test 28: Count evens
(test-case :test-count-evens
   #5
   (((âŠ¡âŠ• (lambda (ğ•’ _) (+ ğ•’ #1))) #0) ((comp-filter (lambda (ğ•©) (equal? (% ğ•© #2) #0))) (range-inclusive #1 #10))))

"âœ“ 28 list comprehension tests complete!"
