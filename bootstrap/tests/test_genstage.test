; Day 103: GenStage (producer-consumer) tests — ⟳⊵, ⟳⊵⊕, ⟳⊵→, ⟳⊵⊙, ⟳⊵?, stage-stop

; Reset state
(actor-reset)

; === stage-new-producer ===
; Create a producer stage
(actor-reset)
(define p (stage-new :producer
  (lambda (demand state) (cons (cons state nil) (+ state #1)))
  #0))
(test-case (quote :stage-new-producer) #t (>= p #0))

; === stage-new-consumer ===
; Create a consumer stage
(actor-reset)
(define c (stage-new :consumer
  (lambda (events state) (+ state #1))
  #0))
(test-case (quote :stage-new-consumer) #t (>= c #0))

; === stage-ask-producer ===
; Ask producer for events — returns list from handler
(actor-reset)
(define p (stage-new :producer
  (lambda (demand state)
    ; always produce (state), advance state by demand
    (cons (cons state nil) (+ state demand)))
  #0))
(define evts (stage-ask p #3))
; Should get (0) and state advanced to 3
(test-case (quote :stage-ask-producer) (cons #0 nil) evts)

; === stage-ask-updates-state ===
; Asking updates producer state across calls
(actor-reset)
(define p (stage-new :producer
  (lambda (demand state)
    (cons (cons state nil) (+ state #1)))
  #10))
(stage-ask p #1)   ; produces (10), state→11
(stage-ask p #1)   ; produces (11), state→12
(define evts (stage-ask p #1))  ; produces (12), state→13
(test-case (quote :stage-ask-updates-state) (cons #12 nil) evts)

; === stage-subscribe-basic ===
; Subscribe consumer to producer
(actor-reset)
(define p (stage-new :producer
  (lambda (demand state) (cons (cons state nil) (+ state #1)))
  #0))
(define c (stage-new :consumer
  (lambda (events state) (+ state #1))
  #0))
(test-case (quote :stage-subscribe-basic) #t (stage-subscribe c p))

; === stage-dispatch ===
; Dispatch events to subscribed consumer updates its state
(actor-reset)
(define p (stage-new :producer
  (lambda (demand state) (cons (cons state nil) (+ state #1)))
  #0))
(define c (stage-new :consumer
  (lambda (events state) (+ state #1))
  #0))
(stage-subscribe c p)
; Dispatch events to consumers
(stage-dispatch p (cons :hello nil))
; Consumer handler called, state incremented to 1
(define info (stage-info c))
(test-case (quote :stage-dispatch) #1 (cdr info))

; === stage-info ===
; Get stage info returns ⟨mode state⟩
(actor-reset)
(define p (stage-new :producer
  (lambda (demand state) (cons nil state))
  #42))
(define info (stage-info p))
(test-case (quote :stage-info) (cons :producer #42) info)

; === stage-stop ===
; Stop returns final state
(actor-reset)
(define p (stage-new :producer
  (lambda (demand state) (cons nil state))
  :final))
(test-case (quote :stage-stop) :final (stage-stop p))

; === stage-stop-error ===
; Operations on stopped stage return error
(actor-reset)
(define p (stage-new :producer (lambda (demand state) (cons nil state)) #0))
(stage-stop p)
(test-case (quote :stage-stop-error) #t (error? (stage-ask p #1)))

; === stage-producer-consumer ===
; Producer-consumer mode: handler receives events, returns ⟨out-events new-state⟩
(actor-reset)
(define pc (stage-new :producer-consumer
  (lambda (events state)
    ; pass events through, increment state
    (cons events (+ state #1)))
  #0))
(define c (stage-new :consumer
  (lambda (events state)
    ; state = first event received
    (if (equal? events nil) state (car events)))
  :none))
(stage-subscribe c pc)
; Dispatch events into producer-consumer
(stage-dispatch pc (cons :data nil))
; pc state should be 1, c should have received forwarded events
(define pc-info (stage-info pc))
(test-case (quote :stage-producer-consumer) #1 (cdr pc-info))
