; Test: Trie (trie) — ART with SIMD Node16 + Path Compression
; Day 117

; 1. trie-new-empty — create + size 0
(test-case (quote :trie-new-empty) #0 (trie-size (trie)))

; 2. trie-put-get — insert then lookup
(define t (trie))
(trie-put t :hello #42)
(test-case (quote :trie-put-get) #42 (trie-get t :hello))

; 3. trie-has-missing — membership false for absent key
(test-case (quote :trie-has-missing) #f (trie-has? (trie) :nope))

; 4. trie-delete — remove returns old value
(define t2 (trie))
(trie-put t2 :x #1)
(test-case (quote :trie-delete) #1 (trie-del t2 :x))
(test-case (quote :trie-delete-size) #0 (trie-size t2))

; 5. trie-type-predicate
(test-case (quote :trie-type-yes) #t (trie? (trie)))
(test-case (quote :trie-type-no) #f (trie? #42))

; 6. trie-prefix-search — keys with shared prefix
(define t3 (trie))
(trie-put t3 :cat #1)
(trie-put t3 :car #2)
(trie-put t3 :card #3)
(trie-put t3 :dog #4)
(test-case (quote :trie-prefix-count) #3 (trie-prefix-count t3 :ca))

; 7. trie-longest-prefix — routing-table style lookup
(define t4 (trie))
(trie-put t4 :app #1)
(trie-put t4 :apple #2)
(trie-put t4 :application #3)
(test-case (quote :trie-longest-prefix) :apple (trie-longest-prefix t4 :applesauce))

; 8. trie-merge — combine two tries
(define ta (trie))
(trie-put ta :a #1)
(define tb (trie))
(trie-put tb :b #2)
(define tm (trie-merge ta tb))
(test-case (quote :trie-merge-size) #2 (trie-size tm))

; 9. trie-variadic-constructor — create from pairs
(define t5 (trie (cons :x #1) (cons :y #2) (cons :z #3)))
(test-case (quote :trie-variadic-size) #3 (trie-size t5))
(test-case (quote :trie-variadic-get) #2 (trie-get t5 :y))

; 10. trie-entries-sorted — all entries in lex order
(define t6 (trie (cons :z #3) (cons :a #1) (cons :m #2)))
(define ks (trie-keys t6))
(test-case (quote :trie-keys-first) :a (car ks))

; 11. trie-overwrite — put same key updates value
(define t7 (trie))
(trie-put t7 :k #10)
(trie-put t7 :k #20)
(test-case (quote :trie-overwrite) #20 (trie-get t7 :k))
(test-case (quote :trie-overwrite-size) #1 (trie-size t7))

; 12. trie-has — membership true for present key
(define t8 (trie (cons :foo #1)))
(test-case (quote :trie-has-yes) #t (trie-has? t8 :foo))
(test-case (quote :trie-has-no) #f (trie-has? t8 :bar))

; 13. trie-get-missing — returns nil for absent key
(test-case (quote :trie-get-missing) nil (trie-get (trie) :nokey))

; 14. trie-prefix-keys — prefix search returns key list
(define t9 (trie (cons :abc #1) (cons :abd #2) (cons :xyz #3)))
(define pk (trie-prefix-keys t9 :ab))
(test-case (quote :trie-prefix-keys-first) :abc (car pk))

; 15. trie-vals — all values in key-sorted order
(define t10 (trie (cons :b #2) (cons :a #1) (cons :c #3)))
(define vs (trie-vals t10))
(test-case (quote :trie-vals-first) #1 (car vs))
