; Day 94: Dynamic Supervisor Children + Rest-for-One Strategy
; Tests: add/remove children dynamically, rest-for-one restart strategy

;;; Test 1: sup-add-child basic — add child, verify alive
(actor-reset)
(define w1 (lambda (self) (actor-receive)))
(define sup1 (sup-start :one-for-one (cons w1 nil)))
(actor-run #100)
(define new-behavior (lambda (self) (actor-receive)))
(define new-id (sup-add-child sup1 new-behavior))
(actor-run #100)
; Children list should now have 2 entries, both alive
(define kids1 (sup-children sup1))
(test-case (quote :sup-add-child-basic)
  #t
  (and (actor-alive? (car kids1))
     (actor-alive? (car (cdr kids1)))))

;;; Test 2: sup-add-child multiple — add several dynamically
(actor-reset)
(define base (lambda (self) (actor-receive)))
(define sup2 (sup-start :one-for-one (cons base nil)))
(actor-run #50)
(define d1 (sup-add-child sup2 (lambda (self) (actor-receive))))
(define d2 (sup-add-child sup2 (lambda (self) (actor-receive))))
(actor-run #100)
(define kids2 (sup-children sup2))
; Should have 3 children total (1 original + 2 dynamic)
(test-case (quote :sup-add-child-multiple)
  #3
  (+ (if (actor-alive? (car kids2)) #1 #0)
     (+ (if (actor-alive? (car (cdr kids2))) #1 #0)
        (if (actor-alive? (car (cdr (cdr kids2)))) #1 #0))))

;;; Test 3: sup-add-child max — exceed MAX_SUP_CHILDREN -> error
(actor-reset)
(define sup3 (sup-start :one-for-one nil))
; Add 32 children (MAX_SUP_CHILDREN)
(define add-many (lambda (n)
  (if (equal? n #0)
     :done
     (bind (sup-add-child sup3 (lambda (self) (actor-receive)))
        (lambda (_) (add-many (- n #1)))))))
(add-many #32)
(actor-run #200)
; 33rd should fail
(define overflow-result (sup-add-child sup3 (lambda (self) (actor-receive))))
(test-case (quote :sup-add-child-max)
  #t
  (error? overflow-result))

;;; Test 4: sup-remove-child basic — remove child, verify dead
(actor-reset)
(define w4 (lambda (self) (actor-receive)))
(define sup4 (sup-start :one-for-one (cons w4 (cons w4 nil))))
(actor-run #100)
(define kids4 (sup-children sup4))
(define victim (car kids4))
(sup-remove-child sup4 victim)
(test-case (quote :sup-remove-child-basic)
  #f
  (actor-alive? victim))

;;; Test 5: sup-remove remaining supervised — remove one, crash another, restart works
(actor-reset)
(define crashable (lambda (self)
  (bind (actor-receive) (lambda (msg)
    (if (equal? msg :crash) (error :crashed :boom) msg)))))
(define steady (lambda (self) (actor-receive)))
(define sup5 (sup-start :one-for-one (cons crashable (cons steady nil))))
(actor-run #100)
(define kids5 (sup-children sup5))
(define crash-kid (car kids5))
(define steady-kid (car (cdr kids5)))
; Remove steady kid
(sup-remove-child sup5 steady-kid)
; Crash the crashable one
(actor-send crash-kid :crash)
(actor-run #200)
; Crashable should be restarted, only 1 child now
(define kids5b (sup-children sup5))
(test-case (quote :sup-remove-remaining-supervised)
  #t
  (and (actor-alive? (car kids5b))
     (equal? (cdr kids5b) nil)))

;;; Test 6: rest-for-one basic — crash middle, later restart, earlier unchanged
(actor-reset)
(define ch6 (chan-create))
(define w6a (lambda (self)
  (bind (chan-send ch6 :a-started) (lambda (_) (actor-receive)))))
(define w6b (lambda (self)
  (bind (chan-send ch6 :b-started) (lambda (_)
    (bind (actor-receive) (lambda (msg)
      (if (equal? msg :crash) (error :crashed :b) msg)))))))
(define w6c (lambda (self)
  (bind (chan-send ch6 :c-started) (lambda (_) (actor-receive)))))
(define sup6 (sup-start :rest-for-one (cons w6a (cons w6b (cons w6c nil)))))
(actor-run #100)
(define kids6 (sup-children sup6))
(define old-a6 (car kids6))
(define old-b6 (car (cdr kids6)))
(define old-c6 (car (cdr (cdr kids6))))
; Crash middle child (b)
(actor-send old-b6 :crash)
(actor-run #200)
(define kids6b (sup-children sup6))
(define new-a6 (car kids6b))
(define new-b6 (car (cdr kids6b)))
(define new-c6 (car (cdr (cdr kids6b))))
; a unchanged, b and c restarted (new IDs)
(test-case (quote :rest-for-one-middle-crash)
  #t
  (and (equal? old-a6 new-a6)
     (and (not (equal? old-b6 new-b6))
        (not (equal? old-c6 new-c6)))))

;;; Test 7: rest-for-one first child — crash first, all restart
(actor-reset)
(define ch7 (chan-create))
(define w7a (lambda (self)
  (bind (chan-send ch7 :a) (lambda (_)
    (bind (actor-receive) (lambda (msg)
      (if (equal? msg :crash) (error :crashed :a) msg)))))))
(define w7b (lambda (self) (bind (chan-send ch7 :b) (lambda (_) (actor-receive)))))
(define w7c (lambda (self) (bind (chan-send ch7 :c) (lambda (_) (actor-receive)))))
(define sup7 (sup-start :rest-for-one (cons w7a (cons w7b (cons w7c nil)))))
(actor-run #100)
(define kids7 (sup-children sup7))
(define old-a7 (car kids7))
(define old-b7 (car (cdr kids7)))
(define old-c7 (car (cdr (cdr kids7))))
(actor-send old-a7 :crash)
(actor-run #200)
(define kids7b (sup-children sup7))
(define new-a7 (car kids7b))
(define new-b7 (car (cdr kids7b)))
(define new-c7 (car (cdr (cdr kids7b))))
; All should have new IDs
(test-case (quote :rest-for-one-first-crash)
  #t
  (and (not (equal? old-a7 new-a7))
     (and (not (equal? old-b7 new-b7))
        (not (equal? old-c7 new-c7)))))

;;; Test 8: rest-for-one last child — only last restarts
(actor-reset)
(define ch8 (chan-create))
(define w8a (lambda (self) (bind (chan-send ch8 :a) (lambda (_) (actor-receive)))))
(define w8b (lambda (self) (bind (chan-send ch8 :b) (lambda (_) (actor-receive)))))
(define w8c (lambda (self)
  (bind (chan-send ch8 :c) (lambda (_)
    (bind (actor-receive) (lambda (msg)
      (if (equal? msg :crash) (error :crashed :c) msg)))))))
(define sup8 (sup-start :rest-for-one (cons w8a (cons w8b (cons w8c nil)))))
(actor-run #100)
(define kids8 (sup-children sup8))
(define old-a8 (car kids8))
(define old-b8 (car (cdr kids8)))
(define old-c8 (car (cdr (cdr kids8))))
(actor-send old-c8 :crash)
(actor-run #200)
(define kids8b (sup-children sup8))
(define new-a8 (car kids8b))
(define new-b8 (car (cdr kids8b)))
(define new-c8 (car (cdr (cdr kids8b))))
; a and b unchanged, only c restarted
(test-case (quote :rest-for-one-last-crash)
  #t
  (and (equal? old-a8 new-a8)
     (and (equal? old-b8 new-b8)
        (not (equal? old-c8 new-c8)))))

;;; Test 9: dynamic-add then crash (rest-for-one) — dynamically added child restarts too
(actor-reset)
(define ch9 (chan-create))
(define w9a (lambda (self) (bind (chan-send ch9 :a) (lambda (_) (actor-receive)))))
(define w9b (lambda (self)
  (bind (chan-send ch9 :b) (lambda (_)
    (bind (actor-receive) (lambda (msg)
      (if (equal? msg :crash) (error :crashed :b) msg)))))))
(define sup9 (sup-start :rest-for-one (cons w9a (cons w9b nil))))
(actor-run #100)
; Dynamically add a third child
(define dyn9 (sup-add-child sup9 (lambda (self) (bind (chan-send ch9 :dyn) (lambda (_) (actor-receive))))))
(actor-run #100)
(define kids9 (sup-children sup9))
(define old-a9 (car kids9))
(define old-b9 (car (cdr kids9)))
(define old-dyn9 (car (cdr (cdr kids9))))
; Crash b (middle) — dyn (after b) should also restart
(actor-send old-b9 :crash)
(actor-run #200)
(define kids9b (sup-children sup9))
(define new-a9 (car kids9b))
(define new-b9 (car (cdr kids9b)))
(define new-dyn9 (car (cdr (cdr kids9b))))
(test-case (quote :rest-for-one-dynamic-child)
  #t
  (and (equal? old-a9 new-a9)
     (and (not (equal? old-b9 new-b9))
        (not (equal? old-dyn9 new-dyn9)))))

;;; Test 10: sup-remove then crash — removed child stays gone
(actor-reset)
(define ch10 (chan-create))
(define w10a (lambda (self) (bind (chan-send ch10 :a) (lambda (_) (actor-receive)))))
(define w10b (lambda (self) (bind (chan-send ch10 :b) (lambda (_) (actor-receive)))))
(define w10c (lambda (self)
  (bind (chan-send ch10 :c) (lambda (_)
    (bind (actor-receive) (lambda (msg)
      (if (equal? msg :crash) (error :crashed :c) msg)))))))
(define sup10 (sup-start :one-for-one (cons w10a (cons w10b (cons w10c nil)))))
(actor-run #100)
(define kids10 (sup-children sup10))
(define kid-b10 (car (cdr kids10)))
(define kid-c10 (car (cdr (cdr kids10))))
; Remove b
(sup-remove-child sup10 kid-b10)
; Crash c
(actor-send kid-c10 :crash)
(actor-run #200)
; Should have 2 children now (a and restarted c), b stays gone
(define kids10b (sup-children sup10))
(test-case (quote :sup-remove-then-crash)
  #t
  (and (equal? (cdr (cdr kids10b)) nil)
     (and (actor-alive? (car kids10b))
        (actor-alive? (car (cdr kids10b))))))
