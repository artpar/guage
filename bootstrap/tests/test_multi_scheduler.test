; Test: Multi-Scheduler Deep Stress Tests
; Exhaustive coverage of N:M work-stealing with real worker threads
; Every code path, edge case, suspend reason, and cross-scheduler interaction
;
; NOTE: Trace events are thread-local (per scheduler). Assertions on trace
; counts only see events recorded by the main thread (scheduler 0).
; Multi-scheduler tests therefore focus on outcomes (results, alive status)
; rather than exact trace counts.

; ============ Helpers ============
(define ev-ts     (lambda (ev) (cdr (car ev))))
(define ev-sched  (lambda (ev) (cdr (car (cdr ev)))))
(define ev-actor  (lambda (ev) (cdr (car (cdr (cdr ev))))))
(define ev-kind   (lambda (ev) (cdr (car (cdr (cdr (cdr ev)))))))
(define ev-detail (lambda (ev) (cdr (car (cdr (cdr (cdr (cdr ev))))))))

(define list-len (lambda (xs)
  (if (equal? xs nil) #0
     (+ #1 (list-len (cdr xs))))))

; Helper: sum a list of numbers
(define list-sum (lambda (xs)
  (if (equal? xs nil) #0
     (+ (car xs) (list-sum (cdr xs))))))

; Helper: check all items in list satisfy predicate
(define list-all (lambda (xs pred)
  (if (equal? xs nil) #t
     (if (pred (car xs))
        (list-all (cdr xs) pred)
        #f))))

; Helper: find value in alist by key
(define alist-get (lambda (alist key)
  (if (equal? alist nil) nil
     (if (equal? (car (car alist)) key)
        (cdr (car alist))
        (alist-get (cdr alist) key)))))

; Helper: safe head — returns value itself if not a pair (prevents assert crash)
(define safe-head (lambda (x) (if (error? x) x (if (equal? x nil) nil (car x)))))
(define safe-tail (lambda (x) (if (error? x) x (if (equal? x nil) nil (cdr x)))))

; ============================================================
; Section 1: Basic multi-scheduler activation (3 assertions)
; Verifies sched-count set/get and single actor on 2 schedulers
; ============================================================
(actor-reset)
(chan-reset)
(trace-enable! #t)
(trace-clear)

(sched-count #2)
(test-case (quote :ms-sched-count-2) #2 (sched-count))

(define ms1-a (actor-spawn (lambda (self) :hello-multi)))
(actor-run #500)

(test-case (quote :ms-basic-dead) #f (actor-alive? ms1-a))
(test-case (quote :ms-basic-result) :hello-multi (actor-result ms1-a))

; ============================================================
; Section 2: Work stealing — 8 actors across 2 schedulers (3 assertions)
; Forces work distribution: more actors than schedulers
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define ws-a1 (actor-spawn (lambda (self) :w1)))
(define ws-a2 (actor-spawn (lambda (self) :w2)))
(define ws-a3 (actor-spawn (lambda (self) :w3)))
(define ws-a4 (actor-spawn (lambda (self) :w4)))
(define ws-a5 (actor-spawn (lambda (self) :w5)))
(define ws-a6 (actor-spawn (lambda (self) :w6)))
(define ws-a7 (actor-spawn (lambda (self) :w7)))
(define ws-a8 (actor-spawn (lambda (self) :w8)))
(actor-run #10000)

(test-case (quote :ws-all-dead) #t
  (and (and (not (actor-alive? ws-a1)) (not (actor-alive? ws-a2)))
      (and (not (actor-alive? ws-a5)) (not (actor-alive? ws-a8)))))
(test-case (quote :ws-results-correct) #t
  (and (equal? (actor-result ws-a1) :w1) (equal? (actor-result ws-a8) :w8)))
(test-case (quote :ws-trace-activity) #t (> (trace-count) #0))

; ============================================================
; Section 3: LIFO slot behavior (3 assertions)
; Back-to-back spawns exercise the runnext single-slot
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define lifo-a (actor-spawn (lambda (self) :first)))
(define lifo-b (actor-spawn (lambda (self) :second)))
(actor-run #500)

(test-case (quote :lifo-a-done) #f (actor-alive? lifo-a))
(test-case (quote :lifo-b-done) #f (actor-alive? lifo-b))
(test-case (quote :lifo-resume-events) #t (>= (trace-count :RESUME) #1))

; ============================================================
; Section 4: Global queue + bulk spawn — 20 actors (3 assertions)
; Exercises global Vyukov MPMC overflow queue
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define gq01 (actor-spawn (lambda (self) #1)))
(define gq02 (actor-spawn (lambda (self) #2)))
(define gq03 (actor-spawn (lambda (self) #3)))
(define gq04 (actor-spawn (lambda (self) #4)))
(define gq05 (actor-spawn (lambda (self) #5)))
(define gq06 (actor-spawn (lambda (self) #6)))
(define gq07 (actor-spawn (lambda (self) #7)))
(define gq08 (actor-spawn (lambda (self) #8)))
(define gq09 (actor-spawn (lambda (self) #9)))
(define gq10 (actor-spawn (lambda (self) #10)))
(define gq11 (actor-spawn (lambda (self) #11)))
(define gq12 (actor-spawn (lambda (self) #12)))
(define gq13 (actor-spawn (lambda (self) #13)))
(define gq14 (actor-spawn (lambda (self) #14)))
(define gq15 (actor-spawn (lambda (self) #15)))
(define gq16 (actor-spawn (lambda (self) #16)))
(define gq17 (actor-spawn (lambda (self) #17)))
(define gq18 (actor-spawn (lambda (self) #18)))
(define gq19 (actor-spawn (lambda (self) #19)))
(define gq20 (actor-spawn (lambda (self) #20)))
(actor-run #2000)

(test-case (quote :gq-first) #1 (actor-result gq01))
(test-case (quote :gq-mid) #10 (actor-result gq10))
(test-case (quote :gq-last) #20 (actor-result gq20))

; ============================================================
; Section 5: High actor count stress — 50 actors (3 assertions)
; Saturates deques, forces global queue + stealing
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define h01 (actor-spawn (lambda (self) :ok)))
(define h02 (actor-spawn (lambda (self) :ok)))
(define h03 (actor-spawn (lambda (self) :ok)))
(define h04 (actor-spawn (lambda (self) :ok)))
(define h05 (actor-spawn (lambda (self) :ok)))
(define h06 (actor-spawn (lambda (self) :ok)))
(define h07 (actor-spawn (lambda (self) :ok)))
(define h08 (actor-spawn (lambda (self) :ok)))
(define h09 (actor-spawn (lambda (self) :ok)))
(define h10 (actor-spawn (lambda (self) :ok)))
(define h11 (actor-spawn (lambda (self) :ok)))
(define h12 (actor-spawn (lambda (self) :ok)))
(define h13 (actor-spawn (lambda (self) :ok)))
(define h14 (actor-spawn (lambda (self) :ok)))
(define h15 (actor-spawn (lambda (self) :ok)))
(define h16 (actor-spawn (lambda (self) :ok)))
(define h17 (actor-spawn (lambda (self) :ok)))
(define h18 (actor-spawn (lambda (self) :ok)))
(define h19 (actor-spawn (lambda (self) :ok)))
(define h20 (actor-spawn (lambda (self) :ok)))
(define h21 (actor-spawn (lambda (self) :ok)))
(define h22 (actor-spawn (lambda (self) :ok)))
(define h23 (actor-spawn (lambda (self) :ok)))
(define h24 (actor-spawn (lambda (self) :ok)))
(define h25 (actor-spawn (lambda (self) :ok)))
(define h26 (actor-spawn (lambda (self) :ok)))
(define h27 (actor-spawn (lambda (self) :ok)))
(define h28 (actor-spawn (lambda (self) :ok)))
(define h29 (actor-spawn (lambda (self) :ok)))
(define h30 (actor-spawn (lambda (self) :ok)))
(define h31 (actor-spawn (lambda (self) :ok)))
(define h32 (actor-spawn (lambda (self) :ok)))
(define h33 (actor-spawn (lambda (self) :ok)))
(define h34 (actor-spawn (lambda (self) :ok)))
(define h35 (actor-spawn (lambda (self) :ok)))
(define h36 (actor-spawn (lambda (self) :ok)))
(define h37 (actor-spawn (lambda (self) :ok)))
(define h38 (actor-spawn (lambda (self) :ok)))
(define h39 (actor-spawn (lambda (self) :ok)))
(define h40 (actor-spawn (lambda (self) :ok)))
(define h41 (actor-spawn (lambda (self) :ok)))
(define h42 (actor-spawn (lambda (self) :ok)))
(define h43 (actor-spawn (lambda (self) :ok)))
(define h44 (actor-spawn (lambda (self) :ok)))
(define h45 (actor-spawn (lambda (self) :ok)))
(define h46 (actor-spawn (lambda (self) :ok)))
(define h47 (actor-spawn (lambda (self) :ok)))
(define h48 (actor-spawn (lambda (self) :ok)))
(define h49 (actor-spawn (lambda (self) :ok)))
(define h50 (actor-spawn (lambda (self) :ok)))
(actor-run #10000)

(test-case (quote :stress-50-first) #f (actor-alive? h01))
(test-case (quote :stress-50-mid) #f (actor-alive? h25))
(test-case (quote :stress-50-last) #f (actor-alive? h50))

; ============================================================
; Section 6: Message passing across schedulers (3 assertions)
; SUSPEND_MAILBOX path: sender→receiver cross-thread
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define pong-a (actor-spawn (lambda (self) (actor-receive))))
(define ping-a (actor-spawn (lambda (self)
  (bind (actor-send pong-a :ping) (lambda (_)
    (bind (actor-send pong-a :pong2) (lambda (_)
      :sent-both)))))))
(actor-run #500)

(test-case (quote :pingpong-result) :ping (actor-result pong-a))
(test-case (quote :pingpong-sender-done) #f (actor-alive? ping-a))
(test-case (quote :pingpong-send-trace) #t (>= (trace-count :SEND) #1))

; ============================================================
; Section 7: Channel contention — 4 producers, 1 consumer (3 assertions)
; SUSPEND_CHAN_SEND + SUSPEND_CHAN_RECV across schedulers
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define cch (chan-create #8))

(define cp1 (actor-spawn (lambda (self)
  (bind (chan-send cch #25) (lambda (_) :p1)))))
(define cp2 (actor-spawn (lambda (self)
  (bind (chan-send cch #25) (lambda (_) :p2)))))
(define cp3 (actor-spawn (lambda (self)
  (bind (chan-send cch #25) (lambda (_) :p3)))))
(define cp4 (actor-spawn (lambda (self)
  (bind (chan-send cch #25) (lambda (_) :p4)))))

(define ccons (actor-spawn (lambda (self)
  (bind (chan-recv cch) (lambda (v1)
  (bind (chan-recv cch) (lambda (v2)
  (bind (chan-recv cch) (lambda (v3)
  (bind (chan-recv cch) (lambda (v4)
    (+ (+ v1 v2) (+ v3 v4)))))))))))))
(actor-run #10000)

(test-case (quote :chan-contention-sum) #100 (actor-result ccons))
(test-case (quote :chan-contention-producers-done) #t
  (and (not (actor-alive? cp1)) (not (actor-alive? cp4))))
(test-case (quote :chan-contention-trace) #t (> (trace-count) #0))

; ============================================================
; Section 8: Reduction preemption fairness (3 assertions)
; SUSPEND_REDUCTION: long-running vs fast actor
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define long-runner (actor-spawn (lambda (self)
  (bind (actor-send self :tick) (lambda (_)
  (bind (actor-receive) (lambda (_)
  (bind (actor-send self :tick) (lambda (_)
  (bind (actor-receive) (lambda (_)
  (bind (actor-send self :tick) (lambda (_)
  (bind (actor-receive) (lambda (_)
    :long-done)))))))))))))))

(define fast-actor (actor-spawn (lambda (self) :fast-done)))
(actor-run #2000)

(test-case (quote :preempt-fast-done) #f (actor-alive? fast-actor))
(test-case (quote :preempt-fast-result) :fast-done (actor-result fast-actor))
(test-case (quote :preempt-long-done) #f (actor-alive? long-runner))

; ============================================================
; Section 9: Scheduler statistics deep inspection (5 assertions)
; Validates sched-stats output structure and stat fields
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define st1 (actor-spawn (lambda (self) :s1)))
(define st2 (actor-spawn (lambda (self) :s2)))
(define st3 (actor-spawn (lambda (self) :s3)))
(define st4 (actor-spawn (lambda (self) :s4)))
(actor-run #500)

(define stats (sched-stats))
(test-case (quote :stats-nonempty) #t (not (equal? stats nil)))
(test-case (quote :stats-has-2-entries) #t (>= (list-len stats) #2))
(test-case (quote :stats-sched0-id) #0 (car (car stats)))
; Scheduler 0 reductions > 0
(define s0-alist (cdr (car stats)))
(define s0-reds (cdr (car (cdr (cdr s0-alist)))))
(test-case (quote :stats-reds-gt0) #t (> s0-reds #0))
; Second scheduler entry exists with id=1
(test-case (quote :stats-sched1-id) #1 (car (car (cdr stats))))

; ============================================================
; Section 10: Trace fidelity under load (4 assertions)
; Main thread trace ring buffer correctness
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define tf01 (actor-spawn (lambda (self) :t1)))
(define tf02 (actor-spawn (lambda (self) :t2)))
(define tf03 (actor-spawn (lambda (self) :t3)))
(define tf04 (actor-spawn (lambda (self) :t4)))
(define tf05 (actor-spawn (lambda (self) :t5)))
(define tf06 (actor-spawn (lambda (self) :t6)))
(define tf07 (actor-spawn (lambda (self) :t7)))
(define tf08 (actor-spawn (lambda (self) :t8)))
(define tf09 (actor-spawn (lambda (self) :t9)))
(define tf10 (actor-spawn (lambda (self) :t10)))
(actor-run #10000)

(test-case (quote :trace-fid-spawn) #t (>= (trace-count :SPAWN) #1))
(test-case (quote :trace-fid-die) #t (>= (trace-count :DIE) #1))
(test-case (quote :trace-fid-total) #t (> (trace-count) #0))
(define snap-all (trace-snapshot))
(test-case (quote :trace-fid-snap) #t (not (equal? snap-all nil)))

; ============================================================
; Section 11: Monitor across schedulers (3 assertions)
; actor_notify_exit sends :DOWN to watcher on potentially different scheduler
; Tests: (:DOWN actor-id :normal) message structure
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define mon-child (actor-spawn (lambda (self) :normal-exit)))
(define mon-parent (actor-spawn (lambda (self)
  (bind (actor-monitor mon-child) (lambda (_)
    (actor-receive))))))
(actor-run #10000)

(define mon-result (actor-result mon-parent))
(test-case (quote :monitor-down-tag) :DOWN (safe-head mon-result))
(test-case (quote :monitor-down-reason) :normal (safe-head (safe-tail (safe-tail mon-result))))
; Parent finished (got the DOWN message and exited)
(test-case (quote :monitor-parent-dead) #f (actor-alive? mon-parent))

; ============================================================
; Section 12: Link death propagation across schedulers (2 assertions)
; actor_exit_signal kills linked actor without trap-exit
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define link-child (actor-spawn (lambda (self)
  (bind (actor-receive) (lambda (msg)
    (error :crash :boom))))))
(define link-parent (actor-spawn (lambda (self)
  (bind (actor-link link-child) (lambda (_)
    (bind (actor-send link-child :die) (lambda (_)
      (actor-receive))))))))
(actor-run #10000)

(test-case (quote :link-parent-dead) #f (actor-alive? link-parent))
(test-case (quote :link-child-dead) #f (actor-alive? link-child))

; ============================================================
; Section 13: Link with trap-exit across schedulers (3 assertions)
; actor-trap-exit converts exit signal to :EXIT message instead of killing
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define trap-child (actor-spawn (lambda (self)
  (bind (actor-receive) (lambda (msg) (error :intentional :crash))))))
(define trap-parent (actor-spawn (lambda (self)
  (bind (actor-trap-exit #t) (lambda (_)
  (bind (actor-link trap-child) (lambda (_)
  (bind (actor-send trap-child :go) (lambda (_)
    (actor-receive))))))))))
(actor-run #10000)

; Parent should be dead (finished) — received :EXIT as message
(test-case (quote :trap-parent-dead) #f (actor-alive? trap-parent))
; Parent result is the :EXIT message — ⟨:EXIT child-id error⟩
(define trap-result (actor-result trap-parent))
(test-case (quote :trap-exit-tag) :EXIT (safe-head trap-result))
; Child crashed
(test-case (quote :trap-child-dead) #f (actor-alive? trap-child))

; ============================================================
; Section 14: Unlink prevents death propagation (2 assertions)
; actor-unlink removes bidirectional link
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define unl-child (actor-spawn (lambda (self)
  (bind (actor-receive) (lambda (_) (error :crash :unlinktest))))))
(define unl-parent (actor-spawn (lambda (self)
  (bind (actor-link unl-child) (lambda (_)
  (bind (actor-unlink unl-child) (lambda (_)
  (bind (actor-send unl-child :die) (lambda (_)
    (actor-receive))))))))))
(actor-run #10000)

; Parent should be alive — still waiting for message, unlinked from child crash
(test-case (quote :unlink-parent-alive) #t (actor-alive? unl-parent))
; Child is dead (crashed)
(test-case (quote :unlink-child-dead) #f (actor-alive? unl-child))

; ============================================================
; Section 15: Exit signal across schedulers (2 assertions)
; actor-exit sends exit signal to actor (like Erlang exit/2)
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define exit-victim (actor-spawn (lambda (self) (actor-receive))))
(define exit-sender (actor-spawn (lambda (self)
  (actor-exit exit-victim :killed))))
(actor-run #500)

(test-case (quote :exit-victim-dead) #f (actor-alive? exit-victim))
(test-case (quote :exit-sender-done) #f (actor-alive? exit-sender))

; ============================================================
; Section 16: Channel close while actor suspended (3 assertions)
; SUSPEND_CHAN_RECV -> channel closed -> error resume
; Tests sched_prepare_resume chan-recv-closed path
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define close-ch (chan-create #4))
; Reader blocks on empty channel
(define close-reader (actor-spawn (lambda (self) (chan-recv close-ch))))
; Closer closes the channel after a brief delay
(define close-closer (actor-spawn (lambda (self)
  (bind (actor-send self :tick) (lambda (_)
  (bind (actor-receive) (lambda (_)
    (chan-close close-ch))))))))
(actor-run #10000)

; Reader should get error (chan-recv-closed)
(test-case (quote :close-reader-dead) #f (actor-alive? close-reader))
(define close-result (actor-result close-reader))
(test-case (quote :close-reader-error) #t (error? close-result))
; Closer completed
(test-case (quote :close-closer-done) #f (actor-alive? close-closer))

; ============================================================
; Section 17: Channel send blocking (3 assertions)
; SUSPEND_CHAN_SEND: capacity-1 channel, send blocks until consumed
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define tiny-ch (chan-create #1))
; Sender sends 3 values — blocks after first since capacity=1
(define blk-sender (actor-spawn (lambda (self)
  (bind (chan-send tiny-ch #10) (lambda (_)
  (bind (chan-send tiny-ch #20) (lambda (_)
  (bind (chan-send tiny-ch #30) (lambda (_)
    :sent-all)))))))))
; Reader reads 3 values
(define blk-reader (actor-spawn (lambda (self)
  (bind (chan-recv tiny-ch) (lambda (v1)
  (bind (chan-recv tiny-ch) (lambda (v2)
  (bind (chan-recv tiny-ch) (lambda (v3)
    (+ v1 (+ v2 v3)))))))))))
(actor-run #10000)

(test-case (quote :chsend-sender-done) #f (actor-alive? blk-sender))
(test-case (quote :chsend-sender-result) :sent-all (actor-result blk-sender))
(test-case (quote :chsend-reader-sum) #60 (actor-result blk-reader))

; ============================================================
; Section 18: Select across schedulers (3 assertions)
; chan-select blocks on multiple channels, wakes when data arrives
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define sel-ch1 (chan-create #4))
(define sel-ch2 (chan-create #4))
; Consumer does blocking select on both channels
(define sel-cons (actor-spawn (lambda (self) (chan-select sel-ch1 sel-ch2))))
; Producer sends to ch2 (ch1 stays empty)
(define sel-prod (actor-spawn (lambda (self) (chan-send sel-ch2 :from-ch2))))
(actor-run #10000)

(test-case (quote :select-cons-done) #f (actor-alive? sel-cons))
; Select result is ⟨channel value⟩ — value should be :from-ch2
(define sel-result (actor-result sel-cons))
(test-case (quote :select-value) :from-ch2 (safe-tail sel-result))
(test-case (quote :select-prod-done) #f (actor-alive? sel-prod))

; ============================================================
; Section 19: Timer delivery across schedulers (3 assertions)
; timer-send-after fires timer message to actor on potentially different scheduler
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
; Target waits for timer message
(define timer-target (actor-spawn (lambda (self) (actor-receive))))
; Spawner creates timer and exits
(define timer-spawner (actor-spawn (lambda (self)
  (timer-send-after #10 timer-target :timer-fired))))
(actor-run #500)

(test-case (quote :timer-target-done) #f (actor-alive? timer-target))
(test-case (quote :timer-target-result) :timer-fired (actor-result timer-target))
; Timer spawner should have returned the timer ID
(test-case (quote :timer-spawner-done) #f (actor-alive? timer-spawner))

; ============================================================
; Section 20: Timer cancel across schedulers (2 assertions)
; timer-cancel cancels a pending timer before it fires
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define cancel-target (actor-spawn (lambda (self) (actor-receive))))
; Create timer with long delay, then cancel it
(define cancel-actor (actor-spawn (lambda (self)
  (bind (timer-send-after #9999 cancel-target :never) (lambda (tid)
    (timer-cancel tid))))))
(actor-run #500)

; Target should still be alive (timer was cancelled, no message sent)
(test-case (quote :cancel-target-alive) #t (actor-alive? cancel-target))
; Canceller completed
(test-case (quote :cancel-actor-done) #f (actor-alive? cancel-actor))

; ============================================================
; Section 21: Task-await across schedulers (3 assertions)
; SUSPEND_TASK_AWAIT: actor waits for another to finish
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define task-worker (actor-spawn (lambda (self) #42)))
(define task-waiter (actor-spawn (lambda (self)
  (bind (task-await task-worker) (lambda (result)
    (+ result #8))))))
(actor-run #500)

(test-case (quote :await-worker-done) #f (actor-alive? task-worker))
(test-case (quote :await-waiter-done) #f (actor-alive? task-waiter))
(test-case (quote :await-waiter-result) #50 (actor-result task-waiter))

; ============================================================
; Section 22: Process dictionary across schedulers (4 assertions)
; proc-dict-put / proc-dict-get inside actors on multi-scheduler
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
; Actor stores value in its own process dictionary
(define dict-actor (actor-spawn (lambda (self)
  (bind (proc-dict-put :mykey #999) (lambda (_)
    (proc-dict-get :mykey))))))
(actor-run #500)

(test-case (quote :dict-actor-done) #f (actor-alive? dict-actor))
(test-case (quote :dict-actor-result) #999 (actor-result dict-actor))

; Two actors with independent dictionaries
(define dict-a (actor-spawn (lambda (self)
  (bind (proc-dict-put :x #111) (lambda (_) (proc-dict-get :x))))))
(define dict-b (actor-spawn (lambda (self)
  (bind (proc-dict-put :x #222) (lambda (_) (proc-dict-get :x))))))
(actor-run #500)

(test-case (quote :dict-isolation-a) #111 (actor-result dict-a))
(test-case (quote :dict-isolation-b) #222 (actor-result dict-b))

; ============================================================
; Section 23: Registry across schedulers (4 assertions)
; registry-register / registry-whereis name resolution when actors on different schedulers
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define reg-server (actor-spawn (lambda (self) (actor-receive))))
(registry-register :my-server reg-server)

; Verify lookup works before actors run
(define reg-found (registry-whereis :my-server))
(test-case (quote :reg-lookup-works) #t (not (equal? reg-found nil)))

; Client looks up server by name and sends message
(define reg-client (actor-spawn (lambda (self)
  (bind (registry-whereis :my-server) (lambda (srv)
    (bind (actor-send srv :hello-from-client) (lambda (_)
      :client-done)))))))
(actor-run #500)

; Server received the message
(test-case (quote :reg-server-done) #f (actor-alive? reg-server))
(test-case (quote :reg-server-result) :hello-from-client (actor-result reg-server))
; Client completed
(test-case (quote :reg-client-done) #f (actor-alive? reg-client))

; ============================================================
; Section 24: Multiple messages FIFO ordering (2 assertions)
; Mailbox Vyukov MPMC preserves order from single sender
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define fifo-recv (actor-spawn (lambda (self)
  (bind (actor-receive) (lambda (v1)
  (bind (actor-receive) (lambda (v2)
  (bind (actor-receive) (lambda (v3)
    (cons v1 (cons v2 (cons v3 nil))))))))))))
(define fifo-send (actor-spawn (lambda (self)
  (bind (actor-send fifo-recv :first) (lambda (_)
  (bind (actor-send fifo-recv :second) (lambda (_)
  (bind (actor-send fifo-recv :third) (lambda (_)
    :sent)))))))))
(actor-run #500)

(define fifo-result (actor-result fifo-recv))
(test-case (quote :fifo-first) :first (safe-head fifo-result))
(test-case (quote :fifo-third) :third (safe-head (safe-tail (safe-tail fifo-result))))

; ============================================================
; Section 25: Supervisor one-for-one across schedulers (3 assertions)
; Supervisor restarts crashed child on multi-scheduler
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
; Two child behaviors: first crashes, second is stable
(define sup-id (sup-start :one-for-one
  (cons (lambda (self) (bind (actor-receive) (lambda (_) (error :crash :sup-test))))
  (cons (lambda (self) (actor-receive))
    nil))))
(actor-run #200)

; Get children before crash
(define sup-kids-before (sup-children sup-id))
(define kid1-before (car sup-kids-before))

; Send message to first child to trigger crash
(actor-send kid1-before :crash-now)
(actor-run #500)

; After restart, child count should still be 2
(define sup-kids-after (sup-children sup-id))
(test-case (quote :sup-child-count) #2 (list-len sup-kids-after))
; Restart count should be >= 1
(test-case (quote :sup-restart-count) #t (>= (sup-restart-count sup-id) #1))
; New first child is different from crashed one (new actor)
(define kid1-after (car sup-kids-after))
(test-case (quote :sup-new-child) #t (not (equal? kid1-before kid1-after)))

; ============================================================
; Section 26: Dynamic supervisor across schedulers (3 assertions)
; dynsup-start creates empty supervisor, dynsup-start-child adds children dynamically
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define dsup-id (dynsup-start))
; Start children dynamically — all permanent, all block on receive
(dynsup-start-child dsup-id (lambda (self) (actor-receive)) :permanent)
(dynsup-start-child dsup-id (lambda (self) (actor-receive)) :permanent)
(dynsup-start-child dsup-id (lambda (self) (actor-receive)) :permanent)
(actor-run #500)

(test-case (quote :dynsup-count) #3 (dynsup-count dsup-id))
(define dkids (dynsup-which-children dsup-id))
(test-case (quote :dynsup-has-children) #t (> (list-len dkids) #0))
; Terminate one child
(dynsup-terminate-child dsup-id (car (car dkids)))
(actor-run #200)
(test-case (quote :dynsup-after-term) #2 (dynsup-count dsup-id))

; ============================================================
; Section 27: Multi-round message exchange (2 assertions)
; Actor sends and receives multiple rounds — tests continuation
; persistence across scheduler switches (saved_continuation)
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
; Echo server: receives message, sends it back incremented
(define echo-srv (actor-spawn (lambda (self)
  (bind (actor-receive) (lambda (req)
    (bind (actor-send (car req) (+ (cdr req) #1)) (lambda (_)
    (bind (actor-receive) (lambda (req2)
      (bind (actor-send (car req2) (+ (cdr req2) #1)) (lambda (_)
        :echo-done)))))))))))
; Client sends request, gets response, sends again
(define echo-cli (actor-spawn (lambda (self)
  (bind (actor-send echo-srv (cons self #10)) (lambda (_)
  (bind (actor-receive) (lambda (r1)
  (bind (actor-send echo-srv (cons self r1)) (lambda (_)
  (bind (actor-receive) (lambda (r2)
    r2)))))))))))
(actor-run #10000)

(test-case (quote :echo-final-result) #12 (actor-result echo-cli))
(test-case (quote :echo-srv-done) #f (actor-alive? echo-srv))

; ============================================================
; Section 28: Graceful termination with results (8 assertions)
; Validates all actors finish + correct results + stats post-shutdown
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define gt1 (actor-spawn (lambda (self) :g1)))
(define gt2 (actor-spawn (lambda (self) :g2)))
(define gt3 (actor-spawn (lambda (self) :g3)))
(actor-run #500)

(test-case (quote :grace-a1-dead) #f (actor-alive? gt1))
(test-case (quote :grace-a2-dead) #f (actor-alive? gt2))
(test-case (quote :grace-a3-dead) #f (actor-alive? gt3))
(test-case (quote :grace-a1-result) :g1 (actor-result gt1))
(test-case (quote :grace-a2-result) :g2 (actor-result gt2))
(test-case (quote :grace-a3-result) :g3 (actor-result gt3))
(test-case (quote :grace-trace-gt0) #t (> (trace-count) #0))
(define post-stats (sched-stats))
(test-case (quote :grace-stats-exist) #t (not (equal? post-stats nil)))

; ============================================================
; Section 29: Scale to 4 schedulers (5 assertions)
; Tests sched-count with N=4, 4 stat entries, actor completion
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #4)
(test-case (quote :scale4-count) #4 (sched-count))

(define sc4-a (actor-spawn (lambda (self) :four-sched)))
(define sc4-b (actor-spawn (lambda (self) :four-sched2)))
(define sc4-c (actor-spawn (lambda (self) :four-sched3)))
(define sc4-d (actor-spawn (lambda (self) :four-sched4)))
(actor-run #10000)

(test-case (quote :scale4-a-done) :four-sched (actor-result sc4-a))
(test-case (quote :scale4-d-done) :four-sched4 (actor-result sc4-d))
(define s4-stats (sched-stats))
(test-case (quote :scale4-stats-len) #4 (list-len s4-stats))
; Last scheduler entry has id=3
(define s4-last (car (cdr (cdr (cdr s4-stats)))))
(test-case (quote :scale4-last-sched-id) #3 (car s4-last))

; ============================================================
; Section 30: Scale to 4 schedulers with channels + messages (3 assertions)
; Cross-scheduler communication at higher scheduler counts
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #4)
(define sc4ch (chan-create #16))
; 4 producers, 1 consumer
(define sc4p1 (actor-spawn (lambda (self) (bind (chan-send sc4ch #10) (lambda (_) :sp1)))))
(define sc4p2 (actor-spawn (lambda (self) (bind (chan-send sc4ch #20) (lambda (_) :sp2)))))
(define sc4p3 (actor-spawn (lambda (self) (bind (chan-send sc4ch #30) (lambda (_) :sp3)))))
(define sc4p4 (actor-spawn (lambda (self) (bind (chan-send sc4ch #40) (lambda (_) :sp4)))))
(define sc4c (actor-spawn (lambda (self)
  (bind (chan-recv sc4ch) (lambda (v1)
  (bind (chan-recv sc4ch) (lambda (v2)
  (bind (chan-recv sc4ch) (lambda (v3)
  (bind (chan-recv sc4ch) (lambda (v4)
    (+ (+ v1 v2) (+ v3 v4)))))))))))))
(actor-run #10000)

(test-case (quote :sc4-chan-sum) #100 (actor-result sc4c))
(test-case (quote :sc4-all-prods-done) #t
  (and (and (not (actor-alive? sc4p1)) (not (actor-alive? sc4p2)))
      (and (not (actor-alive? sc4p3)) (not (actor-alive? sc4p4)))))
(test-case (quote :sc4-consumer-done) #f (actor-alive? sc4c))

; ============================================================
; Section 31: Back to single scheduler (2 assertions)
; Downscale from 4→1, verify no stale state
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #1)
(test-case (quote :back-single-count) #1 (sched-count))

(define single-a (actor-spawn (lambda (self) :back-to-one)))
(actor-run #200)

(test-case (quote :back-single-result) :back-to-one (actor-result single-a))

; ============================================================
; Section 32: Re-scale after downscale (3 assertions)
; 1→2 after having been 4→1, tests scheduler reinitialization
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define rescale-a (actor-spawn (lambda (self) :rescaled-ok)))
(define rescale-b (actor-spawn (lambda (self) :rescaled-ok2)))
(actor-run #500)

(test-case (quote :rescale-count) #2 (sched-count))
(test-case (quote :rescale-a-result) :rescaled-ok (actor-result rescale-a))
(test-case (quote :rescale-b-result) :rescaled-ok2 (actor-result rescale-b))

; ============================================================
; Section 33: Multiple lifecycle cycles — repeated init/run/drain (2 assertions)
; Exercises the queue drain fix: repeated sched_run_all + actor_reset_all
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

; Cycle through 5 create-run-reset cycles on 2 schedulers
(sched-count #2)
(define cyc1 (actor-spawn (lambda (self) :c1)))
(actor-run #200)
(actor-reset)

(sched-count #2)
(define cyc2 (actor-spawn (lambda (self) :c2)))
(actor-run #200)
(actor-reset)

(sched-count #2)
(define cyc3 (actor-spawn (lambda (self) :c3)))
(actor-run #200)
(actor-reset)

(sched-count #2)
(define cyc4 (actor-spawn (lambda (self) :c4)))
(actor-run #200)
(actor-reset)

(sched-count #2)
(define cyc5 (actor-spawn (lambda (self) :c5)))
(actor-run #200)

; Last cycle's actor should have correct result
(test-case (quote :lifecycle-cycle5) :c5 (actor-result cyc5))
(test-case (quote :lifecycle-cycle5-dead) #f (actor-alive? cyc5))

; ============================================================
; Section 34: Rapid lifecycle — 10 cycles with channels (2 assertions)
; Stresses the queue drain with channel operations each cycle
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define rc1ch (chan-create #2))
(define rc1a (actor-spawn (lambda (self) (bind (chan-send rc1ch #1) (lambda (_) (chan-recv rc1ch))))))
(actor-run #300)
(actor-reset) (chan-reset)

(sched-count #2)
(define rc2ch (chan-create #2))
(define rc2a (actor-spawn (lambda (self) (bind (chan-send rc2ch #2) (lambda (_) (chan-recv rc2ch))))))
(actor-run #300)
(actor-reset) (chan-reset)

(sched-count #2)
(define rc3ch (chan-create #2))
(define rc3a (actor-spawn (lambda (self) (bind (chan-send rc3ch #3) (lambda (_) (chan-recv rc3ch))))))
(actor-run #300)
(actor-reset) (chan-reset)

(sched-count #2)
(define rc4ch (chan-create #2))
(define rc4a (actor-spawn (lambda (self) (bind (chan-send rc4ch #4) (lambda (_) (chan-recv rc4ch))))))
(actor-run #300)
(actor-reset) (chan-reset)

(sched-count #2)
(define rc5ch (chan-create #2))
(define rc5a (actor-spawn (lambda (self) (bind (chan-send rc5ch #5) (lambda (_) (chan-recv rc5ch))))))
(actor-run #300)
(actor-reset) (chan-reset)

(sched-count #2)
(define rc6ch (chan-create #2))
(define rc6a (actor-spawn (lambda (self) (bind (chan-send rc6ch #6) (lambda (_) (chan-recv rc6ch))))))
(actor-run #300)
(actor-reset) (chan-reset)

(sched-count #2)
(define rc7ch (chan-create #2))
(define rc7a (actor-spawn (lambda (self) (bind (chan-send rc7ch #7) (lambda (_) (chan-recv rc7ch))))))
(actor-run #300)
(actor-reset) (chan-reset)

(sched-count #2)
(define rc8ch (chan-create #2))
(define rc8a (actor-spawn (lambda (self) (bind (chan-send rc8ch #8) (lambda (_) (chan-recv rc8ch))))))
(actor-run #300)
(actor-reset) (chan-reset)

(sched-count #2)
(define rc9ch (chan-create #2))
(define rc9a (actor-spawn (lambda (self) (bind (chan-send rc9ch #9) (lambda (_) (chan-recv rc9ch))))))
(actor-run #300)
(actor-reset) (chan-reset)

(sched-count #2)
(define rc10ch (chan-create #2))
(define rc10a (actor-spawn (lambda (self) (bind (chan-send rc10ch #10) (lambda (_) (chan-recv rc10ch))))))
(actor-run #300)

(test-case (quote :rapid-chan-result) #10 (actor-result rc10a))
(test-case (quote :rapid-chan-dead) #f (actor-alive? rc10a))

; ============================================================
; Section 35: Mixed workload — actors + channels + messages + monitor (4 assertions)
; All suspend reasons in one run
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define mix-ch (chan-create #4))
; Actor 3: message receiver (defined first so cons can reference it)
(define mix-waiter (actor-spawn (lambda (self) (actor-receive))))
; Actor 4: monitors mix-waiter
(define mix-monitor (actor-spawn (lambda (self)
  (bind (actor-monitor mix-waiter) (lambda (_) (actor-receive))))))
; Actor 1: channel producer
(define mix-prod (actor-spawn (lambda (self)
  (bind (chan-send mix-ch #77) (lambda (_) :prod-done)))))
; Actor 2: channel consumer + message sender
(define mix-cons (actor-spawn (lambda (self)
  (bind (chan-recv mix-ch) (lambda (val)
    (bind (actor-send mix-waiter val) (lambda (_)
      :cons-done)))))))
(actor-run #10000)

(test-case (quote :mix-prod-done) #f (actor-alive? mix-prod))
(test-case (quote :mix-waiter-result) #77 (actor-result mix-waiter))
(test-case (quote :mix-cons-done) #f (actor-alive? mix-cons))
; Monitor received :DOWN after waiter exited
(define mix-mon-result (actor-result mix-monitor))
(test-case (quote :mix-monitor-down) :DOWN (safe-head mix-mon-result))

; ============================================================
; Section 36: Chain of monitors — A monitors B monitors C (3 assertions)
; Tests cascading :DOWN messages through monitor chain
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define chain-c (actor-spawn (lambda (self) :chain-end)))
(define chain-b (actor-spawn (lambda (self)
  (bind (actor-monitor chain-c) (lambda (_)
    (actor-receive))))))
(define chain-a (actor-spawn (lambda (self)
  (bind (actor-monitor chain-b) (lambda (_)
    (actor-receive))))))
(actor-run #10000)

; C finishes -> B gets :DOWN -> B finishes -> A gets :DOWN
(test-case (quote :chain-c-dead) #f (actor-alive? chain-c))
(test-case (quote :chain-b-dead) #f (actor-alive? chain-b))
(test-case (quote :chain-a-dead) #f (actor-alive? chain-a))

; ============================================================
; Section 37: Chain of links — crash propagation through 3 actors (3 assertions)
; A linked to B linked to C, C crashes -> all die
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define lc-c (actor-spawn (lambda (self)
  (bind (actor-receive) (lambda (_) (error :chain-crash :lc))))))
(define lc-b (actor-spawn (lambda (self)
  (bind (actor-link lc-c) (lambda (_) (actor-receive))))))
(define lc-a (actor-spawn (lambda (self)
  (bind (actor-link lc-b) (lambda (_) (actor-receive))))))
; Trigger crash
(actor-send lc-c :crash-now)
(actor-run #10000)

(test-case (quote :lc-c-dead) #f (actor-alive? lc-c))
(test-case (quote :lc-b-dead) #f (actor-alive? lc-b))
(test-case (quote :lc-a-dead) #f (actor-alive? lc-a))

; ============================================================
; Section 38: Actor error result across schedulers (2 assertions)
; Actor that returns error value — result is an error cell
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define err-actor (actor-spawn (lambda (self) (error :my-error :details))))
(actor-run #500)

(test-case (quote :err-actor-dead) #f (actor-alive? err-actor))
(test-case (quote :err-actor-is-error) #t (error? (actor-result err-actor)))

; ============================================================
; Section 39: Self-send across schedulers (2 assertions)
; Actor sends message to itself — tests mailbox + continuation
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define self-actor (actor-spawn (lambda (self)
  (bind (actor-send self :self-msg) (lambda (_)
    (actor-receive))))))
(actor-run #500)

(test-case (quote :self-send-done) #f (actor-alive? self-actor))
(test-case (quote :self-send-result) :self-msg (actor-result self-actor))

; ============================================================
; Section 40: Large message body across schedulers (2 assertions)
; Tests ref-counting correctness for large nested structures
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
; Build a deeply nested list
(define big-msg (cons #1 (cons #2 (cons #3 (cons #4 (cons #5
  (cons #6 (cons #7 (cons #8 (cons #9 (cons #10 nil)))))))))))

(define big-recv (actor-spawn (lambda (self) (actor-receive))))
(define big-send (actor-spawn (lambda (self)
  (actor-send big-recv big-msg))))
(actor-run #500)

(define big-result (actor-result big-recv))
(test-case (quote :big-msg-head) #1 (safe-head big-result))
(test-case (quote :big-msg-deep) #10 (safe-head (safe-tail (safe-tail (safe-tail (safe-tail (safe-tail (safe-tail (safe-tail (safe-tail (safe-tail big-result)))))))))))

; ============================================================
; Section 41: Concurrent channel readers (2 assertions)
; 2 readers on same channel — each gets one value
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define shared-ch (chan-create #4))
; 2 readers
(define cr1 (actor-spawn (lambda (self) (chan-recv shared-ch))))
(define cr2 (actor-spawn (lambda (self) (chan-recv shared-ch))))
; 2 writers
(define cw1 (actor-spawn (lambda (self) (chan-send shared-ch :val-a))))
(define cw2 (actor-spawn (lambda (self) (chan-send shared-ch :val-b))))
(actor-run #500)

; Both readers got a value (could be either :val-a or :val-b)
(test-case (quote :conc-reader1-done) #f (actor-alive? cr1))
(test-case (quote :conc-reader2-done) #f (actor-alive? cr2))

; ============================================================
; Section 42: Zero-tick budget (edge case) (2 assertions)
; actor-run #0 should return immediately, actors stay alive
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define zero-a (actor-spawn (lambda (self) :never)))
(actor-run #0)
; Actor should still be alive — no ticks were given
(test-case (quote :zero-tick-alive) #t (actor-alive? zero-a))
; Now give it real ticks
(actor-run #500)
(test-case (quote :zero-tick-then-run) :never (actor-result zero-a))

; ============================================================
; Section 43: Starvation guard — LIFO consecutive limit (2 assertions)
; After 3 consecutive LIFO pops, scheduler falls back to deque
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
; Spawn 6 actors — more than 3 consecutive LIFO limit
(define sg1 (actor-spawn (lambda (self) :sg1)))
(define sg2 (actor-spawn (lambda (self) :sg2)))
(define sg3 (actor-spawn (lambda (self) :sg3)))
(define sg4 (actor-spawn (lambda (self) :sg4)))
(define sg5 (actor-spawn (lambda (self) :sg5)))
(define sg6 (actor-spawn (lambda (self) :sg6)))
(actor-run #500)

; All complete despite starvation guard cycling
(test-case (quote :starve-all-done) #t
  (and (and (not (actor-alive? sg1)) (not (actor-alive? sg3)))
      (and (not (actor-alive? sg5)) (not (actor-alive? sg6)))))
(test-case (quote :starve-results) #t
  (and (equal? (actor-result sg1) :sg1) (equal? (actor-result sg6) :sg6)))

; ============================================================
; Section 44: Actor result after multi-round yield (2 assertions)
; Actor yields multiple times (SUSPEND_REDUCTION) before finishing
; Tests saved_continuation correctness
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
; Compute fibonacci (recursive, burns reductions, causes yields)
(define fib (lambda (n)
  (if (<= n #1) n
     (+ (fib (- n #1)) (fib (- n #2))))))
(define fib-actor (actor-spawn (lambda (self) (fib #10))))
(actor-run #10000)

(test-case (quote :fib-done) #f (actor-alive? fib-actor))
(test-case (quote :fib-result) #55 (actor-result fib-actor))

; ============================================================
; Section 45: Multiple schedulers with monitor + link + channel (4 assertions)
; Kitchen-sink test: all concurrency features in one run
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define ks-ch (chan-create #4))

; Worker: reads from channel, sends to parent
(define ks-worker (actor-spawn (lambda (self)
  (bind (chan-recv ks-ch) (lambda (job)
    job)))))

; Monitor: watches worker
(define ks-watcher (actor-spawn (lambda (self)
  (bind (actor-monitor ks-worker) (lambda (_)
    (actor-receive))))))

; Driver: sends job via channel
(define ks-driver (actor-spawn (lambda (self)
  (chan-send ks-ch :job-done))))

; Linked buddy: linked to worker (should survive since worker exits normally)
(define ks-buddy (actor-spawn (lambda (self)
  (bind (actor-link ks-worker) (lambda (_)
    (actor-receive))))))

(actor-run #10000)

; Worker got job and finished
(test-case (quote :ks-worker-result) :job-done (actor-result ks-worker))
; Watcher got :DOWN message
(define ks-mon-r (actor-result ks-watcher))
(test-case (quote :ks-watcher-down) :DOWN (safe-head ks-mon-r))
; Driver completed
(test-case (quote :ks-driver-done) #f (actor-alive? ks-driver))
; Buddy should be alive — normal exit doesn't propagate through links
(test-case (quote :ks-buddy-alive) #t (actor-alive? ks-buddy))

; ============================================================
; Section 46: BWoS block boundary — NE+1 actors (2 assertions)
; Spawn 33 actors (BWOS_NE+1) to force exactly one block advancement
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define bb01 (actor-spawn (lambda (self) :bb)))
(define bb02 (actor-spawn (lambda (self) :bb)))
(define bb03 (actor-spawn (lambda (self) :bb)))
(define bb04 (actor-spawn (lambda (self) :bb)))
(define bb05 (actor-spawn (lambda (self) :bb)))
(define bb06 (actor-spawn (lambda (self) :bb)))
(define bb07 (actor-spawn (lambda (self) :bb)))
(define bb08 (actor-spawn (lambda (self) :bb)))
(define bb09 (actor-spawn (lambda (self) :bb)))
(define bb10 (actor-spawn (lambda (self) :bb)))
(define bb11 (actor-spawn (lambda (self) :bb)))
(define bb12 (actor-spawn (lambda (self) :bb)))
(define bb13 (actor-spawn (lambda (self) :bb)))
(define bb14 (actor-spawn (lambda (self) :bb)))
(define bb15 (actor-spawn (lambda (self) :bb)))
(define bb16 (actor-spawn (lambda (self) :bb)))
(define bb17 (actor-spawn (lambda (self) :bb)))
(define bb18 (actor-spawn (lambda (self) :bb)))
(define bb19 (actor-spawn (lambda (self) :bb)))
(define bb20 (actor-spawn (lambda (self) :bb)))
(define bb21 (actor-spawn (lambda (self) :bb)))
(define bb22 (actor-spawn (lambda (self) :bb)))
(define bb23 (actor-spawn (lambda (self) :bb)))
(define bb24 (actor-spawn (lambda (self) :bb)))
(define bb25 (actor-spawn (lambda (self) :bb)))
(define bb26 (actor-spawn (lambda (self) :bb)))
(define bb27 (actor-spawn (lambda (self) :bb)))
(define bb28 (actor-spawn (lambda (self) :bb)))
(define bb29 (actor-spawn (lambda (self) :bb)))
(define bb30 (actor-spawn (lambda (self) :bb)))
(define bb31 (actor-spawn (lambda (self) :bb)))
(define bb32 (actor-spawn (lambda (self) :bb)))
(define bb33 (actor-spawn (lambda (self) :bb-last)))
(actor-run #10000)

(test-case (quote :bwos-block-boundary-first) #f (actor-alive? bb01))
(test-case (quote :bwos-block-boundary-last) :bb-last (actor-result bb33))

; ============================================================
; Section 47: BWoS multi-block fill — 128 actors on 2 schedulers (3 assertions)
; Fills 4+ blocks, exercises grant/reclaim protocol
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
; Spawn 64 actors (enough to fill 2 blocks per scheduler)
(define mb-count #0)
(define mb01 (actor-spawn (lambda (self) #1)))
(define mb02 (actor-spawn (lambda (self) #2)))
(define mb03 (actor-spawn (lambda (self) #3)))
(define mb04 (actor-spawn (lambda (self) #4)))
(define mb05 (actor-spawn (lambda (self) #5)))
(define mb06 (actor-spawn (lambda (self) #6)))
(define mb07 (actor-spawn (lambda (self) #7)))
(define mb08 (actor-spawn (lambda (self) #8)))
(define mb09 (actor-spawn (lambda (self) #9)))
(define mb10 (actor-spawn (lambda (self) #10)))
(define mb11 (actor-spawn (lambda (self) #11)))
(define mb12 (actor-spawn (lambda (self) #12)))
(define mb13 (actor-spawn (lambda (self) #13)))
(define mb14 (actor-spawn (lambda (self) #14)))
(define mb15 (actor-spawn (lambda (self) #15)))
(define mb16 (actor-spawn (lambda (self) #16)))
(define mb17 (actor-spawn (lambda (self) #17)))
(define mb18 (actor-spawn (lambda (self) #18)))
(define mb19 (actor-spawn (lambda (self) #19)))
(define mb20 (actor-spawn (lambda (self) #20)))
(define mb21 (actor-spawn (lambda (self) #21)))
(define mb22 (actor-spawn (lambda (self) #22)))
(define mb23 (actor-spawn (lambda (self) #23)))
(define mb24 (actor-spawn (lambda (self) #24)))
(define mb25 (actor-spawn (lambda (self) #25)))
(define mb26 (actor-spawn (lambda (self) #26)))
(define mb27 (actor-spawn (lambda (self) #27)))
(define mb28 (actor-spawn (lambda (self) #28)))
(define mb29 (actor-spawn (lambda (self) #29)))
(define mb30 (actor-spawn (lambda (self) #30)))
(define mb31 (actor-spawn (lambda (self) #31)))
(define mb32 (actor-spawn (lambda (self) #32)))
(define mb33 (actor-spawn (lambda (self) #33)))
(define mb34 (actor-spawn (lambda (self) #34)))
(define mb35 (actor-spawn (lambda (self) #35)))
(define mb36 (actor-spawn (lambda (self) #36)))
(define mb37 (actor-spawn (lambda (self) #37)))
(define mb38 (actor-spawn (lambda (self) #38)))
(define mb39 (actor-spawn (lambda (self) #39)))
(define mb40 (actor-spawn (lambda (self) #40)))
(define mb41 (actor-spawn (lambda (self) #41)))
(define mb42 (actor-spawn (lambda (self) #42)))
(define mb43 (actor-spawn (lambda (self) #43)))
(define mb44 (actor-spawn (lambda (self) #44)))
(define mb45 (actor-spawn (lambda (self) #45)))
(define mb46 (actor-spawn (lambda (self) #46)))
(define mb47 (actor-spawn (lambda (self) #47)))
(define mb48 (actor-spawn (lambda (self) #48)))
(define mb49 (actor-spawn (lambda (self) #49)))
(define mb50 (actor-spawn (lambda (self) #50)))
(define mb51 (actor-spawn (lambda (self) #51)))
(define mb52 (actor-spawn (lambda (self) #52)))
(define mb53 (actor-spawn (lambda (self) #53)))
(define mb54 (actor-spawn (lambda (self) #54)))
(define mb55 (actor-spawn (lambda (self) #55)))
(define mb56 (actor-spawn (lambda (self) #56)))
(define mb57 (actor-spawn (lambda (self) #57)))
(define mb58 (actor-spawn (lambda (self) #58)))
(define mb59 (actor-spawn (lambda (self) #59)))
(define mb60 (actor-spawn (lambda (self) #60)))
(define mb61 (actor-spawn (lambda (self) #61)))
(define mb62 (actor-spawn (lambda (self) #62)))
(define mb63 (actor-spawn (lambda (self) #63)))
(define mb64 (actor-spawn (lambda (self) #64)))
(actor-run #20000)

(test-case (quote :bwos-multiblock-first) #1 (actor-result mb01))
(test-case (quote :bwos-multiblock-mid) #32 (actor-result mb32))
(test-case (quote :bwos-multiblock-last) #64 (actor-result mb64))

; ============================================================
; Section 48: BWoS steal contention — 4 schedulers, work on sched 0 (3 assertions)
; Forces aggressive cross-scheduler stealing from multiple blocks
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #4)
(define sc01 (actor-spawn (lambda (self) :sc)))
(define sc02 (actor-spawn (lambda (self) :sc)))
(define sc03 (actor-spawn (lambda (self) :sc)))
(define sc04 (actor-spawn (lambda (self) :sc)))
(define sc05 (actor-spawn (lambda (self) :sc)))
(define sc06 (actor-spawn (lambda (self) :sc)))
(define sc07 (actor-spawn (lambda (self) :sc)))
(define sc08 (actor-spawn (lambda (self) :sc)))
(define sc09 (actor-spawn (lambda (self) :sc)))
(define sc10 (actor-spawn (lambda (self) :sc)))
(define sc11 (actor-spawn (lambda (self) :sc)))
(define sc12 (actor-spawn (lambda (self) :sc)))
(define sc13 (actor-spawn (lambda (self) :sc)))
(define sc14 (actor-spawn (lambda (self) :sc)))
(define sc15 (actor-spawn (lambda (self) :sc)))
(define sc16 (actor-spawn (lambda (self) :sc)))
(define sc17 (actor-spawn (lambda (self) :sc)))
(define sc18 (actor-spawn (lambda (self) :sc)))
(define sc19 (actor-spawn (lambda (self) :sc)))
(define sc20 (actor-spawn (lambda (self) :sc-last)))
(actor-run #10000)

(test-case (quote :bwos-steal-first-done) #f (actor-alive? sc01))
(test-case (quote :bwos-steal-last-done) #f (actor-alive? sc20))
(test-case (quote :bwos-steal-last-result) :sc-last (actor-result sc20))

; ============================================================
; Section 49: BWoS rapid lifecycle — 10 cycles of spawn-4 + run + drain (2 assertions)
; Tests block reuse and epoch counter advancement
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define rl01 (actor-spawn (lambda (self) :r1)))
(define rl02 (actor-spawn (lambda (self) :r2)))
(define rl03 (actor-spawn (lambda (self) :r3)))
(define rl04 (actor-spawn (lambda (self) :r4)))
(actor-run #200)
(actor-reset)

(sched-count #2)
(define rl05 (actor-spawn (lambda (self) :r5)))
(define rl06 (actor-spawn (lambda (self) :r6)))
(define rl07 (actor-spawn (lambda (self) :r7)))
(define rl08 (actor-spawn (lambda (self) :r8)))
(actor-run #200)
(actor-reset)

(sched-count #2)
(define rl09 (actor-spawn (lambda (self) :r9)))
(define rl10 (actor-spawn (lambda (self) :r10)))
(define rl11 (actor-spawn (lambda (self) :r11)))
(define rl12 (actor-spawn (lambda (self) :r12)))
(actor-run #200)
(actor-reset)

(sched-count #2)
(define rl13 (actor-spawn (lambda (self) :r13)))
(define rl14 (actor-spawn (lambda (self) :r14)))
(define rl15 (actor-spawn (lambda (self) :r15)))
(define rl16 (actor-spawn (lambda (self) :r16)))
(actor-run #200)
(actor-reset)

(sched-count #2)
(define rl17 (actor-spawn (lambda (self) :r17)))
(define rl18 (actor-spawn (lambda (self) :r18)))
(define rl19 (actor-spawn (lambda (self) :r19)))
(define rl20 (actor-spawn (lambda (self) :r20)))
(actor-run #200)
(actor-reset)

(sched-count #2)
(define rl21 (actor-spawn (lambda (self) :r21)))
(define rl22 (actor-spawn (lambda (self) :r22)))
(define rl23 (actor-spawn (lambda (self) :r23)))
(define rl24 (actor-spawn (lambda (self) :r24)))
(actor-run #200)
(actor-reset)

(sched-count #2)
(define rl25 (actor-spawn (lambda (self) :r25)))
(define rl26 (actor-spawn (lambda (self) :r26)))
(define rl27 (actor-spawn (lambda (self) :r27)))
(define rl28 (actor-spawn (lambda (self) :r28)))
(actor-run #200)
(actor-reset)

(sched-count #2)
(define rl29 (actor-spawn (lambda (self) :r29)))
(define rl30 (actor-spawn (lambda (self) :r30)))
(define rl31 (actor-spawn (lambda (self) :r31)))
(define rl32 (actor-spawn (lambda (self) :r32)))
(actor-run #200)
(actor-reset)

(sched-count #2)
(define rl33 (actor-spawn (lambda (self) :r33)))
(define rl34 (actor-spawn (lambda (self) :r34)))
(define rl35 (actor-spawn (lambda (self) :r35)))
(define rl36 (actor-spawn (lambda (self) :r36)))
(actor-run #200)
(actor-reset)

(sched-count #2)
(define rl37 (actor-spawn (lambda (self) :r37)))
(define rl38 (actor-spawn (lambda (self) :r38)))
(define rl39 (actor-spawn (lambda (self) :r39)))
(define rl40 (actor-spawn (lambda (self) :rl-final)))
(actor-run #200)

(test-case (quote :bwos-rapid-last-dead) #f (actor-alive? rl40))
(test-case (quote :bwos-rapid-last-result) :rl-final (actor-result rl40))

; ============================================================
; Section 50: BWoS global overflow — 50 actors on 2 schedulers (2 assertions)
; Exercises multi-block + global queue overflow under contention
; ============================================================
(actor-reset)
(chan-reset)
(trace-clear)

(sched-count #2)
(define ov01 (actor-spawn (lambda (self) :ov)))
(define ov02 (actor-spawn (lambda (self) :ov)))
(define ov03 (actor-spawn (lambda (self) :ov)))
(define ov04 (actor-spawn (lambda (self) :ov)))
(define ov05 (actor-spawn (lambda (self) :ov)))
(define ov06 (actor-spawn (lambda (self) :ov)))
(define ov07 (actor-spawn (lambda (self) :ov)))
(define ov08 (actor-spawn (lambda (self) :ov)))
(define ov09 (actor-spawn (lambda (self) :ov)))
(define ov10 (actor-spawn (lambda (self) :ov)))
(define ov11 (actor-spawn (lambda (self) :ov)))
(define ov12 (actor-spawn (lambda (self) :ov)))
(define ov13 (actor-spawn (lambda (self) :ov)))
(define ov14 (actor-spawn (lambda (self) :ov)))
(define ov15 (actor-spawn (lambda (self) :ov)))
(define ov16 (actor-spawn (lambda (self) :ov)))
(define ov17 (actor-spawn (lambda (self) :ov)))
(define ov18 (actor-spawn (lambda (self) :ov)))
(define ov19 (actor-spawn (lambda (self) :ov)))
(define ov20 (actor-spawn (lambda (self) :ov)))
(define ov21 (actor-spawn (lambda (self) :ov)))
(define ov22 (actor-spawn (lambda (self) :ov)))
(define ov23 (actor-spawn (lambda (self) :ov)))
(define ov24 (actor-spawn (lambda (self) :ov)))
(define ov25 (actor-spawn (lambda (self) :ov)))
(define ov26 (actor-spawn (lambda (self) :ov)))
(define ov27 (actor-spawn (lambda (self) :ov)))
(define ov28 (actor-spawn (lambda (self) :ov)))
(define ov29 (actor-spawn (lambda (self) :ov)))
(define ov30 (actor-spawn (lambda (self) :ov)))
(define ov31 (actor-spawn (lambda (self) :ov)))
(define ov32 (actor-spawn (lambda (self) :ov)))
(define ov33 (actor-spawn (lambda (self) :ov)))
(define ov34 (actor-spawn (lambda (self) :ov)))
(define ov35 (actor-spawn (lambda (self) :ov)))
(define ov36 (actor-spawn (lambda (self) :ov)))
(define ov37 (actor-spawn (lambda (self) :ov)))
(define ov38 (actor-spawn (lambda (self) :ov)))
(define ov39 (actor-spawn (lambda (self) :ov)))
(define ov40 (actor-spawn (lambda (self) :ov)))
(define ov41 (actor-spawn (lambda (self) :ov)))
(define ov42 (actor-spawn (lambda (self) :ov)))
(define ov43 (actor-spawn (lambda (self) :ov)))
(define ov44 (actor-spawn (lambda (self) :ov)))
(define ov45 (actor-spawn (lambda (self) :ov)))
(define ov46 (actor-spawn (lambda (self) :ov)))
(define ov47 (actor-spawn (lambda (self) :ov)))
(define ov48 (actor-spawn (lambda (self) :ov)))
(define ov49 (actor-spawn (lambda (self) :ov)))
(define ov50 (actor-spawn (lambda (self) :ov-last)))
(actor-run #10000)

(test-case (quote :bwos-overflow-first-done) #f (actor-alive? ov01))
(test-case (quote :bwos-overflow-last-result) :ov-last (actor-result ov50))

; ============================================================
; Cleanup
; ============================================================
(trace-enable! #f)
(trace-clear)
(actor-reset)
(chan-reset)
(sched-count #1)
