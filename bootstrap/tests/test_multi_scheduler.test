; Test: Multi-Scheduler Deep Stress Tests
; Exhaustive coverage of N:M work-stealing with real worker threads
; Every code path, edge case, suspend reason, and cross-scheduler interaction
;
; NOTE: Trace events are thread-local (per scheduler). Assertions on trace
; counts only see events recorded by the main thread (scheduler 0).
; Multi-scheduler tests therefore focus on outcomes (results, alive status)
; rather than exact trace counts.

; ============ Helpers ============
(≔ ev-ts     (λ (ev) (▷ (◁ ev))))
(≔ ev-sched  (λ (ev) (▷ (◁ (▷ ev)))))
(≔ ev-actor  (λ (ev) (▷ (◁ (▷ (▷ ev))))))
(≔ ev-kind   (λ (ev) (▷ (◁ (▷ (▷ (▷ ev)))))))
(≔ ev-detail (λ (ev) (▷ (◁ (▷ (▷ (▷ (▷ ev))))))))

(≔ list-len (λ (xs)
  (? (≡ xs ∅) #0
     (⊕ #1 (list-len (▷ xs))))))

; Helper: sum a list of numbers
(≔ list-sum (λ (xs)
  (? (≡ xs ∅) #0
     (⊕ (◁ xs) (list-sum (▷ xs))))))

; Helper: check all items in list satisfy predicate
(≔ list-all (λ (xs pred)
  (? (≡ xs ∅) #t
     (? (pred (◁ xs))
        (list-all (▷ xs) pred)
        #f))))

; Helper: find value in alist by key
(≔ alist-get (λ (alist key)
  (? (≡ alist ∅) ∅
     (? (≡ (◁ (◁ alist)) key)
        (▷ (◁ alist))
        (alist-get (▷ alist) key)))))

; Helper: safe head — returns value itself if not a pair (prevents assert crash)
(≔ safe-head (λ (x) (? (⚠? x) x (? (≡ x ∅) ∅ (◁ x)))))
(≔ safe-tail (λ (x) (? (⚠? x) x (? (≡ x ∅) ∅ (▷ x)))))

; ============================================================
; Section 1: Basic multi-scheduler activation (3 assertions)
; Verifies ⟳# set/get and single actor on 2 schedulers
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳! #t)
(⟳⊳⊳∅)

(⟳# #2)
(⊨ (⌜ :ms-sched-count-2) #2 (⟳#))

(≔ ms1-a (⟳ (λ (self) :hello-multi)))
(⟳! #500)

(⊨ (⌜ :ms-basic-dead) #f (⟳? ms1-a))
(⊨ (⌜ :ms-basic-result) :hello-multi (⟳→ ms1-a))

; ============================================================
; Section 2: Work stealing — 8 actors across 2 schedulers (3 assertions)
; Forces work distribution: more actors than schedulers
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ ws-a1 (⟳ (λ (self) :w1)))
(≔ ws-a2 (⟳ (λ (self) :w2)))
(≔ ws-a3 (⟳ (λ (self) :w3)))
(≔ ws-a4 (⟳ (λ (self) :w4)))
(≔ ws-a5 (⟳ (λ (self) :w5)))
(≔ ws-a6 (⟳ (λ (self) :w6)))
(≔ ws-a7 (⟳ (λ (self) :w7)))
(≔ ws-a8 (⟳ (λ (self) :w8)))
(⟳! #10000)

(⊨ (⌜ :ws-all-dead) #t
  (∧ (∧ (¬ (⟳? ws-a1)) (¬ (⟳? ws-a2)))
      (∧ (¬ (⟳? ws-a5)) (¬ (⟳? ws-a8)))))
(⊨ (⌜ :ws-results-correct) #t
  (∧ (≡ (⟳→ ws-a1) :w1) (≡ (⟳→ ws-a8) :w8)))
(⊨ (⌜ :ws-trace-activity) #t (> (⟳⊳⊳#) #0))

; ============================================================
; Section 3: LIFO slot behavior (3 assertions)
; Back-to-back spawns exercise the runnext single-slot
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ lifo-a (⟳ (λ (self) :first)))
(≔ lifo-b (⟳ (λ (self) :second)))
(⟳! #500)

(⊨ (⌜ :lifo-a-done) #f (⟳? lifo-a))
(⊨ (⌜ :lifo-b-done) #f (⟳? lifo-b))
(⊨ (⌜ :lifo-resume-events) #t (≥ (⟳⊳⊳# :RESUME) #1))

; ============================================================
; Section 4: Global queue + bulk spawn — 20 actors (3 assertions)
; Exercises global Vyukov MPMC overflow queue
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ gq01 (⟳ (λ (self) #1)))
(≔ gq02 (⟳ (λ (self) #2)))
(≔ gq03 (⟳ (λ (self) #3)))
(≔ gq04 (⟳ (λ (self) #4)))
(≔ gq05 (⟳ (λ (self) #5)))
(≔ gq06 (⟳ (λ (self) #6)))
(≔ gq07 (⟳ (λ (self) #7)))
(≔ gq08 (⟳ (λ (self) #8)))
(≔ gq09 (⟳ (λ (self) #9)))
(≔ gq10 (⟳ (λ (self) #10)))
(≔ gq11 (⟳ (λ (self) #11)))
(≔ gq12 (⟳ (λ (self) #12)))
(≔ gq13 (⟳ (λ (self) #13)))
(≔ gq14 (⟳ (λ (self) #14)))
(≔ gq15 (⟳ (λ (self) #15)))
(≔ gq16 (⟳ (λ (self) #16)))
(≔ gq17 (⟳ (λ (self) #17)))
(≔ gq18 (⟳ (λ (self) #18)))
(≔ gq19 (⟳ (λ (self) #19)))
(≔ gq20 (⟳ (λ (self) #20)))
(⟳! #2000)

(⊨ (⌜ :gq-first) #1 (⟳→ gq01))
(⊨ (⌜ :gq-mid) #10 (⟳→ gq10))
(⊨ (⌜ :gq-last) #20 (⟳→ gq20))

; ============================================================
; Section 5: High actor count stress — 50 actors (3 assertions)
; Saturates deques, forces global queue + stealing
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ h01 (⟳ (λ (self) :ok)))
(≔ h02 (⟳ (λ (self) :ok)))
(≔ h03 (⟳ (λ (self) :ok)))
(≔ h04 (⟳ (λ (self) :ok)))
(≔ h05 (⟳ (λ (self) :ok)))
(≔ h06 (⟳ (λ (self) :ok)))
(≔ h07 (⟳ (λ (self) :ok)))
(≔ h08 (⟳ (λ (self) :ok)))
(≔ h09 (⟳ (λ (self) :ok)))
(≔ h10 (⟳ (λ (self) :ok)))
(≔ h11 (⟳ (λ (self) :ok)))
(≔ h12 (⟳ (λ (self) :ok)))
(≔ h13 (⟳ (λ (self) :ok)))
(≔ h14 (⟳ (λ (self) :ok)))
(≔ h15 (⟳ (λ (self) :ok)))
(≔ h16 (⟳ (λ (self) :ok)))
(≔ h17 (⟳ (λ (self) :ok)))
(≔ h18 (⟳ (λ (self) :ok)))
(≔ h19 (⟳ (λ (self) :ok)))
(≔ h20 (⟳ (λ (self) :ok)))
(≔ h21 (⟳ (λ (self) :ok)))
(≔ h22 (⟳ (λ (self) :ok)))
(≔ h23 (⟳ (λ (self) :ok)))
(≔ h24 (⟳ (λ (self) :ok)))
(≔ h25 (⟳ (λ (self) :ok)))
(≔ h26 (⟳ (λ (self) :ok)))
(≔ h27 (⟳ (λ (self) :ok)))
(≔ h28 (⟳ (λ (self) :ok)))
(≔ h29 (⟳ (λ (self) :ok)))
(≔ h30 (⟳ (λ (self) :ok)))
(≔ h31 (⟳ (λ (self) :ok)))
(≔ h32 (⟳ (λ (self) :ok)))
(≔ h33 (⟳ (λ (self) :ok)))
(≔ h34 (⟳ (λ (self) :ok)))
(≔ h35 (⟳ (λ (self) :ok)))
(≔ h36 (⟳ (λ (self) :ok)))
(≔ h37 (⟳ (λ (self) :ok)))
(≔ h38 (⟳ (λ (self) :ok)))
(≔ h39 (⟳ (λ (self) :ok)))
(≔ h40 (⟳ (λ (self) :ok)))
(≔ h41 (⟳ (λ (self) :ok)))
(≔ h42 (⟳ (λ (self) :ok)))
(≔ h43 (⟳ (λ (self) :ok)))
(≔ h44 (⟳ (λ (self) :ok)))
(≔ h45 (⟳ (λ (self) :ok)))
(≔ h46 (⟳ (λ (self) :ok)))
(≔ h47 (⟳ (λ (self) :ok)))
(≔ h48 (⟳ (λ (self) :ok)))
(≔ h49 (⟳ (λ (self) :ok)))
(≔ h50 (⟳ (λ (self) :ok)))
(⟳! #10000)

(⊨ (⌜ :stress-50-first) #f (⟳? h01))
(⊨ (⌜ :stress-50-mid) #f (⟳? h25))
(⊨ (⌜ :stress-50-last) #f (⟳? h50))

; ============================================================
; Section 6: Message passing across schedulers (3 assertions)
; SUSPEND_MAILBOX path: sender→receiver cross-thread
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ pong-a (⟳ (λ (self) (←?))))
(≔ ping-a (⟳ (λ (self)
  (≫ (→! pong-a :ping) (λ (_)
    (≫ (→! pong-a :pong2) (λ (_)
      :sent-both)))))))
(⟳! #500)

(⊨ (⌜ :pingpong-result) :ping (⟳→ pong-a))
(⊨ (⌜ :pingpong-sender-done) #f (⟳? ping-a))
(⊨ (⌜ :pingpong-send-trace) #t (≥ (⟳⊳⊳# :SEND) #1))

; ============================================================
; Section 7: Channel contention — 4 producers, 1 consumer (3 assertions)
; SUSPEND_CHAN_SEND + SUSPEND_CHAN_RECV across schedulers
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ cch (⟿⊚ #8))

(≔ cp1 (⟳ (λ (self)
  (≫ (⟿→ cch #25) (λ (_) :p1)))))
(≔ cp2 (⟳ (λ (self)
  (≫ (⟿→ cch #25) (λ (_) :p2)))))
(≔ cp3 (⟳ (λ (self)
  (≫ (⟿→ cch #25) (λ (_) :p3)))))
(≔ cp4 (⟳ (λ (self)
  (≫ (⟿→ cch #25) (λ (_) :p4)))))

(≔ ccons (⟳ (λ (self)
  (≫ (⟿← cch) (λ (v1)
  (≫ (⟿← cch) (λ (v2)
  (≫ (⟿← cch) (λ (v3)
  (≫ (⟿← cch) (λ (v4)
    (⊕ (⊕ v1 v2) (⊕ v3 v4)))))))))))))
(⟳! #10000)

(⊨ (⌜ :chan-contention-sum) #100 (⟳→ ccons))
(⊨ (⌜ :chan-contention-producers-done) #t
  (∧ (¬ (⟳? cp1)) (¬ (⟳? cp4))))
(⊨ (⌜ :chan-contention-trace) #t (> (⟳⊳⊳#) #0))

; ============================================================
; Section 8: Reduction preemption fairness (3 assertions)
; SUSPEND_REDUCTION: long-running vs fast actor
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ long-runner (⟳ (λ (self)
  (≫ (→! self :tick) (λ (_)
  (≫ (←?) (λ (_)
  (≫ (→! self :tick) (λ (_)
  (≫ (←?) (λ (_)
  (≫ (→! self :tick) (λ (_)
  (≫ (←?) (λ (_)
    :long-done)))))))))))))))

(≔ fast-actor (⟳ (λ (self) :fast-done)))
(⟳! #2000)

(⊨ (⌜ :preempt-fast-done) #f (⟳? fast-actor))
(⊨ (⌜ :preempt-fast-result) :fast-done (⟳→ fast-actor))
(⊨ (⌜ :preempt-long-done) #f (⟳? long-runner))

; ============================================================
; Section 9: Scheduler statistics deep inspection (5 assertions)
; Validates ⟳#? output structure and stat fields
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ st1 (⟳ (λ (self) :s1)))
(≔ st2 (⟳ (λ (self) :s2)))
(≔ st3 (⟳ (λ (self) :s3)))
(≔ st4 (⟳ (λ (self) :s4)))
(⟳! #500)

(≔ stats (⟳#?))
(⊨ (⌜ :stats-nonempty) #t (¬ (≡ stats ∅)))
(⊨ (⌜ :stats-has-2-entries) #t (≥ (list-len stats) #2))
(⊨ (⌜ :stats-sched0-id) #0 (◁ (◁ stats)))
; Scheduler 0 reductions > 0
(≔ s0-alist (▷ (◁ stats)))
(≔ s0-reds (▷ (◁ (▷ (▷ s0-alist)))))
(⊨ (⌜ :stats-reds-gt0) #t (> s0-reds #0))
; Second scheduler entry exists with id=1
(⊨ (⌜ :stats-sched1-id) #1 (◁ (◁ (▷ stats))))

; ============================================================
; Section 10: Trace fidelity under load (4 assertions)
; Main thread trace ring buffer correctness
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ tf01 (⟳ (λ (self) :t1)))
(≔ tf02 (⟳ (λ (self) :t2)))
(≔ tf03 (⟳ (λ (self) :t3)))
(≔ tf04 (⟳ (λ (self) :t4)))
(≔ tf05 (⟳ (λ (self) :t5)))
(≔ tf06 (⟳ (λ (self) :t6)))
(≔ tf07 (⟳ (λ (self) :t7)))
(≔ tf08 (⟳ (λ (self) :t8)))
(≔ tf09 (⟳ (λ (self) :t9)))
(≔ tf10 (⟳ (λ (self) :t10)))
(⟳! #10000)

(⊨ (⌜ :trace-fid-spawn) #t (≥ (⟳⊳⊳# :SPAWN) #1))
(⊨ (⌜ :trace-fid-die) #t (≥ (⟳⊳⊳# :DIE) #1))
(⊨ (⌜ :trace-fid-total) #t (> (⟳⊳⊳#) #0))
(≔ snap-all (⟳⊳⊳⊛))
(⊨ (⌜ :trace-fid-snap) #t (¬ (≡ snap-all ∅)))

; ============================================================
; Section 11: Monitor across schedulers (3 assertions)
; actor_notify_exit sends :DOWN to watcher on potentially different scheduler
; Tests: (:DOWN actor-id :normal) message structure
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ mon-child (⟳ (λ (self) :normal-exit)))
(≔ mon-parent (⟳ (λ (self)
  (≫ (⟳⊙ mon-child) (λ (_)
    (←?))))))
(⟳! #10000)

(≔ mon-result (⟳→ mon-parent))
(⊨ (⌜ :monitor-down-tag) :DOWN (safe-head mon-result))
(⊨ (⌜ :monitor-down-reason) :normal (safe-head (safe-tail (safe-tail mon-result))))
; Parent finished (got the DOWN message and exited)
(⊨ (⌜ :monitor-parent-dead) #f (⟳? mon-parent))

; ============================================================
; Section 12: Link death propagation across schedulers (2 assertions)
; actor_exit_signal kills linked actor without trap-exit
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ link-child (⟳ (λ (self)
  (≫ (←?) (λ (msg)
    (⚠ :crash :boom))))))
(≔ link-parent (⟳ (λ (self)
  (≫ (⟳⊗ link-child) (λ (_)
    (≫ (→! link-child :die) (λ (_)
      (←?))))))))
(⟳! #10000)

(⊨ (⌜ :link-parent-dead) #f (⟳? link-parent))
(⊨ (⌜ :link-child-dead) #f (⟳? link-child))

; ============================================================
; Section 13: Link with trap-exit across schedulers (3 assertions)
; ⟳⊜ converts exit signal to :EXIT message instead of killing
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ trap-child (⟳ (λ (self)
  (≫ (←?) (λ (msg) (⚠ :intentional :crash))))))
(≔ trap-parent (⟳ (λ (self)
  (≫ (⟳⊜ #t) (λ (_)
  (≫ (⟳⊗ trap-child) (λ (_)
  (≫ (→! trap-child :go) (λ (_)
    (←?))))))))))
(⟳! #10000)

; Parent should be dead (finished) — received :EXIT as message
(⊨ (⌜ :trap-parent-dead) #f (⟳? trap-parent))
; Parent result is the :EXIT message — ⟨:EXIT child-id error⟩
(≔ trap-result (⟳→ trap-parent))
(⊨ (⌜ :trap-exit-tag) :EXIT (safe-head trap-result))
; Child crashed
(⊨ (⌜ :trap-child-dead) #f (⟳? trap-child))

; ============================================================
; Section 14: Unlink prevents death propagation (2 assertions)
; ⟳⊘ removes bidirectional link
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ unl-child (⟳ (λ (self)
  (≫ (←?) (λ (_) (⚠ :crash :unlinktest))))))
(≔ unl-parent (⟳ (λ (self)
  (≫ (⟳⊗ unl-child) (λ (_)
  (≫ (⟳⊘ unl-child) (λ (_)
  (≫ (→! unl-child :die) (λ (_)
    (←?))))))))))
(⟳! #10000)

; Parent should be alive — still waiting for message, unlinked from child crash
(⊨ (⌜ :unlink-parent-alive) #t (⟳? unl-parent))
; Child is dead (crashed)
(⊨ (⌜ :unlink-child-dead) #f (⟳? unl-child))

; ============================================================
; Section 15: Exit signal across schedulers (2 assertions)
; ⟳✕ sends exit signal to actor (like Erlang exit/2)
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ exit-victim (⟳ (λ (self) (←?))))
(≔ exit-sender (⟳ (λ (self)
  (⟳✕ exit-victim :killed))))
(⟳! #500)

(⊨ (⌜ :exit-victim-dead) #f (⟳? exit-victim))
(⊨ (⌜ :exit-sender-done) #f (⟳? exit-sender))

; ============================================================
; Section 16: Channel close while actor suspended (3 assertions)
; SUSPEND_CHAN_RECV → channel closed → error resume
; Tests sched_prepare_resume chan-recv-closed path
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ close-ch (⟿⊚ #4))
; Reader blocks on empty channel
(≔ close-reader (⟳ (λ (self) (⟿← close-ch))))
; Closer closes the channel after a brief delay
(≔ close-closer (⟳ (λ (self)
  (≫ (→! self :tick) (λ (_)
  (≫ (←?) (λ (_)
    (⟿× close-ch))))))))
(⟳! #10000)

; Reader should get error (chan-recv-closed)
(⊨ (⌜ :close-reader-dead) #f (⟳? close-reader))
(≔ close-result (⟳→ close-reader))
(⊨ (⌜ :close-reader-error) #t (⚠? close-result))
; Closer completed
(⊨ (⌜ :close-closer-done) #f (⟳? close-closer))

; ============================================================
; Section 17: Channel send blocking (3 assertions)
; SUSPEND_CHAN_SEND: capacity-1 channel, send blocks until consumed
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ tiny-ch (⟿⊚ #1))
; Sender sends 3 values — blocks after first since capacity=1
(≔ blk-sender (⟳ (λ (self)
  (≫ (⟿→ tiny-ch #10) (λ (_)
  (≫ (⟿→ tiny-ch #20) (λ (_)
  (≫ (⟿→ tiny-ch #30) (λ (_)
    :sent-all)))))))))
; Reader reads 3 values
(≔ blk-reader (⟳ (λ (self)
  (≫ (⟿← tiny-ch) (λ (v1)
  (≫ (⟿← tiny-ch) (λ (v2)
  (≫ (⟿← tiny-ch) (λ (v3)
    (⊕ v1 (⊕ v2 v3)))))))))))
(⟳! #10000)

(⊨ (⌜ :chsend-sender-done) #f (⟳? blk-sender))
(⊨ (⌜ :chsend-sender-result) :sent-all (⟳→ blk-sender))
(⊨ (⌜ :chsend-reader-sum) #60 (⟳→ blk-reader))

; ============================================================
; Section 18: Select across schedulers (3 assertions)
; ⟿⊞ blocks on multiple channels, wakes when data arrives
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ sel-ch1 (⟿⊚ #4))
(≔ sel-ch2 (⟿⊚ #4))
; Consumer does blocking select on both channels
(≔ sel-cons (⟳ (λ (self) (⟿⊞ sel-ch1 sel-ch2))))
; Producer sends to ch2 (ch1 stays empty)
(≔ sel-prod (⟳ (λ (self) (⟿→ sel-ch2 :from-ch2))))
(⟳! #10000)

(⊨ (⌜ :select-cons-done) #f (⟳? sel-cons))
; Select result is ⟨channel value⟩ — value should be :from-ch2
(≔ sel-result (⟳→ sel-cons))
(⊨ (⌜ :select-value) :from-ch2 (safe-tail sel-result))
(⊨ (⌜ :select-prod-done) #f (⟳? sel-prod))

; ============================================================
; Section 19: Timer delivery across schedulers (3 assertions)
; ⟳⏱ fires timer message to actor on potentially different scheduler
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
; Target waits for timer message
(≔ timer-target (⟳ (λ (self) (←?))))
; Spawner creates timer and exits
(≔ timer-spawner (⟳ (λ (self)
  (⟳⏱ #10 timer-target :timer-fired))))
(⟳! #500)

(⊨ (⌜ :timer-target-done) #f (⟳? timer-target))
(⊨ (⌜ :timer-target-result) :timer-fired (⟳→ timer-target))
; Timer spawner should have returned the timer ID
(⊨ (⌜ :timer-spawner-done) #f (⟳? timer-spawner))

; ============================================================
; Section 20: Timer cancel across schedulers (2 assertions)
; ⟳⏱× cancels a pending timer before it fires
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ cancel-target (⟳ (λ (self) (←?))))
; Create timer with long delay, then cancel it
(≔ cancel-actor (⟳ (λ (self)
  (≫ (⟳⏱ #9999 cancel-target :never) (λ (tid)
    (⟳⏱× tid))))))
(⟳! #500)

; Target should still be alive (timer was cancelled, no message sent)
(⊨ (⌜ :cancel-target-alive) #t (⟳? cancel-target))
; Canceller completed
(⊨ (⌜ :cancel-actor-done) #f (⟳? cancel-actor))

; ============================================================
; Section 21: Task-await across schedulers (3 assertions)
; SUSPEND_TASK_AWAIT: actor waits for another to finish
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ task-worker (⟳ (λ (self) #42)))
(≔ task-waiter (⟳ (λ (self)
  (≫ (⟳⊲ task-worker) (λ (result)
    (⊕ result #8))))))
(⟳! #500)

(⊨ (⌜ :await-worker-done) #f (⟳? task-worker))
(⊨ (⌜ :await-waiter-done) #f (⟳? task-waiter))
(⊨ (⌜ :await-waiter-result) #50 (⟳→ task-waiter))

; ============================================================
; Section 22: Process dictionary across schedulers (4 assertions)
; ⟳⊔⊕ / ⟳⊔? inside actors on multi-scheduler
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
; Actor stores value in its own process dictionary
(≔ dict-actor (⟳ (λ (self)
  (≫ (⟳⊔⊕ :mykey #999) (λ (_)
    (⟳⊔? :mykey))))))
(⟳! #500)

(⊨ (⌜ :dict-actor-done) #f (⟳? dict-actor))
(⊨ (⌜ :dict-actor-result) #999 (⟳→ dict-actor))

; Two actors with independent dictionaries
(≔ dict-a (⟳ (λ (self)
  (≫ (⟳⊔⊕ :x #111) (λ (_) (⟳⊔? :x))))))
(≔ dict-b (⟳ (λ (self)
  (≫ (⟳⊔⊕ :x #222) (λ (_) (⟳⊔? :x))))))
(⟳! #500)

(⊨ (⌜ :dict-isolation-a) #111 (⟳→ dict-a))
(⊨ (⌜ :dict-isolation-b) #222 (⟳→ dict-b))

; ============================================================
; Section 23: Registry across schedulers (4 assertions)
; ⟳⊜⊕ / ⟳⊜? name resolution when actors on different schedulers
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ reg-server (⟳ (λ (self) (←?))))
(⟳⊜⊕ :my-server reg-server)

; Verify lookup works before actors run
(≔ reg-found (⟳⊜? :my-server))
(⊨ (⌜ :reg-lookup-works) #t (¬ (≡ reg-found ∅)))

; Client looks up server by name and sends message
(≔ reg-client (⟳ (λ (self)
  (≫ (⟳⊜? :my-server) (λ (srv)
    (≫ (→! srv :hello-from-client) (λ (_)
      :client-done)))))))
(⟳! #500)

; Server received the message
(⊨ (⌜ :reg-server-done) #f (⟳? reg-server))
(⊨ (⌜ :reg-server-result) :hello-from-client (⟳→ reg-server))
; Client completed
(⊨ (⌜ :reg-client-done) #f (⟳? reg-client))

; ============================================================
; Section 24: Multiple messages FIFO ordering (2 assertions)
; Mailbox Vyukov MPMC preserves order from single sender
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ fifo-recv (⟳ (λ (self)
  (≫ (←?) (λ (v1)
  (≫ (←?) (λ (v2)
  (≫ (←?) (λ (v3)
    (⟨⟩ v1 (⟨⟩ v2 (⟨⟩ v3 ∅))))))))))))
(≔ fifo-send (⟳ (λ (self)
  (≫ (→! fifo-recv :first) (λ (_)
  (≫ (→! fifo-recv :second) (λ (_)
  (≫ (→! fifo-recv :third) (λ (_)
    :sent)))))))))
(⟳! #500)

(≔ fifo-result (⟳→ fifo-recv))
(⊨ (⌜ :fifo-first) :first (safe-head fifo-result))
(⊨ (⌜ :fifo-third) :third (safe-head (safe-tail (safe-tail fifo-result))))

; ============================================================
; Section 25: Supervisor one-for-one across schedulers (3 assertions)
; Supervisor restarts crashed child on multi-scheduler
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
; Two child behaviors: first crashes, second is stable
(≔ sup-id (⟳⊛ :one-for-one
  (⟨⟩ (λ (self) (≫ (←?) (λ (_) (⚠ :crash :sup-test))))
  (⟨⟩ (λ (self) (←?))
    ∅))))
(⟳! #200)

; Get children before crash
(≔ sup-kids-before (⟳⊛? sup-id))
(≔ kid1-before (◁ sup-kids-before))

; Send message to first child to trigger crash
(→! kid1-before :crash-now)
(⟳! #500)

; After restart, child count should still be 2
(≔ sup-kids-after (⟳⊛? sup-id))
(⊨ (⌜ :sup-child-count) #2 (list-len sup-kids-after))
; Restart count should be ≥ 1
(⊨ (⌜ :sup-restart-count) #t (≥ (⟳⊛! sup-id) #1))
; New first child is different from crashed one (new actor)
(≔ kid1-after (◁ sup-kids-after))
(⊨ (⌜ :sup-new-child) #t (¬ (≡ kid1-before kid1-after)))

; ============================================================
; Section 26: Dynamic supervisor across schedulers (3 assertions)
; ⟳⊛⊹ creates empty supervisor, ⟳⊛⊹⊕ adds children dynamically
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ dsup-id (⟳⊛⊹))
; Start children dynamically — all permanent, all block on receive
(⟳⊛⊹⊕ dsup-id (λ (self) (←?)) :permanent)
(⟳⊛⊹⊕ dsup-id (λ (self) (←?)) :permanent)
(⟳⊛⊹⊕ dsup-id (λ (self) (←?)) :permanent)
(⟳! #500)

(⊨ (⌜ :dynsup-count) #3 (⟳⊛⊹# dsup-id))
(≔ dkids (⟳⊛⊹? dsup-id))
(⊨ (⌜ :dynsup-has-children) #t (> (list-len dkids) #0))
; Terminate one child
(⟳⊛⊹⊖ dsup-id (◁ (◁ dkids)))
(⟳! #200)
(⊨ (⌜ :dynsup-after-term) #2 (⟳⊛⊹# dsup-id))

; ============================================================
; Section 27: Multi-round message exchange (2 assertions)
; Actor sends and receives multiple rounds — tests continuation
; persistence across scheduler switches (saved_continuation)
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
; Echo server: receives message, sends it back incremented
(≔ echo-srv (⟳ (λ (self)
  (≫ (←?) (λ (req)
    (≫ (→! (◁ req) (⊕ (▷ req) #1)) (λ (_)
    (≫ (←?) (λ (req2)
      (≫ (→! (◁ req2) (⊕ (▷ req2) #1)) (λ (_)
        :echo-done)))))))))))
; Client sends request, gets response, sends again
(≔ echo-cli (⟳ (λ (self)
  (≫ (→! echo-srv (⟨⟩ self #10)) (λ (_)
  (≫ (←?) (λ (r1)
  (≫ (→! echo-srv (⟨⟩ self r1)) (λ (_)
  (≫ (←?) (λ (r2)
    r2)))))))))))
(⟳! #10000)

(⊨ (⌜ :echo-final-result) #12 (⟳→ echo-cli))
(⊨ (⌜ :echo-srv-done) #f (⟳? echo-srv))

; ============================================================
; Section 28: Graceful termination with results (8 assertions)
; Validates all actors finish + correct results + stats post-shutdown
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ gt1 (⟳ (λ (self) :g1)))
(≔ gt2 (⟳ (λ (self) :g2)))
(≔ gt3 (⟳ (λ (self) :g3)))
(⟳! #500)

(⊨ (⌜ :grace-a1-dead) #f (⟳? gt1))
(⊨ (⌜ :grace-a2-dead) #f (⟳? gt2))
(⊨ (⌜ :grace-a3-dead) #f (⟳? gt3))
(⊨ (⌜ :grace-a1-result) :g1 (⟳→ gt1))
(⊨ (⌜ :grace-a2-result) :g2 (⟳→ gt2))
(⊨ (⌜ :grace-a3-result) :g3 (⟳→ gt3))
(⊨ (⌜ :grace-trace-gt0) #t (> (⟳⊳⊳#) #0))
(≔ post-stats (⟳#?))
(⊨ (⌜ :grace-stats-exist) #t (¬ (≡ post-stats ∅)))

; ============================================================
; Section 29: Scale to 4 schedulers (5 assertions)
; Tests ⟳# with N=4, 4 stat entries, actor completion
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #4)
(⊨ (⌜ :scale4-count) #4 (⟳#))

(≔ sc4-a (⟳ (λ (self) :four-sched)))
(≔ sc4-b (⟳ (λ (self) :four-sched2)))
(≔ sc4-c (⟳ (λ (self) :four-sched3)))
(≔ sc4-d (⟳ (λ (self) :four-sched4)))
(⟳! #10000)

(⊨ (⌜ :scale4-a-done) :four-sched (⟳→ sc4-a))
(⊨ (⌜ :scale4-d-done) :four-sched4 (⟳→ sc4-d))
(≔ s4-stats (⟳#?))
(⊨ (⌜ :scale4-stats-len) #4 (list-len s4-stats))
; Last scheduler entry has id=3
(≔ s4-last (◁ (▷ (▷ (▷ s4-stats)))))
(⊨ (⌜ :scale4-last-sched-id) #3 (◁ s4-last))

; ============================================================
; Section 30: Scale to 4 schedulers with channels + messages (3 assertions)
; Cross-scheduler communication at higher scheduler counts
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #4)
(≔ sc4ch (⟿⊚ #16))
; 4 producers, 1 consumer
(≔ sc4p1 (⟳ (λ (self) (≫ (⟿→ sc4ch #10) (λ (_) :sp1)))))
(≔ sc4p2 (⟳ (λ (self) (≫ (⟿→ sc4ch #20) (λ (_) :sp2)))))
(≔ sc4p3 (⟳ (λ (self) (≫ (⟿→ sc4ch #30) (λ (_) :sp3)))))
(≔ sc4p4 (⟳ (λ (self) (≫ (⟿→ sc4ch #40) (λ (_) :sp4)))))
(≔ sc4c (⟳ (λ (self)
  (≫ (⟿← sc4ch) (λ (v1)
  (≫ (⟿← sc4ch) (λ (v2)
  (≫ (⟿← sc4ch) (λ (v3)
  (≫ (⟿← sc4ch) (λ (v4)
    (⊕ (⊕ v1 v2) (⊕ v3 v4)))))))))))))
(⟳! #10000)

(⊨ (⌜ :sc4-chan-sum) #100 (⟳→ sc4c))
(⊨ (⌜ :sc4-all-prods-done) #t
  (∧ (∧ (¬ (⟳? sc4p1)) (¬ (⟳? sc4p2)))
      (∧ (¬ (⟳? sc4p3)) (¬ (⟳? sc4p4)))))
(⊨ (⌜ :sc4-consumer-done) #f (⟳? sc4c))

; ============================================================
; Section 31: Back to single scheduler (2 assertions)
; Downscale from 4→1, verify no stale state
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #1)
(⊨ (⌜ :back-single-count) #1 (⟳#))

(≔ single-a (⟳ (λ (self) :back-to-one)))
(⟳! #200)

(⊨ (⌜ :back-single-result) :back-to-one (⟳→ single-a))

; ============================================================
; Section 32: Re-scale after downscale (3 assertions)
; 1→2 after having been 4→1, tests scheduler reinitialization
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ rescale-a (⟳ (λ (self) :rescaled-ok)))
(≔ rescale-b (⟳ (λ (self) :rescaled-ok2)))
(⟳! #500)

(⊨ (⌜ :rescale-count) #2 (⟳#))
(⊨ (⌜ :rescale-a-result) :rescaled-ok (⟳→ rescale-a))
(⊨ (⌜ :rescale-b-result) :rescaled-ok2 (⟳→ rescale-b))

; ============================================================
; Section 33: Multiple lifecycle cycles — repeated init/run/drain (2 assertions)
; Exercises the queue drain fix: repeated sched_run_all + actor_reset_all
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

; Cycle through 5 create-run-reset cycles on 2 schedulers
(⟳# #2)
(≔ cyc1 (⟳ (λ (self) :c1)))
(⟳! #200)
(⟳∅)

(⟳# #2)
(≔ cyc2 (⟳ (λ (self) :c2)))
(⟳! #200)
(⟳∅)

(⟳# #2)
(≔ cyc3 (⟳ (λ (self) :c3)))
(⟳! #200)
(⟳∅)

(⟳# #2)
(≔ cyc4 (⟳ (λ (self) :c4)))
(⟳! #200)
(⟳∅)

(⟳# #2)
(≔ cyc5 (⟳ (λ (self) :c5)))
(⟳! #200)

; Last cycle's actor should have correct result
(⊨ (⌜ :lifecycle-cycle5) :c5 (⟳→ cyc5))
(⊨ (⌜ :lifecycle-cycle5-dead) #f (⟳? cyc5))

; ============================================================
; Section 34: Rapid lifecycle — 10 cycles with channels (2 assertions)
; Stresses the queue drain with channel operations each cycle
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ rc1ch (⟿⊚ #2))
(≔ rc1a (⟳ (λ (self) (≫ (⟿→ rc1ch #1) (λ (_) (⟿← rc1ch))))))
(⟳! #300)
(⟳∅) (⟿∅)

(⟳# #2)
(≔ rc2ch (⟿⊚ #2))
(≔ rc2a (⟳ (λ (self) (≫ (⟿→ rc2ch #2) (λ (_) (⟿← rc2ch))))))
(⟳! #300)
(⟳∅) (⟿∅)

(⟳# #2)
(≔ rc3ch (⟿⊚ #2))
(≔ rc3a (⟳ (λ (self) (≫ (⟿→ rc3ch #3) (λ (_) (⟿← rc3ch))))))
(⟳! #300)
(⟳∅) (⟿∅)

(⟳# #2)
(≔ rc4ch (⟿⊚ #2))
(≔ rc4a (⟳ (λ (self) (≫ (⟿→ rc4ch #4) (λ (_) (⟿← rc4ch))))))
(⟳! #300)
(⟳∅) (⟿∅)

(⟳# #2)
(≔ rc5ch (⟿⊚ #2))
(≔ rc5a (⟳ (λ (self) (≫ (⟿→ rc5ch #5) (λ (_) (⟿← rc5ch))))))
(⟳! #300)
(⟳∅) (⟿∅)

(⟳# #2)
(≔ rc6ch (⟿⊚ #2))
(≔ rc6a (⟳ (λ (self) (≫ (⟿→ rc6ch #6) (λ (_) (⟿← rc6ch))))))
(⟳! #300)
(⟳∅) (⟿∅)

(⟳# #2)
(≔ rc7ch (⟿⊚ #2))
(≔ rc7a (⟳ (λ (self) (≫ (⟿→ rc7ch #7) (λ (_) (⟿← rc7ch))))))
(⟳! #300)
(⟳∅) (⟿∅)

(⟳# #2)
(≔ rc8ch (⟿⊚ #2))
(≔ rc8a (⟳ (λ (self) (≫ (⟿→ rc8ch #8) (λ (_) (⟿← rc8ch))))))
(⟳! #300)
(⟳∅) (⟿∅)

(⟳# #2)
(≔ rc9ch (⟿⊚ #2))
(≔ rc9a (⟳ (λ (self) (≫ (⟿→ rc9ch #9) (λ (_) (⟿← rc9ch))))))
(⟳! #300)
(⟳∅) (⟿∅)

(⟳# #2)
(≔ rc10ch (⟿⊚ #2))
(≔ rc10a (⟳ (λ (self) (≫ (⟿→ rc10ch #10) (λ (_) (⟿← rc10ch))))))
(⟳! #300)

(⊨ (⌜ :rapid-chan-result) #10 (⟳→ rc10a))
(⊨ (⌜ :rapid-chan-dead) #f (⟳? rc10a))

; ============================================================
; Section 35: Mixed workload — actors + channels + messages + monitor (4 assertions)
; All suspend reasons in one run
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ mix-ch (⟿⊚ #4))
; Actor 3: message receiver (defined first so cons can reference it)
(≔ mix-waiter (⟳ (λ (self) (←?))))
; Actor 4: monitors mix-waiter
(≔ mix-monitor (⟳ (λ (self)
  (≫ (⟳⊙ mix-waiter) (λ (_) (←?))))))
; Actor 1: channel producer
(≔ mix-prod (⟳ (λ (self)
  (≫ (⟿→ mix-ch #77) (λ (_) :prod-done)))))
; Actor 2: channel consumer + message sender
(≔ mix-cons (⟳ (λ (self)
  (≫ (⟿← mix-ch) (λ (val)
    (≫ (→! mix-waiter val) (λ (_)
      :cons-done)))))))
(⟳! #10000)

(⊨ (⌜ :mix-prod-done) #f (⟳? mix-prod))
(⊨ (⌜ :mix-waiter-result) #77 (⟳→ mix-waiter))
(⊨ (⌜ :mix-cons-done) #f (⟳? mix-cons))
; Monitor received :DOWN after waiter exited
(≔ mix-mon-result (⟳→ mix-monitor))
(⊨ (⌜ :mix-monitor-down) :DOWN (safe-head mix-mon-result))

; ============================================================
; Section 36: Chain of monitors — A monitors B monitors C (3 assertions)
; Tests cascading :DOWN messages through monitor chain
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ chain-c (⟳ (λ (self) :chain-end)))
(≔ chain-b (⟳ (λ (self)
  (≫ (⟳⊙ chain-c) (λ (_)
    (←?))))))
(≔ chain-a (⟳ (λ (self)
  (≫ (⟳⊙ chain-b) (λ (_)
    (←?))))))
(⟳! #10000)

; C finishes → B gets :DOWN → B finishes → A gets :DOWN
(⊨ (⌜ :chain-c-dead) #f (⟳? chain-c))
(⊨ (⌜ :chain-b-dead) #f (⟳? chain-b))
(⊨ (⌜ :chain-a-dead) #f (⟳? chain-a))

; ============================================================
; Section 37: Chain of links — crash propagation through 3 actors (3 assertions)
; A linked to B linked to C, C crashes → all die
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ lc-c (⟳ (λ (self)
  (≫ (←?) (λ (_) (⚠ :chain-crash :lc))))))
(≔ lc-b (⟳ (λ (self)
  (≫ (⟳⊗ lc-c) (λ (_) (←?))))))
(≔ lc-a (⟳ (λ (self)
  (≫ (⟳⊗ lc-b) (λ (_) (←?))))))
; Trigger crash
(→! lc-c :crash-now)
(⟳! #10000)

(⊨ (⌜ :lc-c-dead) #f (⟳? lc-c))
(⊨ (⌜ :lc-b-dead) #f (⟳? lc-b))
(⊨ (⌜ :lc-a-dead) #f (⟳? lc-a))

; ============================================================
; Section 38: Actor error result across schedulers (2 assertions)
; Actor that returns error value — result is an error cell
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ err-actor (⟳ (λ (self) (⚠ :my-error :details))))
(⟳! #500)

(⊨ (⌜ :err-actor-dead) #f (⟳? err-actor))
(⊨ (⌜ :err-actor-is-error) #t (⚠? (⟳→ err-actor)))

; ============================================================
; Section 39: Self-send across schedulers (2 assertions)
; Actor sends message to itself — tests mailbox + continuation
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ self-actor (⟳ (λ (self)
  (≫ (→! self :self-msg) (λ (_)
    (←?))))))
(⟳! #500)

(⊨ (⌜ :self-send-done) #f (⟳? self-actor))
(⊨ (⌜ :self-send-result) :self-msg (⟳→ self-actor))

; ============================================================
; Section 40: Large message body across schedulers (2 assertions)
; Tests ref-counting correctness for large nested structures
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
; Build a deeply nested list
(≔ big-msg (⟨⟩ #1 (⟨⟩ #2 (⟨⟩ #3 (⟨⟩ #4 (⟨⟩ #5
  (⟨⟩ #6 (⟨⟩ #7 (⟨⟩ #8 (⟨⟩ #9 (⟨⟩ #10 ∅)))))))))))

(≔ big-recv (⟳ (λ (self) (←?))))
(≔ big-send (⟳ (λ (self)
  (→! big-recv big-msg))))
(⟳! #500)

(≔ big-result (⟳→ big-recv))
(⊨ (⌜ :big-msg-head) #1 (safe-head big-result))
(⊨ (⌜ :big-msg-deep) #10 (safe-head (safe-tail (safe-tail (safe-tail (safe-tail (safe-tail (safe-tail (safe-tail (safe-tail (safe-tail big-result)))))))))))

; ============================================================
; Section 41: Concurrent channel readers (2 assertions)
; 2 readers on same channel — each gets one value
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ shared-ch (⟿⊚ #4))
; 2 readers
(≔ cr1 (⟳ (λ (self) (⟿← shared-ch))))
(≔ cr2 (⟳ (λ (self) (⟿← shared-ch))))
; 2 writers
(≔ cw1 (⟳ (λ (self) (⟿→ shared-ch :val-a))))
(≔ cw2 (⟳ (λ (self) (⟿→ shared-ch :val-b))))
(⟳! #500)

; Both readers got a value (could be either :val-a or :val-b)
(⊨ (⌜ :conc-reader1-done) #f (⟳? cr1))
(⊨ (⌜ :conc-reader2-done) #f (⟳? cr2))

; ============================================================
; Section 42: Zero-tick budget (edge case) (2 assertions)
; ⟳! #0 should return immediately, actors stay alive
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ zero-a (⟳ (λ (self) :never)))
(⟳! #0)
; Actor should still be alive — no ticks were given
(⊨ (⌜ :zero-tick-alive) #t (⟳? zero-a))
; Now give it real ticks
(⟳! #500)
(⊨ (⌜ :zero-tick-then-run) :never (⟳→ zero-a))

; ============================================================
; Section 43: Starvation guard — LIFO consecutive limit (2 assertions)
; After 3 consecutive LIFO pops, scheduler falls back to deque
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
; Spawn 6 actors — more than 3 consecutive LIFO limit
(≔ sg1 (⟳ (λ (self) :sg1)))
(≔ sg2 (⟳ (λ (self) :sg2)))
(≔ sg3 (⟳ (λ (self) :sg3)))
(≔ sg4 (⟳ (λ (self) :sg4)))
(≔ sg5 (⟳ (λ (self) :sg5)))
(≔ sg6 (⟳ (λ (self) :sg6)))
(⟳! #500)

; All complete despite starvation guard cycling
(⊨ (⌜ :starve-all-done) #t
  (∧ (∧ (¬ (⟳? sg1)) (¬ (⟳? sg3)))
      (∧ (¬ (⟳? sg5)) (¬ (⟳? sg6)))))
(⊨ (⌜ :starve-results) #t
  (∧ (≡ (⟳→ sg1) :sg1) (≡ (⟳→ sg6) :sg6)))

; ============================================================
; Section 44: Actor result after multi-round yield (2 assertions)
; Actor yields multiple times (SUSPEND_REDUCTION) before finishing
; Tests saved_continuation correctness
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
; Compute fibonacci (recursive, burns reductions, causes yields)
(≔ fib (λ (n)
  (? (≤ n #1) n
     (⊕ (fib (⊖ n #1)) (fib (⊖ n #2))))))
(≔ fib-actor (⟳ (λ (self) (fib #10))))
(⟳! #10000)

(⊨ (⌜ :fib-done) #f (⟳? fib-actor))
(⊨ (⌜ :fib-result) #55 (⟳→ fib-actor))

; ============================================================
; Section 45: Multiple schedulers with monitor + link + channel (4 assertions)
; Kitchen-sink test: all concurrency features in one run
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ ks-ch (⟿⊚ #4))

; Worker: reads from channel, sends to parent
(≔ ks-worker (⟳ (λ (self)
  (≫ (⟿← ks-ch) (λ (job)
    job)))))

; Monitor: watches worker
(≔ ks-watcher (⟳ (λ (self)
  (≫ (⟳⊙ ks-worker) (λ (_)
    (←?))))))

; Driver: sends job via channel
(≔ ks-driver (⟳ (λ (self)
  (⟿→ ks-ch :job-done))))

; Linked buddy: linked to worker (should survive since worker exits normally)
(≔ ks-buddy (⟳ (λ (self)
  (≫ (⟳⊗ ks-worker) (λ (_)
    (←?))))))

(⟳! #10000)

; Worker got job and finished
(⊨ (⌜ :ks-worker-result) :job-done (⟳→ ks-worker))
; Watcher got :DOWN message
(≔ ks-mon-r (⟳→ ks-watcher))
(⊨ (⌜ :ks-watcher-down) :DOWN (safe-head ks-mon-r))
; Driver completed
(⊨ (⌜ :ks-driver-done) #f (⟳? ks-driver))
; Buddy should be alive — normal exit doesn't propagate through links
(⊨ (⌜ :ks-buddy-alive) #t (⟳? ks-buddy))

; ============================================================
; Section 46: BWoS block boundary — NE+1 actors (2 assertions)
; Spawn 33 actors (BWOS_NE+1) to force exactly one block advancement
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ bb01 (⟳ (λ (self) :bb)))
(≔ bb02 (⟳ (λ (self) :bb)))
(≔ bb03 (⟳ (λ (self) :bb)))
(≔ bb04 (⟳ (λ (self) :bb)))
(≔ bb05 (⟳ (λ (self) :bb)))
(≔ bb06 (⟳ (λ (self) :bb)))
(≔ bb07 (⟳ (λ (self) :bb)))
(≔ bb08 (⟳ (λ (self) :bb)))
(≔ bb09 (⟳ (λ (self) :bb)))
(≔ bb10 (⟳ (λ (self) :bb)))
(≔ bb11 (⟳ (λ (self) :bb)))
(≔ bb12 (⟳ (λ (self) :bb)))
(≔ bb13 (⟳ (λ (self) :bb)))
(≔ bb14 (⟳ (λ (self) :bb)))
(≔ bb15 (⟳ (λ (self) :bb)))
(≔ bb16 (⟳ (λ (self) :bb)))
(≔ bb17 (⟳ (λ (self) :bb)))
(≔ bb18 (⟳ (λ (self) :bb)))
(≔ bb19 (⟳ (λ (self) :bb)))
(≔ bb20 (⟳ (λ (self) :bb)))
(≔ bb21 (⟳ (λ (self) :bb)))
(≔ bb22 (⟳ (λ (self) :bb)))
(≔ bb23 (⟳ (λ (self) :bb)))
(≔ bb24 (⟳ (λ (self) :bb)))
(≔ bb25 (⟳ (λ (self) :bb)))
(≔ bb26 (⟳ (λ (self) :bb)))
(≔ bb27 (⟳ (λ (self) :bb)))
(≔ bb28 (⟳ (λ (self) :bb)))
(≔ bb29 (⟳ (λ (self) :bb)))
(≔ bb30 (⟳ (λ (self) :bb)))
(≔ bb31 (⟳ (λ (self) :bb)))
(≔ bb32 (⟳ (λ (self) :bb)))
(≔ bb33 (⟳ (λ (self) :bb-last)))
(⟳! #10000)

(⊨ (⌜ :bwos-block-boundary-first) #f (⟳? bb01))
(⊨ (⌜ :bwos-block-boundary-last) :bb-last (⟳→ bb33))

; ============================================================
; Section 47: BWoS multi-block fill — 128 actors on 2 schedulers (3 assertions)
; Fills 4+ blocks, exercises grant/reclaim protocol
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
; Spawn 64 actors (enough to fill 2 blocks per scheduler)
(≔ mb-count #0)
(≔ mb01 (⟳ (λ (self) #1)))
(≔ mb02 (⟳ (λ (self) #2)))
(≔ mb03 (⟳ (λ (self) #3)))
(≔ mb04 (⟳ (λ (self) #4)))
(≔ mb05 (⟳ (λ (self) #5)))
(≔ mb06 (⟳ (λ (self) #6)))
(≔ mb07 (⟳ (λ (self) #7)))
(≔ mb08 (⟳ (λ (self) #8)))
(≔ mb09 (⟳ (λ (self) #9)))
(≔ mb10 (⟳ (λ (self) #10)))
(≔ mb11 (⟳ (λ (self) #11)))
(≔ mb12 (⟳ (λ (self) #12)))
(≔ mb13 (⟳ (λ (self) #13)))
(≔ mb14 (⟳ (λ (self) #14)))
(≔ mb15 (⟳ (λ (self) #15)))
(≔ mb16 (⟳ (λ (self) #16)))
(≔ mb17 (⟳ (λ (self) #17)))
(≔ mb18 (⟳ (λ (self) #18)))
(≔ mb19 (⟳ (λ (self) #19)))
(≔ mb20 (⟳ (λ (self) #20)))
(≔ mb21 (⟳ (λ (self) #21)))
(≔ mb22 (⟳ (λ (self) #22)))
(≔ mb23 (⟳ (λ (self) #23)))
(≔ mb24 (⟳ (λ (self) #24)))
(≔ mb25 (⟳ (λ (self) #25)))
(≔ mb26 (⟳ (λ (self) #26)))
(≔ mb27 (⟳ (λ (self) #27)))
(≔ mb28 (⟳ (λ (self) #28)))
(≔ mb29 (⟳ (λ (self) #29)))
(≔ mb30 (⟳ (λ (self) #30)))
(≔ mb31 (⟳ (λ (self) #31)))
(≔ mb32 (⟳ (λ (self) #32)))
(≔ mb33 (⟳ (λ (self) #33)))
(≔ mb34 (⟳ (λ (self) #34)))
(≔ mb35 (⟳ (λ (self) #35)))
(≔ mb36 (⟳ (λ (self) #36)))
(≔ mb37 (⟳ (λ (self) #37)))
(≔ mb38 (⟳ (λ (self) #38)))
(≔ mb39 (⟳ (λ (self) #39)))
(≔ mb40 (⟳ (λ (self) #40)))
(≔ mb41 (⟳ (λ (self) #41)))
(≔ mb42 (⟳ (λ (self) #42)))
(≔ mb43 (⟳ (λ (self) #43)))
(≔ mb44 (⟳ (λ (self) #44)))
(≔ mb45 (⟳ (λ (self) #45)))
(≔ mb46 (⟳ (λ (self) #46)))
(≔ mb47 (⟳ (λ (self) #47)))
(≔ mb48 (⟳ (λ (self) #48)))
(≔ mb49 (⟳ (λ (self) #49)))
(≔ mb50 (⟳ (λ (self) #50)))
(≔ mb51 (⟳ (λ (self) #51)))
(≔ mb52 (⟳ (λ (self) #52)))
(≔ mb53 (⟳ (λ (self) #53)))
(≔ mb54 (⟳ (λ (self) #54)))
(≔ mb55 (⟳ (λ (self) #55)))
(≔ mb56 (⟳ (λ (self) #56)))
(≔ mb57 (⟳ (λ (self) #57)))
(≔ mb58 (⟳ (λ (self) #58)))
(≔ mb59 (⟳ (λ (self) #59)))
(≔ mb60 (⟳ (λ (self) #60)))
(≔ mb61 (⟳ (λ (self) #61)))
(≔ mb62 (⟳ (λ (self) #62)))
(≔ mb63 (⟳ (λ (self) #63)))
(≔ mb64 (⟳ (λ (self) #64)))
(⟳! #20000)

(⊨ (⌜ :bwos-multiblock-first) #1 (⟳→ mb01))
(⊨ (⌜ :bwos-multiblock-mid) #32 (⟳→ mb32))
(⊨ (⌜ :bwos-multiblock-last) #64 (⟳→ mb64))

; ============================================================
; Section 48: BWoS steal contention — 4 schedulers, work on sched 0 (3 assertions)
; Forces aggressive cross-scheduler stealing from multiple blocks
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #4)
(≔ sc01 (⟳ (λ (self) :sc)))
(≔ sc02 (⟳ (λ (self) :sc)))
(≔ sc03 (⟳ (λ (self) :sc)))
(≔ sc04 (⟳ (λ (self) :sc)))
(≔ sc05 (⟳ (λ (self) :sc)))
(≔ sc06 (⟳ (λ (self) :sc)))
(≔ sc07 (⟳ (λ (self) :sc)))
(≔ sc08 (⟳ (λ (self) :sc)))
(≔ sc09 (⟳ (λ (self) :sc)))
(≔ sc10 (⟳ (λ (self) :sc)))
(≔ sc11 (⟳ (λ (self) :sc)))
(≔ sc12 (⟳ (λ (self) :sc)))
(≔ sc13 (⟳ (λ (self) :sc)))
(≔ sc14 (⟳ (λ (self) :sc)))
(≔ sc15 (⟳ (λ (self) :sc)))
(≔ sc16 (⟳ (λ (self) :sc)))
(≔ sc17 (⟳ (λ (self) :sc)))
(≔ sc18 (⟳ (λ (self) :sc)))
(≔ sc19 (⟳ (λ (self) :sc)))
(≔ sc20 (⟳ (λ (self) :sc-last)))
(⟳! #10000)

(⊨ (⌜ :bwos-steal-first-done) #f (⟳? sc01))
(⊨ (⌜ :bwos-steal-last-done) #f (⟳? sc20))
(⊨ (⌜ :bwos-steal-last-result) :sc-last (⟳→ sc20))

; ============================================================
; Section 49: BWoS rapid lifecycle — 10 cycles of spawn-4 + run + drain (2 assertions)
; Tests block reuse and epoch counter advancement
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ rl01 (⟳ (λ (self) :r1)))
(≔ rl02 (⟳ (λ (self) :r2)))
(≔ rl03 (⟳ (λ (self) :r3)))
(≔ rl04 (⟳ (λ (self) :r4)))
(⟳! #200)
(⟳∅)

(⟳# #2)
(≔ rl05 (⟳ (λ (self) :r5)))
(≔ rl06 (⟳ (λ (self) :r6)))
(≔ rl07 (⟳ (λ (self) :r7)))
(≔ rl08 (⟳ (λ (self) :r8)))
(⟳! #200)
(⟳∅)

(⟳# #2)
(≔ rl09 (⟳ (λ (self) :r9)))
(≔ rl10 (⟳ (λ (self) :r10)))
(≔ rl11 (⟳ (λ (self) :r11)))
(≔ rl12 (⟳ (λ (self) :r12)))
(⟳! #200)
(⟳∅)

(⟳# #2)
(≔ rl13 (⟳ (λ (self) :r13)))
(≔ rl14 (⟳ (λ (self) :r14)))
(≔ rl15 (⟳ (λ (self) :r15)))
(≔ rl16 (⟳ (λ (self) :r16)))
(⟳! #200)
(⟳∅)

(⟳# #2)
(≔ rl17 (⟳ (λ (self) :r17)))
(≔ rl18 (⟳ (λ (self) :r18)))
(≔ rl19 (⟳ (λ (self) :r19)))
(≔ rl20 (⟳ (λ (self) :r20)))
(⟳! #200)
(⟳∅)

(⟳# #2)
(≔ rl21 (⟳ (λ (self) :r21)))
(≔ rl22 (⟳ (λ (self) :r22)))
(≔ rl23 (⟳ (λ (self) :r23)))
(≔ rl24 (⟳ (λ (self) :r24)))
(⟳! #200)
(⟳∅)

(⟳# #2)
(≔ rl25 (⟳ (λ (self) :r25)))
(≔ rl26 (⟳ (λ (self) :r26)))
(≔ rl27 (⟳ (λ (self) :r27)))
(≔ rl28 (⟳ (λ (self) :r28)))
(⟳! #200)
(⟳∅)

(⟳# #2)
(≔ rl29 (⟳ (λ (self) :r29)))
(≔ rl30 (⟳ (λ (self) :r30)))
(≔ rl31 (⟳ (λ (self) :r31)))
(≔ rl32 (⟳ (λ (self) :r32)))
(⟳! #200)
(⟳∅)

(⟳# #2)
(≔ rl33 (⟳ (λ (self) :r33)))
(≔ rl34 (⟳ (λ (self) :r34)))
(≔ rl35 (⟳ (λ (self) :r35)))
(≔ rl36 (⟳ (λ (self) :r36)))
(⟳! #200)
(⟳∅)

(⟳# #2)
(≔ rl37 (⟳ (λ (self) :r37)))
(≔ rl38 (⟳ (λ (self) :r38)))
(≔ rl39 (⟳ (λ (self) :r39)))
(≔ rl40 (⟳ (λ (self) :rl-final)))
(⟳! #200)

(⊨ (⌜ :bwos-rapid-last-dead) #f (⟳? rl40))
(⊨ (⌜ :bwos-rapid-last-result) :rl-final (⟳→ rl40))

; ============================================================
; Section 50: BWoS global overflow — 50 actors on 2 schedulers (2 assertions)
; Exercises multi-block + global queue overflow under contention
; ============================================================
(⟳∅)
(⟿∅)
(⟳⊳⊳∅)

(⟳# #2)
(≔ ov01 (⟳ (λ (self) :ov)))
(≔ ov02 (⟳ (λ (self) :ov)))
(≔ ov03 (⟳ (λ (self) :ov)))
(≔ ov04 (⟳ (λ (self) :ov)))
(≔ ov05 (⟳ (λ (self) :ov)))
(≔ ov06 (⟳ (λ (self) :ov)))
(≔ ov07 (⟳ (λ (self) :ov)))
(≔ ov08 (⟳ (λ (self) :ov)))
(≔ ov09 (⟳ (λ (self) :ov)))
(≔ ov10 (⟳ (λ (self) :ov)))
(≔ ov11 (⟳ (λ (self) :ov)))
(≔ ov12 (⟳ (λ (self) :ov)))
(≔ ov13 (⟳ (λ (self) :ov)))
(≔ ov14 (⟳ (λ (self) :ov)))
(≔ ov15 (⟳ (λ (self) :ov)))
(≔ ov16 (⟳ (λ (self) :ov)))
(≔ ov17 (⟳ (λ (self) :ov)))
(≔ ov18 (⟳ (λ (self) :ov)))
(≔ ov19 (⟳ (λ (self) :ov)))
(≔ ov20 (⟳ (λ (self) :ov)))
(≔ ov21 (⟳ (λ (self) :ov)))
(≔ ov22 (⟳ (λ (self) :ov)))
(≔ ov23 (⟳ (λ (self) :ov)))
(≔ ov24 (⟳ (λ (self) :ov)))
(≔ ov25 (⟳ (λ (self) :ov)))
(≔ ov26 (⟳ (λ (self) :ov)))
(≔ ov27 (⟳ (λ (self) :ov)))
(≔ ov28 (⟳ (λ (self) :ov)))
(≔ ov29 (⟳ (λ (self) :ov)))
(≔ ov30 (⟳ (λ (self) :ov)))
(≔ ov31 (⟳ (λ (self) :ov)))
(≔ ov32 (⟳ (λ (self) :ov)))
(≔ ov33 (⟳ (λ (self) :ov)))
(≔ ov34 (⟳ (λ (self) :ov)))
(≔ ov35 (⟳ (λ (self) :ov)))
(≔ ov36 (⟳ (λ (self) :ov)))
(≔ ov37 (⟳ (λ (self) :ov)))
(≔ ov38 (⟳ (λ (self) :ov)))
(≔ ov39 (⟳ (λ (self) :ov)))
(≔ ov40 (⟳ (λ (self) :ov)))
(≔ ov41 (⟳ (λ (self) :ov)))
(≔ ov42 (⟳ (λ (self) :ov)))
(≔ ov43 (⟳ (λ (self) :ov)))
(≔ ov44 (⟳ (λ (self) :ov)))
(≔ ov45 (⟳ (λ (self) :ov)))
(≔ ov46 (⟳ (λ (self) :ov)))
(≔ ov47 (⟳ (λ (self) :ov)))
(≔ ov48 (⟳ (λ (self) :ov)))
(≔ ov49 (⟳ (λ (self) :ov)))
(≔ ov50 (⟳ (λ (self) :ov-last)))
(⟳! #10000)

(⊨ (⌜ :bwos-overflow-first-done) #f (⟳? ov01))
(⊨ (⌜ :bwos-overflow-last-result) :ov-last (⟳→ ov50))

; ============================================================
; Cleanup
; ============================================================
(⟳⊳⊳! #f)
(⟳⊳⊳∅)
(⟳∅)
(⟿∅)
(⟳# #1)
