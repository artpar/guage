; Day 105: Flow — Lazy computation pipelines
; Primitives: ⟳⊸, ⟳⊸↦, ⟳⊸⊲, ⟳⊸⊕, ⟳⊸⊙, flow-run

;;; Test 1: flow-from-list — create flow from a list
(define f1 (flow-from (cons #1 (cons #2 (cons #3 nil)))))
(test-case (quote :flow-from-list)
  (cons #1 (cons #2 (cons #3 nil)))
  (flow-run f1))

;;; Test 2: flow-map-basic — map doubles each element
(define f2 (flow-from (cons #1 (cons #2 (cons #3 nil)))))
(flow-map f2 (lambda (x) (* x #2)))
(test-case (quote :flow-map-basic)
  (cons #2 (cons #4 (cons #6 nil)))
  (flow-run f2))

;;; Test 3: flow-filter-basic — filter even numbers
(define f3 (flow-from (cons #1 (cons #2 (cons #3 (cons #4 nil)))))
(flow-filter f3 (lambda (x) (equal? (- x (* (/ x #2) #2)) #0)))
(test-case (quote :flow-filter-basic)
  (cons #2 (cons #4 nil))
  (flow-run f3))

;;; Test 4: flow-map-filter-chain — chain map then filter
(define f4 (flow-from (cons #1 (cons #2 (cons #3 (cons #4 nil)))))
(flow-map f4 (lambda (x) (* x #10)))
(flow-filter f4 (lambda (x) (> x #25)))
(test-case (quote :flow-map-filter-chain)
  (cons #30 (cons #40 nil))
  (flow-run f4))

;;; Test 5: flow-reduce-sum — reduce to sum
(define f5 (flow-from (cons #1 (cons #2 (cons #3 (cons #4 nil)))))
(flow-reduce f5 #0 (lambda (acc x) (+ acc x)))
(test-case (quote :flow-reduce-sum)
  #10
  (flow-run f5))

;;; Test 6: flow-each-basic — side-effect collects via agent
(actor-reset)
(define ag (agent-start (lambda () nil)))
(define f6 (flow-from (cons #10 (cons #20 (cons #30 nil)))))
(flow-each f6 (lambda (x) (agent-update ag (lambda (s) (cons x s)))))
(define r6 (flow-run f6))
(test-case (quote :flow-each-basic)
  #t
  (and (equal? r6 nil)
      (equal? (agent-get ag (lambda (s) s)) (cons #30 (cons #20 (cons #10 nil))))))

;;; Test 7: flow-empty-list — flow from empty list
(define f7 (flow-from nil))
(flow-map f7 (lambda (x) (* x #2)))
(test-case (quote :flow-empty-list)
  nil
  (flow-run f7))

;;; Test 8: flow-map-filter-reduce — full pipeline
(define f8 (flow-from (cons #1 (cons #2 (cons #3 (cons #4 (cons #5 nil))))))
(flow-map f8 (lambda (x) (* x #3)))
(flow-filter f8 (lambda (x) (> x #6)))
(flow-reduce f8 #0 (lambda (acc x) (+ acc x)))
(test-case (quote :flow-map-filter-reduce)
  #36
  (flow-run f8))

;;; Test 9: flow-multiple-maps — chain multiple maps
(define f9 (flow-from (cons #1 (cons #2 (cons #3 nil))))
(flow-map f9 (lambda (x) (+ x #10)))
(flow-map f9 (lambda (x) (* x #2)))
(test-case (quote :flow-multiple-maps)
  (cons #22 (cons #24 (cons #26 nil)))
  (flow-run f9))

;;; Test 10: flow-filter-none-match — filter removes all
(define f10 (flow-from (cons #1 (cons #2 (cons #3 nil))))
(flow-filter f10 (lambda (x) (> x #100)))
(test-case (quote :flow-filter-none-match)
  nil
  (flow-run f10))
