; Test: Actor Model with Message Passing
; Day 89 - Spawn, send, receive, scheduler

; ============ Reset actors before testing ============
(actor-reset)

; ============ Basic Spawn ============

; Spawn an actor that immediately returns
(define a1 (actor-spawn (lambda (self) :done)))

; Actor should be alive before running
(test-case (quote :actor-alive-before-run) #t (actor-alive? a1))

; ============ Run and Check Result ============

; Run scheduler — actor body returns :done immediately
(actor-run #100)

; After running, actor should be dead
(test-case (quote :actor-dead-after-run) #f (actor-alive? a1))

; Get the result of finished actor
(test-case (quote :actor-result) :done (actor-result a1))

; ============ Reset for next tests ============
(actor-reset)

; ============ Send and Receive ============

; Actor that receives one message and returns it
(define a2 (actor-spawn (lambda (self) (actor-receive))))
(actor-send a2 :hello)
(actor-run #100)
(test-case (quote :send-receive-one) :hello (actor-result a2))

; ============ Reset ============
(actor-reset)

; ============ Multiple Messages (FIFO) ============

; Actor that receives two messages and returns them as a pair
; Use bind (bind) to sequence multiple receives since lambdas have single body
(define a3 (actor-spawn (lambda (self)
  (bind (actor-receive) (lambda (m1)
    (bind (actor-receive) (lambda (m2)
      (cons m1 m2))))))))

(actor-send a3 :first)
(actor-send a3 :second)
(actor-run #100)
(test-case (quote :fifo-order) (cons :first :second) (actor-result a3))

; ============ Reset ============
(actor-reset)

; ============ Send to Dead Actor ============

(define a4 (actor-spawn (lambda (self) :done)))
(actor-run #100)
(test-case (quote :send-to-dead) #t (error? (actor-send a4 :msg)))

; ============ Reset ============
(actor-reset)

; ============ Multiple Actors ============

; Two actors: one sends to the other
(define receiver (actor-spawn (lambda (self) (actor-receive))))

(define sender (actor-spawn (lambda (self)
  (bind (actor-send receiver :ping) (lambda (_) :sent)))))

(actor-run #100)
(test-case (quote :sender-result) :sent (actor-result sender))
(test-case (quote :receiver-result) :ping (actor-result receiver))

; ============ Reset ============
(actor-reset)

; ============ Actor Processes N Messages ============

; Actor that receives 3 messages, sums the numbers
(define summer (actor-spawn (lambda (self)
  (bind (actor-receive) (lambda (n1)
    (bind (actor-receive) (lambda (n2)
      (bind (actor-receive) (lambda (n3)
        (+ (+ n1 n2) n3))))))))))

(actor-send summer #10)
(actor-send summer #20)
(actor-send summer #30)
(actor-run #100)
(test-case (quote :sum-messages) #60 (actor-result summer))

; ============ Reset ============
(actor-reset)

; ============ Scheduler Tick Count ============

; Spawn actor that finishes immediately
(define quick (actor-spawn (lambda (self) #42)))
(define ticks (actor-run #100))
; Should have run at least 1 tick
(test-case (quote :ticks-ran) #t (> ticks #0))

; ============ Reset ============
(actor-reset)

; ============ Actor Still Running Error ============

(define waiting (actor-spawn (lambda (self) (actor-receive))))
; Don't run scheduler — actor is still alive
(test-case (quote :result-while-running) #t (error? (actor-result waiting)))

; ============ Reset ============
(actor-reset)

; ============ Self Reference ============

; Actor behavior receives self and can check it's alive
(define self-aware (actor-spawn (lambda (self) (actor-alive? self))))
(actor-run #100)
; While running, self was alive -> returns #t
(test-case (quote :self-ref-alive) #t (actor-result self-aware))
