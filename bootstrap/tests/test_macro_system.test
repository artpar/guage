; Test suite for macro system (Day 33)
; =========================================

; Test 1: Simple macro definition
; arity should return the macro name
(test-case :macro-def-simple (quote when) (macro when (c b) (quasiquote-tilde (if (~ c) (~ b) nil))))

; Test 2: Macro usage - when with true condition
(macro when (condition body) (quasiquote-tilde (if (~ condition) (~ body) nil)))
(test-case :when-true #42 (when #t #42))

; Test 3: Macro usage - when with false condition
(test-case :when-false nil (when #f #42))

; Test 4: Macro with computation
(test-case :when-with-computation #10 (when #t (+ #5 #5)))

; Test 5: Let-style binding macro
(macro let (var value body) (quasiquote-tilde ((lambda (x) (~ body)) (~ value))))
(test-case :let-binding #43 (let x #42 (+ x #1)))

; Test 6: Let with complex computation
(test-case :let-complex #15 (let x (+ #5 #5) (+ x #5)))

; Test 7: Unless macro (opposite of when)
(macro unless (condition body) (quasiquote-tilde (if (~ condition) nil (~ body))))
(test-case :unless-false #42 (unless #f #42))

; Test 8: Unless with true condition
(test-case :unless-true nil (unless #t #42))

; Test 9: Multi-parameter macro
(macro add3 (a b c) (quasiquote-tilde (+ (~ a) (+ (~ b) (~ c)))))
(test-case :add3 #6 (add3 #1 #2 #3))

; Test 10: Macro with nested operations
(macro double-sum (x y) (quasiquote-tilde (* #2 (+ (~ x) (~ y)))))
(test-case :double-sum #20 (double-sum #5 #5))

; Test 11: Nested macro calls - macro uses result of another macro
(macro twice (expr) (quasiquote-tilde (+ (~ expr) (~ expr))))
(test-case :nested-twice #84 (twice (twice #21)))

; Test 12: Macro calling other macros
(macro if-positive (x then else) (quasiquote-tilde (if (> (~ x) #0) (~ then) (~ else))))
(test-case :macro-calls-macro #5 (if-positive #3 #5 #0))
(test-case :macro-calls-macro-neg #0 (if-positive (- #0 #3) #5 #0))

; Test 13: Macro with conditional expansion
(macro safe-div (x y) (quasiquote-tilde (if (equal? (~ y) #0) (error :div-by-zero nil) (/ (~ x) (~ y)))))
(test-case :safe-div-normal #5 (safe-div #10 #2))
(test-case :safe-div-error #t (error? (safe-div #10 #0)))

; Test 14: Macro redefining macro
(macro test-redef (x) (quasiquote-tilde (+ (~ x) #1)))
(test-case :test-redef-v1 #6 (test-redef #5))
(macro test-redef (x) (quasiquote-tilde (* (~ x) #2)))
(test-case :test-redef-v2 #10 (test-redef #5))

; Test 15: Macro with multiple expansions in sequence
(macro inc (x) (quasiquote-tilde (+ (~ x) #1)))
(test-case :inc-chain #7 (inc (inc (inc #4))))

; ===== Additional advanced tests =====

; Test 16: Macro generating comparisons
(macro between (x lo hi) (quasiquote-tilde (and (> (~ x) (~ lo)) (< (~ x) (~ hi)))))
(test-case :between-true #t (between #5 #0 #10))
(test-case :between-false #f (between #15 #0 #10))

; Test 17: Macro for pair operations
(macro first-of (pair) (quasiquote-tilde (car (~ pair))))
(macro second-of (pair) (quasiquote-tilde (cdr (~ pair))))
(test-case :first-of #1 (first-of (cons #1 #2)))
(test-case :second-of #2 (second-of (cons #1 #2)))

; Test 18: Macro with side effects (printing)
(macro debug (x) (quasiquote-tilde (trace (~ x))))
(test-case :debug-returns-value #42 (debug #42))

; Test 19: Macro with assertion
(macro assert-positive (x) (quasiquote-tilde (assert (> (~ x) #0) :not-positive)))
(test-case :assert-positive-ok #t (assert-positive #5))
(test-case :assert-positive-fail #t (error? (assert-positive (- #0 #5))))

; Test 20: Complex macro - conditional binding
(macro when-let (var test then else)
  (quasiquote-tilde (if (~ test)
        ((lambda (x) (~ then)) (~ test))
        (~ else))))
(test-case :when-let-true #11 (when-let x #t (+ #10 #1) #99))

; Summary
(print "âœ“ 20 macro system tests")
