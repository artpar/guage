; ═══════════════════════════════════════════════════════════════
; Test: Iteration Macros - Part 1 (Day 81)
; ═══════════════════════════════════════════════════════════════
; Tests for stdlib iteration/sequencing macros
; - ⊎ (begin/progn) - sequence expressions
; - ⊲* (for-each) - iterate with side effects
; - actor-spawn (dotimes) - repeat n times
; - ⊎↦ (list comprehension syntax)
; ═══════════════════════════════════════════════════════════════

(load "bootstrap/stdlib/macros_iteration.scm")

; ═══════════════════════════════════════════════════════════════
; ⊎ (begin/progn) - Sequence expressions, return last
; ═══════════════════════════════════════════════════════════════

; Single expression - just returns it
(test-case (quote :begin-single) #42 (⊎ #42))

; Two expressions - returns last
(test-case (quote :begin-two) #2 (⊎ #1 #2))

; Three expressions - returns last
(test-case (quote :begin-three) #3 (⊎ #1 #2 #3))

; Five expressions - returns last
(test-case (quote :begin-five) #5 (⊎ #1 #2 #3 #4 #5))

; Ten expressions - returns last
(test-case (quote :begin-ten) #10 (⊎ #1 #2 #3 #4 #5 #6 #7 #8 #9 #10))

; With trace side effects - all execute, returns last
(test-case (quote :begin-with-trace) :done (⊎ (trace :a) (trace :b) :done))

; Nested begin
(test-case (quote :begin-nested) #9 (⊎ (⊎ #1 #2) (⊎ #3 #9)))

; Begin with computation
(test-case (quote :begin-compute) #6 (⊎ (+ #1 #2) (+ #2 #3) (+ #1 #5)))

; ═══════════════════════════════════════════════════════════════
; ⊲* (for-each) - Iterate over list with side effects
; ═══════════════════════════════════════════════════════════════

; For-each returns nil after iteration
(test-case (quote :foreach-empty) nil (⊲* (lambda (x) x) nil))

; For-each on single element list
(test-case (quote :foreach-single) nil (⊲* (lambda (x) (* x #2)) (cons #5 nil)))

; For-each on multiple elements - returns nil
(test-case (quote :foreach-multi) nil (⊲* (lambda (x) x) (cons #1 (cons #2 (cons #3 nil)))))

; For-each with trace (side effect)
(test-case (quote :foreach-trace) nil (⊲* (lambda (x) (trace x)) (cons :a (cons :b (cons :c nil)))))

; ═══════════════════════════════════════════════════════════════
; actor-spawn (dotimes) - Repeat body n times
; ═══════════════════════════════════════════════════════════════

; Zero times - returns nil
(test-case (quote :dotimes-zero) nil (actor-spawn #0 :body))

; One time - returns nil after execution
(test-case (quote :dotimes-one) nil (actor-spawn #1 :body))

; Multiple times - returns nil
(test-case (quote :dotimes-five) nil (actor-spawn #5 :body))

; With trace (verify side effect)
(test-case (quote :dotimes-trace) nil (actor-spawn #3 (trace :tick)))

; ═══════════════════════════════════════════════════════════════
; ⊎↦ (list comprehension) - Build list from pattern
; ═══════════════════════════════════════════════════════════════

; Simple list comprehension - double each
(test-case (quote :listcomp-double)
   (cons #2 (cons #4 (cons #6 nil)))
   (⊎↦ (* :x #2) (:x (cons #1 (cons #2 (cons #3 nil))))))

; Identity list comprehension
(test-case (quote :listcomp-identity)
   (cons #1 (cons #2 (cons #3 nil)))
   (⊎↦ :x (:x (cons #1 (cons #2 (cons #3 nil))))))

; List comprehension with complex expression
(test-case (quote :listcomp-complex)
   (cons #10 (cons #20 (cons #30 nil)))
   (⊎↦ (* :n #10) (:n (cons #1 (cons #2 (cons #3 nil))))))

; Empty list comprehension
(test-case (quote :listcomp-empty)
   nil
   (⊎↦ :x (:x nil)))

; ═══════════════════════════════════════════════════════════════
; Summary: 20 iteration macro tests (Part 1)
; ═══════════════════════════════════════════════════════════════

"✓ 20 iteration macro tests (Part 1) passed"
