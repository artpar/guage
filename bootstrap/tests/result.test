;;; Result/Either Type Tests
;;; Tests for railway-oriented programming utilities

;; Load Result library
(load "bootstrap/stdlib/result.scm")

;; ============================================================================
;; Basic Constructors
;; ============================================================================

(test-case :ok-constructor
   (adt-create :Result :Ok #42)
   (ok #42))

(test-case :err-constructor
   (adt-create :Result :Err :div-by-zero)
   (err :div-by-zero))

;; ============================================================================
;; Predicates
;; ============================================================================

(test-case :ok?-on-ok
   #t
   (ok? (ok #42)))

(test-case :ok?-on-err
   #f
   (ok? (err :fail)))

(test-case :err?-on-err
   #t
   (err? (err :fail)))

(test-case :err?-on-ok
   #f
   (err? (ok #42)))

;; ============================================================================
;; Map - Transform success value
;; ============================================================================

(test-case :map-on-ok
   (ok #84)
   ((map (lambda (ğ•©) (* ğ•© #2))) (ok #42)))

(test-case :map-on-err
   (err :fail)
   ((map (lambda (ğ•©) (* ğ•© #2))) (err :fail)))

(test-case :map-chain
   (ok #12)
   ((map (lambda (ğ•©) (+ ğ•© #2)))
    ((map (lambda (ğ•©) (* ğ•© #2)))
     (ok #5))))

;; ============================================================================
;; Map-Err - Transform error value
;; ============================================================================

(test-case :map-err-on-err
   (err :FAIL)
   ((map-err (lambda (ğ•©) :FAIL)) (err :fail)))

(test-case :map-err-on-ok
   (ok #42)
   ((map-err (lambda (ğ•©) :FAIL)) (ok #42)))

;; ============================================================================
;; Flatmap - Monadic bind for Result
;; ============================================================================

(test-case :flatmap-ok-to-ok
   (ok #84)
   ((flatmap (lambda (ğ•©) (ok (* ğ•© #2)))) (ok #42)))

(test-case :flatmap-ok-to-err
   (err :too-large)
   ((flatmap (lambda (ğ•©) (if (> ğ•© #100) (err :too-large) (ok ğ•©))))
    (ok #200)))

(test-case :flatmap-err-propagation
   (err :initial-fail)
   ((flatmap (lambda (ğ•©) (ok (* ğ•© #2)))) (err :initial-fail)))

(test-case :flatmap-chain
   (ok #14)
   ((flatmap (lambda (ğ•©) (ok (+ ğ•© #2))))
    ((flatmap (lambda (ğ•©) (ok (* ğ•© #2))))
     (ok #6))))

(test-case :flatmap-chain-with-error
   (err :negative)
   ((flatmap (lambda (ğ•©) (ok (+ ğ•© #2))))
    ((flatmap (lambda (ğ•©) (if (< ğ•© #0) (err :negative) (ok (* ğ•© #2)))))
     (ok #-5))))

;; ============================================================================
;; Fold - Eliminate Result to single value
;; ============================================================================

(test-case :fold-on-ok
   #42
   (((fold (lambda (ğ•©) ğ•©)) (lambda (ğ•©) #0)) (ok #42)))

(test-case :fold-on-err
   #99
   (((fold (lambda (ğ•©) #0)) (lambda (ğ•©) #99)) (err :fail)))

(test-case :fold-with-computation
   #84
   (((fold (lambda (ğ•©) (* ğ•© #2))) (lambda (ğ•©) #0)) (ok #42)))

;; ============================================================================
;; Unwrap - Extract value or error
;; ============================================================================

(test-case :unwrap-ok
   #42
   (unwrap (ok #42)))

(test-case :unwrap-err-is-error
   #t
   (error? (unwrap (err :fail))))

(test-case :unwrap-or-on-ok
   #42
   ((unwrap-or #99) (ok #42)))

(test-case :unwrap-or-on-err
   #99
   ((unwrap-or #99) (err :fail)))

(test-case :unwrap-err-on-err
   :fail
   (unwrap-err (err :fail)))

(test-case :unwrap-err-on-ok-is-error
   #t
   (error? (unwrap-err (ok #42))))

;; ============================================================================
;; Combinators - and-then, or-else
;; ============================================================================

(test-case :and-then-ok-ok
   (ok #2)
   ((and-then (ok #1)) (ok #2)))

(test-case :and-then-ok-err
   (err :second-fail)
   ((and-then (ok #1)) (err :second-fail)))

(test-case :and-then-err-ok
   (err :first-fail)
   ((and-then (err :first-fail)) (ok #2)))

(test-case :and-then-err-err
   (err :first-fail)
   ((and-then (err :first-fail)) (err :second-fail)))

(test-case :or-else-ok-ok
   (ok #1)
   ((or-else (ok #1)) (ok #2)))

(test-case :or-else-ok-err
   (ok #1)
   ((or-else (ok #1)) (err :fail)))

(test-case :or-else-err-ok
   (ok #2)
   ((or-else (err :fail)) (ok #2)))

(test-case :or-else-err-err
   (err :second-fail)
   ((or-else (err :first-fail)) (err :second-fail)))

;; ============================================================================
;; Real-World Examples
;; ============================================================================

;; Safe division
(define safe-div (lambda (ğ•©) (lambda (ğ•ª)
  (if (equal? ğ•ª #0)
     (err :div-by-zero)
     (ok (/ ğ•© ğ•ª))))))

(test-case :safe-div-ok
   (ok #5)
   ((safe-div #10) #2))

(test-case :safe-div-err
   (err :div-by-zero)
   ((safe-div #10) #0))

;; Validation chain
(define validate-positive (lambda (ğ•©)
  (if (> ğ•© #0)
     (ok ğ•©)
     (err :not-positive))))

(define validate-even (lambda (ğ•©)
  (if (equal? (% ğ•© #2) #0)
     (ok ğ•©)
     (err :not-even))))

(test-case :validation-chain-ok
   (ok #4)
   ((flatmap validate-even)
    ((flatmap validate-positive) (ok #4))))

(test-case :validation-chain-fail-first
   (err :not-positive)
   ((flatmap validate-even)
    ((flatmap validate-positive) (ok #-4))))

(test-case :validation-chain-fail-second
   (err :not-even)
   ((flatmap validate-even)
    ((flatmap validate-positive) (ok #3))))

;; Railway-oriented programming - computation pipeline
(define parse-int (lambda (ğ•©)
  (if (number? ğ•©)
     (ok ğ•©)
     (err :not-a-number))))

(define validate-range (lambda (ğ•©)
  (if (and (>= ğ•© #0) (<= ğ•© #100))
     (ok ğ•©)
     (err :out-of-range))))

(define compute (lambda (ğ•©)
  (ok (* ğ•© #2))))

(define pipeline (lambda (ğ•©)
  ((flatmap compute)
   ((flatmap validate-range)
    (parse-int ğ•©)))))

(test-case :pipeline-ok
   (ok #100)
   (pipeline #50))

(test-case :pipeline-fail-parse
   (err :not-a-number)
   (pipeline :not-a-number))

(test-case :pipeline-fail-range
   (err :out-of-range)
   (pipeline #200))

;; Multiple error handling with or-else
(define try-first (lambda (ğ•©)
  (if (> ğ•© #10)
     (ok ğ•©)
     (err :too-small))))

(define try-second (lambda (ğ•©)
  (if (equal? ğ•© #5)
     (ok (* ğ•© #10))
     (err :not-five))))

(test-case :fallback-first-succeeds
   (ok #20)
   ((or-else (try-first #20)) (try-second #20)))

(test-case :fallback-second-succeeds
   (ok #50)
   ((or-else (try-first #5)) (try-second #5)))

(test-case :fallback-both-fail
   (err :not-five)
   ((or-else (try-first #3)) (try-second #3)))

;; ============================================================================
;; Summary
;; ============================================================================

(print "")
(print "Result Type Tests Complete!")
(print "âœ“ All railway-oriented programming patterns working")
