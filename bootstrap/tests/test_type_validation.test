#!/usr/bin/env guage
; Test suite for type validation (Day 84)
; Compiler-level type checking for declared types

(â‰‹ "Testing Type Validation...")

; ============================================================================
; Test: âˆˆâœ“ (Validate single binding)
; ============================================================================

(â‰‹ "\nTesting âˆˆâœ“ (validate binding)...")

; Declare and validate - correct type
(â‰” val-ok #42)
(âˆˆ val-ok (â„¤))

(âŠ¨ :validate-int-ok
   #t
   (âˆˆâœ“ val-ok))

; Declare string with correct type
(â‰” str-ok "hello")
(âˆˆ str-ok (ğ•Š))

(âŠ¨ :validate-string-ok
   #t
   (âˆˆâœ“ str-ok))

; Declare bool with correct type
(â‰” bool-ok #t)
(âˆˆ bool-ok (ğ”¹))

(âŠ¨ :validate-bool-ok
   #t
   (âˆˆâœ“ bool-ok))

; Declare nil with correct type
(â‰” nil-ok âˆ…)
(âˆˆ nil-ok (âˆ…â‚œ))

(âŠ¨ :validate-nil-ok
   #t
   (âˆˆâœ“ nil-ok))

; Undeclared binding - no type to validate, returns #t (vacuously true)
(â‰” undeclared #99)

(âŠ¨ :validate-undeclared
   #t
   (âˆˆâœ“ undeclared))

; ============================================================================
; Test: âˆˆâœ“ with type mismatches (returns error)
; ============================================================================

(â‰‹ "Testing âˆˆâœ“ with type mismatches...")

; Declare int but value is string - should error
(â‰” bad-int "not-an-int")
(âˆˆ bad-int (â„¤))

(âŠ¨ :validate-bad-int
   #t
   (âš ? (âˆˆâœ“ bad-int)))

; Declare string but value is int - should error
(â‰” bad-string #123)
(âˆˆ bad-string (ğ•Š))

(âŠ¨ :validate-bad-string
   #t
   (âš ? (âˆˆâœ“ bad-string)))

; Declare bool but value is int - should error
(â‰” bad-bool #0)
(âˆˆ bad-bool (ğ”¹))

(âŠ¨ :validate-bad-bool
   #t
   (âš ? (âˆˆâœ“ bad-bool)))

; ============================================================================
; Test: âˆˆâœ“ with function types
; ============================================================================

(â‰‹ "Testing âˆˆâœ“ with function types...")

; Correct function type
(â‰” fn-ok (Î» (x) (âŠ• x #1)))
(âˆˆ fn-ok (â†’ (â„¤) (â„¤)))

(âŠ¨ :validate-fn-ok
   #t
   (âˆˆâœ“ fn-ok))

; Non-function declared as function - should error
(â‰” fn-bad #42)
(âˆˆ fn-bad (â†’ (â„¤) (â„¤)))

(âŠ¨ :validate-fn-bad
   #t
   (âš ? (âˆˆâœ“ fn-bad)))

; ============================================================================
; Test: âˆˆâœ“ with list types
; ============================================================================

(â‰‹ "Testing âˆˆâœ“ with list types...")

; Correct list type
(â‰” list-ok (âŸ¨âŸ© #1 (âŸ¨âŸ© #2 (âŸ¨âŸ© #3 âˆ…))))
(âˆˆ list-ok ([]â‚œ (â„¤)))

(âŠ¨ :validate-list-ok
   #t
   (âˆˆâœ“ list-ok))

; Empty list - valid for any list type
(â‰” list-empty âˆ…)
(âˆˆ list-empty ([]â‚œ (â„¤)))

(âŠ¨ :validate-list-empty
   #t
   (âˆˆâœ“ list-empty))

; Non-list declared as list - should error
(â‰” list-bad #42)
(âˆˆ list-bad ([]â‚œ (â„¤)))

(âŠ¨ :validate-list-bad
   #t
   (âš ? (âˆˆâœ“ list-bad)))

; ============================================================================
; Test: âˆˆâœ“ with union types
; ============================================================================

(â‰‹ "Testing âˆˆâœ“ with union types...")

; Union type - int matches int|string
(â‰” union-int #42)
(âˆˆ union-int (âˆªâ‚œ (â„¤) (ğ•Š)))

(âŠ¨ :validate-union-int
   #t
   (âˆˆâœ“ union-int))

; Union type - string matches int|string
(â‰” union-str "hello")
(âˆˆ union-str (âˆªâ‚œ (â„¤) (ğ•Š)))

(âŠ¨ :validate-union-str
   #t
   (âˆˆâœ“ union-str))

; Union type - bool doesn't match int|string
(â‰” union-bad #t)
(âˆˆ union-bad (âˆªâ‚œ (â„¤) (ğ•Š)))

(âŠ¨ :validate-union-bad
   #t
   (âš ? (âˆˆâœ“ union-bad)))

; ============================================================================
; Test: âˆˆâœ“ with any type (âŠ¤)
; ============================================================================

(â‰‹ "Testing âˆˆâœ“ with any type...")

; Any type always validates
(â‰” any-int #42)
(âˆˆ any-int (âŠ¤))

(âŠ¨ :validate-any-int
   #t
   (âˆˆâœ“ any-int))

(â‰” any-str "hello")
(âˆˆ any-str (âŠ¤))

(âŠ¨ :validate-any-str
   #t
   (âˆˆâœ“ any-str))

(â‰” any-fn (Î» (x) x))
(âˆˆ any-fn (âŠ¤))

(âŠ¨ :validate-any-fn
   #t
   (âˆˆâœ“ any-fn))

; ============================================================================
; Test: âˆˆâœ“* (Validate ALL declared types)
; ============================================================================

(â‰‹ "Testing âˆˆâœ“* (validate all)...")

; Note: Previous tests intentionally created mismatched types (bad-int, etc.)
; So âˆˆâœ“* will correctly return errors for those

; âˆˆâœ“* returns error if ANY declared type doesn't match
; Since we have bad-int, bad-string, bad-bool, etc. from earlier tests,
; this will return an error (which is the correct behavior)
(âŠ¨ :validate-all-has-errors
   #t
   (âš ? (âˆˆâœ“*)))

; ============================================================================
; Test: âˆˆâŠ¢ (Type-check function application)
; ============================================================================

(â‰‹ "Testing âˆˆâŠ¢ (type-check application)...")

; Setup function with declared type
(â‰” add-fn (Î» (x y) (âŠ• x y)))
(âˆˆ add-fn (â†’ (â„¤) (â„¤) (â„¤)))

; Check if application is type-safe
(âŠ¨ :typecheck-app-ok
   #t
   (âˆˆâŠ¢ add-fn #1 #2))

; Check with wrong argument type - should error
(âŠ¨ :typecheck-app-bad
   #t
   (âš ? (âˆˆâŠ¢ add-fn "not-int" #2)))

; Function without declared type - vacuously passes
(â‰” untyped-fn (Î» (x) x))

(âŠ¨ :typecheck-untyped
   #t
   (âˆˆâŠ¢ untyped-fn "anything"))

; ============================================================================
; Test: âˆˆâŠ¢ with curried functions
; ============================================================================

(â‰‹ "Testing âˆˆâŠ¢ with curried functions...")

; Curried add
(â‰” curry-add (Î» (x) (Î» (y) (âŠ• x y))))
(âˆˆ curry-add (â†’ (â„¤) (â†’ (â„¤) (â„¤))))

; Check first application
(âŠ¨ :typecheck-curry-first
   #t
   (âˆˆâŠ¢ curry-add #5))

; Check with wrong type
(âŠ¨ :typecheck-curry-bad
   #t
   (âš ? (âˆˆâŠ¢ curry-add "bad")))

; ============================================================================
; Integration: Type validation workflow
; ============================================================================

(â‰‹ "Testing integration workflows...")

; Define module with types (use simple int return type)
(â‰” double-it (Î» (x) (âŠ— x #2)))
(âˆˆ double-it (â†’ (â„¤) (â„¤)))

; Validate before use
(âŠ¨ :workflow-validate
   #t
   (âˆˆâœ“ double-it))

; Type-check application
(âŠ¨ :workflow-typecheck
   #t
   (âˆˆâŠ¢ double-it #10))

; Actual usage
(âŠ¨ :workflow-use
   #20
   (double-it #10))

(â‰‹ "\nâœ… All type validation tests passed!")
