#!/usr/bin/env guage
; Test suite for type validation (Day 84)
; Compiler-level type checking for declared types

(print "Testing Type Validation...")

; ============================================================================
; Test: type-validate (Validate single binding)
; ============================================================================

(print "\nTesting type-validate (validate binding)...")

; Declare and validate - correct type
(define val-ok #42)
(type-decl val-ok (Int))

(test-case :validate-int-ok
   #t
   (type-validate val-ok))

; Declare string with correct type
(define str-ok "hello")
(type-decl str-ok (String))

(test-case :validate-string-ok
   #t
   (type-validate str-ok))

; Declare bool with correct type
(define bool-ok #t)
(type-decl bool-ok (Bool))

(test-case :validate-bool-ok
   #t
   (type-validate bool-ok))

; Declare nil with correct type
(define nil-ok nil)
(type-decl nil-ok (Nil-type))

(test-case :validate-nil-ok
   #t
   (type-validate nil-ok))

; Undeclared binding - no type to validate, returns #t (vacuously true)
(define undeclared #99)

(test-case :validate-undeclared
   #t
   (type-validate undeclared))

; ============================================================================
; Test: type-validate with type mismatches (returns error)
; ============================================================================

(print "Testing type-validate with type mismatches...")

; Declare int but value is string - should error
(define bad-int "not-an-int")
(type-decl bad-int (Int))

(test-case :validate-bad-int
   #t
   (error? (type-validate bad-int)))

; Declare string but value is int - should error
(define bad-string #123)
(type-decl bad-string (String))

(test-case :validate-bad-string
   #t
   (error? (type-validate bad-string)))

; Declare bool but value is int - should error
(define bad-bool #0)
(type-decl bad-bool (Bool))

(test-case :validate-bad-bool
   #t
   (error? (type-validate bad-bool)))

; ============================================================================
; Test: type-validate with function types
; ============================================================================

(print "Testing type-validate with function types...")

; Correct function type
(define fn-ok (lambda (x) (+ x #1)))
(type-decl fn-ok (-> (Int) (Int)))

(test-case :validate-fn-ok
   #t
   (type-validate fn-ok))

; Non-function declared as function - should error
(define fn-bad #42)
(type-decl fn-bad (-> (Int) (Int)))

(test-case :validate-fn-bad
   #t
   (error? (type-validate fn-bad)))

; ============================================================================
; Test: type-validate with list types
; ============================================================================

(print "Testing type-validate with list types...")

; Correct list type
(define list-ok (cons #1 (cons #2 (cons #3 nil))))
(type-decl list-ok (List-type (Int)))

(test-case :validate-list-ok
   #t
   (type-validate list-ok))

; Empty list - valid for any list type
(define list-empty nil)
(type-decl list-empty (List-type (Int)))

(test-case :validate-list-empty
   #t
   (type-validate list-empty))

; Non-list declared as list - should error
(define list-bad #42)
(type-decl list-bad (List-type (Int)))

(test-case :validate-list-bad
   #t
   (error? (type-validate list-bad)))

; ============================================================================
; Test: type-validate with union types
; ============================================================================

(print "Testing type-validate with union types...")

; Union type - int matches int|string
(define union-int #42)
(type-decl union-int (Union-type (Int) (String)))

(test-case :validate-union-int
   #t
   (type-validate union-int))

; Union type - string matches int|string
(define union-str "hello")
(type-decl union-str (Union-type (Int) (String)))

(test-case :validate-union-str
   #t
   (type-validate union-str))

; Union type - bool doesn't match int|string
(define union-bad #t)
(type-decl union-bad (Union-type (Int) (String)))

(test-case :validate-union-bad
   #t
   (error? (type-validate union-bad)))

; ============================================================================
; Test: type-validate with any type (Any)
; ============================================================================

(print "Testing type-validate with any type...")

; Any type always validates
(define any-int #42)
(type-decl any-int (Any))

(test-case :validate-any-int
   #t
   (type-validate any-int))

(define any-str "hello")
(type-decl any-str (Any))

(test-case :validate-any-str
   #t
   (type-validate any-str))

(define any-fn (lambda (x) x))
(type-decl any-fn (Any))

(test-case :validate-any-fn
   #t
   (type-validate any-fn))

; ============================================================================
; Test: type-validate-all (Validate ALL declared types)
; ============================================================================

(print "Testing type-validate-all (validate all)...")

; Note: Previous tests intentionally created mismatched types (bad-int, etc.)
; So type-validate-all will correctly return errors for those

; type-validate-all returns error if ANY declared type doesn't match
; Since we have bad-int, bad-string, bad-bool, etc. from earlier tests,
; this will return an error (which is the correct behavior)
(test-case :validate-all-has-errors
   #t
   (error? (type-validate-all)))

; ============================================================================
; Test: type-assert (Type-check function application)
; ============================================================================

(print "Testing type-assert (type-check application)...")

; Setup function with declared type
(define add-fn (lambda (x y) (+ x y)))
(type-decl add-fn (-> (Int) (Int) (Int)))

; Check if application is type-safe
(test-case :typecheck-app-ok
   #t
   (type-assert add-fn #1 #2))

; Check with wrong argument type - should error
(test-case :typecheck-app-bad
   #t
   (error? (type-assert add-fn "not-int" #2)))

; Function without declared type - vacuously passes
(define untyped-fn (lambda (x) x))

(test-case :typecheck-untyped
   #t
   (type-assert untyped-fn "anything"))

; ============================================================================
; Test: type-assert with curried functions
; ============================================================================

(print "Testing type-assert with curried functions...")

; Curried add
(define curry-add (lambda (x) (lambda (y) (+ x y))))
(type-decl curry-add (-> (Int) (-> (Int) (Int))))

; Check first application
(test-case :typecheck-curry-first
   #t
   (type-assert curry-add #5))

; Check with wrong type
(test-case :typecheck-curry-bad
   #t
   (error? (type-assert curry-add "bad")))

; ============================================================================
; Integration: Type validation workflow
; ============================================================================

(print "Testing integration workflows...")

; Define module with types (use simple int return type)
(define double-it (lambda (x) (* x #2)))
(type-decl double-it (-> (Int) (Int)))

; Validate before use
(test-case :workflow-validate
   #t
   (type-validate double-it))

; Type-check application
(test-case :workflow-typecheck
   #t
   (type-assert double-it #10))

; Actual usage
(test-case :workflow-use
   #20
   (double-it #10))

(print "\nâœ… All type validation tests passed!")
