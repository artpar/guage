#!/usr/bin/env guage
; Test suite for generics and traits

(print "Testing Generics & Traits...")

; --- generic-param generic parameter extraction + instantiation ---

; Generic identity (curried): generic-param marks T as type param in lambda
(define id (lambda (generic-param T) (lambda (x) x)))

; Instantiate with a type and apply via regular function application
(test-case :generic-identity-number
   #42
   ((id :Number) #42))

(test-case :generic-identity-bool
   #t
   ((id :Bool) #t))

; --- runtime-type-of runtime type-of ---

(test-case :type-of-number
   :Number
   (runtime-type-of #42))

(test-case :type-of-bool
   :Bool
   (runtime-type-of #t))

(test-case :type-of-nil
   :Nil
   (runtime-type-of nil))

(test-case :type-of-lambda
   :Lambda
   (runtime-type-of (lambda (x) x)))

(test-case :type-of-pair
   :Pair
   (runtime-type-of (cons #1 #2)))

(test-case :type-of-symbol
   :Symbol
   (runtime-type-of :foo))

(test-case :type-of-error
   :Error
   (runtime-type-of (error :test nil)))

; --- trait-define trait define ---

; Define trait with quoted list of required ops
(trait-define :Showable (cons :show (cons :format nil)))

(test-case :trait-ops-showable
   #t
   (pair? (trait-ops :Showable)))

; --- trait-implement trait implement ---

(define show-num (lambda (x) x))
(define format-num (lambda (x) x))

; Build impl alist: ((:show . show-num) (:format . format-num))
(trait-implement :Number :Showable
     (cons (cons :show show-num) (cons (cons :format format-num) nil)))

; --- trait? trait check ---

(test-case :trait-check-satisfied
   #t
   (trait? :Number :Showable))

(test-case :trait-check-not-satisfied
   #f
   (trait? :String :Showable))

; --- trait-ops trait ops listing ---

(test-case :trait-ops-unknown
   #t
   (null? (trait-ops :NonExistent)))

; --- trait-dispatch trait dispatch ---

(test-case :trait-dispatch-missing-error
   #t
   (error? (trait-dispatch :String :Showable :show)))

; --- Trait defaults ---

; Define trait with defaults
(define default-show (lambda (x) x))
(define default-fmt (lambda (x) x))
(trait-define :Printable
     (cons :show (cons :format nil))
     (cons (cons :show default-show) (cons (cons :format default-fmt) nil)))

; Override only :show for :Number
(define num-show (lambda (x) x))
(trait-implement :Number :Printable
     (cons (cons :show num-show) nil))

; Dispatch :show should use override
(test-case :trait-dispatch-override
   #42
   ((trait-dispatch :Number :Printable :show) #42))

; Dispatch :format should fall back to default
(test-case :trait-dispatch-default-fallback
   #99
   ((trait-dispatch :Number :Printable :format) #99))

; trait-defaults returns defaults alist
(test-case :trait-defaults-exists
   #t
   (pair? (trait-defaults :Printable)))

(test-case :trait-defaults-nil-for-unknown
   #t
   (null? (trait-defaults :NonExistent)))

; --- Trait constraints ---

; Define constrained generic: (generic-param T :Showable) constrains T
(define show-it (lambda (generic-param T :Showable) (lambda (x) ((trait-dispatch T :Showable :show) x))))

; :Number implements :Showable — should work
(test-case :constraint-satisfied
   #42
   ((show-it :Number) #42))

; :String does NOT implement :Showable — should error
(test-case :constraint-unsatisfied
   #t
   (error? (show-it :String)))

(print "\nGenerics & traits tests complete.")
