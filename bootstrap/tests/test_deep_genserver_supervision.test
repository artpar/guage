;;;
;;; Deep Integration: GenServer + Supervisors + Pattern Matching + Channels + ETS
;;;

(actor-reset)
(chan-reset)

;;; --- Supervisor creates GenServer child, client calls it ---

(define echo-server (lambda (self)
  (bind (actor-receive) (lambda (msg)
    (bind (actor-reply (car (cdr msg)) (car (cdr (cdr msg)))) (lambda (_) :done))))))

(define sup1 (sup-start :one-for-one (cons echo-server nil)))
(actor-run #100)

(define kids1 (sup-children sup1))
(define srv1 (car kids1))

(define c1 (actor-spawn (lambda (self) (actor-call srv1 :ping))))
(actor-run #100)

(test-case :sup-genserver-call :ping (actor-result c1))

;;; --- GenServer crashes, supervisor restarts -> new incarnation ---

(define crash-server (lambda (self)
  (bind (actor-receive) (lambda (msg)
    (if (equal? msg :crash)
       (/ #1 #0)
       msg)))))

(define sup2 (sup-start :one-for-one (cons crash-server nil)))
(actor-run #100)

(define kids2a (sup-children sup2))
(define old-srv (car kids2a))

;;; Crash it
(actor-send old-srv :crash)
(actor-run #200)

;;; --- Old incarnation dead, new incarnation alive after restart ---
(define kids2b (sup-children sup2))
(define new-srv (car kids2b))

(test-case :old-dead  #f (actor-alive? old-srv))
(test-case :new-alive #t (actor-alive? new-srv))
(test-case :different-ids #f (equal? old-srv new-srv))

;;; --- GenServer dispatches on message shape (pair vs atom) ---

(define dispatch-server (lambda (self)
  (bind (actor-receive) (lambda (msg)
    (bind (actor-reply (car (cdr msg))
      (if (pair? (car (cdr (cdr msg))))
         (+ (car (car (cdr (cdr msg)))) (cdr (car (cdr (cdr msg)))))
         (* (car (cdr (cdr msg))) #2)))
    (lambda (_) (dispatch-server self)))))))

(define disp-srv (actor-spawn dispatch-server))
(actor-run #50)

(define c2 (actor-spawn (lambda (self) (actor-call disp-srv (cons #3 #4)))))
(actor-run #100)
(test-case :dispatch-pair #7 (actor-result c2))

(define c3 (actor-spawn (lambda (self) (actor-call disp-srv #5))))
(actor-run #100)
(test-case :dispatch-atom #10 (actor-result c3))

;;; --- Two GenServers communicate via channel pipeline ---

(define ch3 (chan-create))

(define adder-server (lambda (self)
  (bind (actor-receive) (lambda (msg)
    (bind (actor-reply (car (cdr msg)) (+ (car (cdr (cdr msg))) #100))
    (lambda (_) :done))))))

(define pipeline-client (actor-spawn (lambda (self)
  (begin
    (define g1 (actor-spawn adder-server))
    (actor-run #50)
    (define r1 (actor-call g1 #5))
    (chan-send ch3 r1)))))

(actor-run #300)

(test-case :pipeline-channel #105 (chan-recv ch3))

;;; --- ETS table preserves state across supervisor restarts ---

(ets-new :persist)
(ets-insert :persist :counter #0)

(define ets-server (lambda (self)
  (bind (actor-receive) (lambda (msg)
    (if (equal? (car (cdr (cdr msg))) :inc)
       (begin
         (define ets-old (ets-lookup :persist :counter))
         (ets-insert :persist :counter (+ ets-old #1))
         (actor-reply (car (cdr msg)) (+ ets-old #1)))
       (actor-reply (car (cdr msg)) (ets-lookup :persist :counter)))))))

(define sup3 (sup-start :one-for-one (cons ets-server nil)))
(actor-run #100)

(define kids3 (sup-children sup3))
(define es1 (car kids3))

;;; Increment once
(define c4 (actor-spawn (lambda (self) (actor-call es1 :inc))))
(actor-run #100)
(test-case :ets-inc #1 (actor-result c4))

;;; Verify ETS directly
(test-case :ets-direct #1 (ets-lookup :persist :counter))

;;; --- Send to dead actor returns error ---

(define dead-actor (actor-spawn (lambda (self) :done)))
(actor-run #100)
(test-case :dead-actor-done #f (actor-alive? dead-actor))
(test-case :send-to-dead #t (error? (actor-send dead-actor :hello)))
