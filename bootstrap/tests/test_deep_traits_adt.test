;;;
;;; Deep Integration: Traits + Pattern Matching + ADTs + Closures + Recursion
;;;

;;; --- ADT definitions ---

(adt-define :Shape (quote (:Circle :radius)) (quote (:Rect :width :height)))
(adt-define :Maybe (quote (:Just :value)) (quote (:Nothing)))
(adt-define :Tree  (quote (:Leaf :value)) (quote (:Branch :left :right)))

;;; --- Helper: list append ---
(define append (lambda (xs ys)
  (if (null? xs) ys
     (cons (car xs) (append (cdr xs) ys)))))

;;; --- Shape area via pattern match ---

(define area (lambda (s)
  (match s (quote (
    ((adt-create :Shape :Circle r) (* #3 (* r r)))
    ((adt-create :Shape :Rect w h)  (* w h)))))))

(test-case :circle-area #75 (area (adt-create :Shape :Circle #5)))
(test-case :rect-area   #24 (area (adt-create :Shape :Rect #4 #6)))

;;; --- Maybe unwrap-or ---

(define unwrap-or (lambda (m default)
  (match m (quote (
    ((adt-create :Maybe :Just v) v)
    ((adt-create :Maybe :Nothing) default))))))

(test-case :unwrap-just    #42 (unwrap-or (adt-create :Maybe :Just #42) #0))
(test-case :unwrap-nothing #0  (unwrap-or (adt-create :Maybe :Nothing) #0))

;;; --- maybe-map: use conditional to avoid De Bruijn issue with closures in match ---

(define maybe-map (lambda (m f)
  (if (adt? m :Maybe :Just)
     (adt-create :Maybe :Just (f (adt-get m :value)))
     (adt-create :Maybe :Nothing))))

(test-case :maybe-map-just #t
  (adt? (maybe-map (adt-create :Maybe :Just #10) (lambda (x) (* x #2))) :Maybe :Just))
(test-case :maybe-map-just-val #20
  (adt-get (maybe-map (adt-create :Maybe :Just #10) (lambda (x) (* x #2))) :value))
(test-case :maybe-map-nothing #t
  (adt? (maybe-map (adt-create :Maybe :Nothing) (lambda (x) (* x #2))) :Maybe :Nothing))

;;; --- Recursive tree-sum via pattern match (no outer vars needed) ---

(define tree-sum (lambda (t)
  (match t (quote (
    ((adt-create :Tree :Leaf v)       v)
    ((adt-create :Tree :Branch l r)   (+ (tree-sum l) (tree-sum r))))))))

(define t1 (adt-create :Tree :Branch
  (adt-create :Tree :Leaf #10)
  (adt-create :Tree :Branch
    (adt-create :Tree :Leaf #20)
    (adt-create :Tree :Leaf #30))))

(test-case :tree-sum #60 (tree-sum t1))

;;; --- tree-map: use conditional to reference closure param ---

(define tree-map (lambda (t f)
  (if (adt? t :Tree :Leaf)
     (adt-create :Tree :Leaf (f (adt-get t :value)))
     (adt-create :Tree :Branch (tree-map (adt-get t :left) f) (tree-map (adt-get t :right) f)))))

(define t2 (tree-map t1 (lambda (x) (* x #2))))
(test-case :tree-map-doubles #120 (tree-sum t2))

;;; --- tree-to-list (only uses globals, no outer vars) ---

(define tree-to-list (lambda (t)
  (match t (quote (
    ((adt-create :Tree :Leaf v)       (cons v nil))
    ((adt-create :Tree :Branch l r)   (append (tree-to-list l) (tree-to-list r))))))))

(define flat (tree-to-list t1))
(test-case :tree-to-list-head #10 (car flat))

;;; --- Guard on ADT computed field ---

(define big-circle? (lambda (s)
  (match s (quote (
    (((adt-create :Shape :Circle r) | (> (* #3 (* r r)) #50)) #t)
    (_ #f))))))

(test-case :big-circle-yes #t (big-circle? (adt-create :Shape :Circle #5)))
(test-case :big-circle-no  #f (big-circle? (adt-create :Shape :Circle #2)))

;;; --- List of ADTs processed by recursive sum-areas ---

(define sum-areas (lambda (shapes)
  (if (null? shapes) #0
     (+ (area (car shapes)) (sum-areas (cdr shapes))))))

(define shapes (cons (adt-create :Shape :Circle #5)
  (cons (adt-create :Shape :Rect #4 #6)
    (cons (adt-create :Shape :Circle #3) nil))))

(test-case :sum-areas #126 (sum-areas shapes))

;;; --- Trait-based sort (needs stdlib) ---

(load "bootstrap/stdlib/sort.scm")
(load "bootstrap/stdlib/traits.scm")

(test-case :trait-sort #t
  (deep-equal? (‚äßsort (cons #3 (cons #1 (cons #5 (cons #2 (cons #4 nil))))))
     (cons #1 (cons #2 (cons #3 (cons #4 (cons #5 nil)))))))
