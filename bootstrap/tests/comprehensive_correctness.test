; Comprehensive Correctness Test - All 55 Functional Primitives
; Tests that each primitive works as specified

; ========== Arithmetic (9) ==========

; Addition
(âŠ• #5 #3)
; Expected: #8

; Subtraction
(âŠ– #10 #3)
; Expected: #7

; Multiplication
(âŠ— #4 #5)
; Expected: #20

; Division
(âŠ˜ #10 #2)
; Expected: #5.0 (or #5)

; Modulo
(% #10 #3)
; Expected: #1

; Less than
(< #3 #5)
; Expected: #t

(< #5 #3)
; Expected: #f

; Greater than
(> #5 #3)
; Expected: #t

(> #3 #5)
; Expected: #f

; Less or equal
(â‰¤ #3 #3)
; Expected: #t

(â‰¤ #3 #5)
; Expected: #t

(â‰¤ #5 #3)
; Expected: #f

; Greater or equal
(â‰¥ #5 #5)
; Expected: #t

(â‰¥ #5 #3)
; Expected: #t

(â‰¥ #3 #5)
; Expected: #f

; ========== Logic & Comparison (5) ==========

; Equality
(â‰¡ #5 #5)
; Expected: #t

(â‰¡ #5 #3)
; Expected: #f

(â‰¡ :test :test)
; Expected: #t

; Inequality
(â‰¢ #5 #3)
; Expected: #t

(â‰¢ #5 #5)
; Expected: #f

; Logical AND
(âˆ§ #t #t)
; Expected: #t

(âˆ§ #t #f)
; Expected: #f

(âˆ§ #f #f)
; Expected: #f

; Logical OR
(âˆ¨ #t #t)
; Expected: #t

(âˆ¨ #t #f)
; Expected: #t

(âˆ¨ #f #f)
; Expected: #f

; Logical NOT
(Â¬ #t)
; Expected: #f

(Â¬ #f)
; Expected: #t

; ========== Type Predicates (6) ==========

; Is number?
(â„•? #42)
; Expected: #t

(â„•? #t)
; Expected: #f

; Is boolean?
(ğ”¹? #t)
; Expected: #t

(ğ”¹? #f)
; Expected: #t

(ğ”¹? #5)
; Expected: #f

; Is symbol?
(:? :test)
; Expected: #t

(:? #5)
; Expected: #f

; Is nil?
(âˆ…? âˆ…)
; Expected: #t

(âˆ…? #5)
; Expected: #f

; Is pair?
(âŸ¨âŸ©? (âŸ¨âŸ© #1 #2))
; Expected: #t

(âŸ¨âŸ©? #5)
; Expected: #f

; Is atom?
(#? #5)
; Expected: #t

(#? #t)
; Expected: #t

(#? :symbol)
; Expected: #t

(#? (âŸ¨âŸ© #1 #2))
; Expected: #f

; ========== Lists (3) ==========

; Construct pair
(â‰” test-pair (âŸ¨âŸ© #42 #99))
test-pair
; Expected: âŸ¨#42 #99âŸ©

; Head (car)
(â— test-pair)
; Expected: #42

; Tail (cdr)
(â–· test-pair)
; Expected: #99

; Nested lists
(â‰” nested (âŸ¨âŸ© #1 (âŸ¨âŸ© #2 (âŸ¨âŸ© #3 âˆ…))))
(â— nested)
; Expected: #1

(â— (â–· nested))
; Expected: #2

(â— (â–· (â–· nested)))
; Expected: #3

; ========== Metaprogramming (1) ==========

; Quote
(âŒœ (âŠ• #1 #2))
; Expected: Quoted expression (not evaluated)

; ========== Debug/Error (4) ==========

; Create error
(â‰” test-error (âš  :test-error :test-data))
test-error
; Expected: âš (:test-error :test-data)

; Is error?
(âš ? test-error)
; Expected: #t

(âš ? #5)
; Expected: #f

; Assert (passing)
(âŠ¢ #t :ok)
; Expected: #t

; Assert (failing)
(âŠ¢ #f :failed)
; Expected: âš (:assertion-failed :failed)

; Trace
(âŸ² #42)
; Expected: #42 (and prints to stderr)

; ========== Introspection (2) ==========

; Arity
(â‰” test-fn (Î» (x) (âŠ• x #1)))
(â§‰ test-fn)
; Expected: #1

(â‰” test-fn2 (Î» (x y) (âŠ• x y)))
(â§‰ test-fn2)
; Expected: #2

; Source
(âŠ› test-fn)
; Expected: Lambda source code

; ========== Testing (2) ==========

; Deep equality
(â‰Ÿ #5 #5)
; Expected: #t

(â‰Ÿ (âŸ¨âŸ© #1 #2) (âŸ¨âŸ© #1 #2))
; Expected: #t

(â‰Ÿ (âŸ¨âŸ© #1 #2) (âŸ¨âŸ© #1 #3))
; Expected: #f

; Test case (passing)
(âŠ¨ :test-pass #t #t)
; Expected: #t

; Test case (failing) - COMMENTED OUT to avoid confusing test harness
; (âŠ¨ :test-fail #t #f)
; Expected: âš (:test-failed ...)

; ========== Documentation (5) ==========

; Get description
(âŒ‚ (âŒœ âŠ•))
; Expected: Description string

; Get type signature
(âŒ‚âˆˆ (âŒœ âŠ•))
; Expected: Type signature string

; Get dependencies
(âŒ‚â‰” (âŒœ test-fn))
; Expected: List of dependencies

; Get source
(âŒ‚âŠ› (âŒœ test-fn))
; Expected: Source code

; Generate tests
(âŒ‚âŠ¨ (âŒœ âŠ•))
; Expected: List of auto-generated tests

; ========== CFG/DFG (2) ==========

; Control flow graph
(â‰” factorial (Î» (n) (? (â‰¡ n #0) #1 (âŠ— n (factorial (âŠ– n #1))))))
(âŒ‚âŸ¿ (âŒœ factorial))
; Expected: CFG structure

; Data flow graph
(âŒ‚â‡ (âŒœ factorial))
; Expected: DFG structure

; ========== Structures - Leaf (5) ==========

; Define leaf structure
(âŠ™â‰” :Point :x :y)
; Expected: :Point type defined

; Create instance
(â‰” point (âŠ™ :Point #3 #4))
point
; Expected: Point instance

; Get field
(âŠ™â†’ point :x)
; Expected: #3

(âŠ™â†’ point :y)
; Expected: #4

; Update field (immutable)
(â‰” point2 (âŠ™â† point :x #10))
(âŠ™â†’ point2 :x)
; Expected: #10

(âŠ™â†’ point :x)
; Expected: #3 (original unchanged)

; Check type
(âŠ™? point :Point)
; Expected: #t

(âŠ™? #5 :Point)
; Expected: #f

; ========== Structures - Node (4) ==========

; Define ADT
(âŠšâ‰” :List [:Nil] [:Cons :head :tail])
; Expected: :List type defined

; Create nil variant
(â‰” empty (âŠš :List :Nil))
empty
; Expected: List Nil

; Create cons variant
(â‰” lst (âŠš :List :Cons #42 empty))
lst
; Expected: List Cons with head=#42

; Get field
(âŠšâ†’ lst :head)
; Expected: #42

; Check type and variant
(âŠš? lst :List :Cons)
; Expected: #t

(âŠš? empty :List :Nil)
; Expected: #t

(âŠš? lst :List :Nil)
; Expected: #f

; ========== Graphs (6) ==========

; Define graph type
(âŠâ‰” :SocialGraph :MyGraph :nodes :edges)
; Expected: :SocialGraph type defined

; Create empty graph
(â‰” graph (âŠ :SocialGraph :MyGraph))
graph
; Expected: Empty graph

; Add node
(â‰” graph1 (âŠâŠ• graph #node1))
; Expected: Graph with one node

; Add edge
(â‰” graph2 (âŠâŠ— graph1 #1 #2 :follows))
; Expected: Graph with edge

; Query property
(âŠâ†’ graph2 :nodes)
; Expected: List of nodes

; Check type
(âŠ? graph2 :SocialGraph)
; Expected: #t

(âŠ? #5 :SocialGraph)
; Expected: #f

; ========== Summary ==========
:comprehensive-correctness-test-complete
