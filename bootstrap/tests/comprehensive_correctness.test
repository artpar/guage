; Comprehensive Correctness Test - All 55 Functional Primitives
; Tests that each primitive works as specified

; ========== Arithmetic (9) ==========

; Addition
(+ #5 #3)
; Expected: #8

; Subtraction
(- #10 #3)
; Expected: #7

; Multiplication
(* #4 #5)
; Expected: #20

; Division
(/ #10 #2)
; Expected: #5.0 (or #5)

; Modulo
(% #10 #3)
; Expected: #1

; Less than
(< #3 #5)
; Expected: #t

(< #5 #3)
; Expected: #f

; Greater than
(> #5 #3)
; Expected: #t

(> #3 #5)
; Expected: #f

; Less or equal
(<= #3 #3)
; Expected: #t

(<= #3 #5)
; Expected: #t

(<= #5 #3)
; Expected: #f

; Greater or equal
(>= #5 #5)
; Expected: #t

(>= #5 #3)
; Expected: #t

(>= #3 #5)
; Expected: #f

; ========== Logic & Comparison (5) ==========

; Equality
(equal? #5 #5)
; Expected: #t

(equal? #5 #3)
; Expected: #f

(equal? :test :test)
; Expected: #t

; Inequality
(not-equal? #5 #3)
; Expected: #t

(not-equal? #5 #5)
; Expected: #f

; Logical AND
(and #t #t)
; Expected: #t

(and #t #f)
; Expected: #f

(and #f #f)
; Expected: #f

; Logical OR
(or #t #t)
; Expected: #t

(or #t #f)
; Expected: #t

(or #f #f)
; Expected: #f

; Logical NOT
(not #t)
; Expected: #f

(not #f)
; Expected: #t

; ========== Type Predicates (6) ==========

; Is number?
(number? #42)
; Expected: #t

(number? #t)
; Expected: #f

; Is boolean?
(boolean? #t)
; Expected: #t

(boolean? #f)
; Expected: #t

(boolean? #5)
; Expected: #f

; Is symbol?
(symbol? :test)
; Expected: #t

(symbol? #5)
; Expected: #f

; Is nil?
(null? nil)
; Expected: #t

(null? #5)
; Expected: #f

; Is pair?
(pair? (cons #1 #2))
; Expected: #t

(pair? #5)
; Expected: #f

; Is atom?
(atom? #5)
; Expected: #t

(atom? #t)
; Expected: #t

(atom? :symbol)
; Expected: #t

(atom? (cons #1 #2))
; Expected: #f

; ========== Lists (3) ==========

; Construct pair
(define test-pair (cons #42 #99))
test-pair
; Expected: ⟨#42 #99⟩

; Head (car)
(car test-pair)
; Expected: #42

; Tail (cdr)
(cdr test-pair)
; Expected: #99

; Nested lists
(define nested (cons #1 (cons #2 (cons #3 nil))))
(car nested)
; Expected: #1

(car (cdr nested))
; Expected: #2

(car (cdr (cdr nested)))
; Expected: #3

; ========== Metaprogramming (1) ==========

; Quote
(quote (+ #1 #2))
; Expected: Quoted expression (not evaluated)

; ========== Debug/Error (4) ==========

; Create error
(define test-error (error :test-error :test-data))
test-error
; Expected: ⚠(:test-error :test-data)

; Is error?
(error? test-error)
; Expected: #t

(error? #5)
; Expected: #f

; Assert (passing)
(assert #t :ok)
; Expected: #t

; Assert (failing)
(assert #f :failed)
; Expected: ⚠(:assertion-failed :failed)

; Trace
(trace #42)
; Expected: #42 (and prints to stderr)

; ========== Introspection (2) ==========

; Arity
(define test-fn (lambda (x) (+ x #1)))
(arity test-fn)
; Expected: #1

(define test-fn2 (lambda (x y) (+ x y)))
(arity test-fn2)
; Expected: #2

; Source
(source test-fn)
; Expected: Lambda source code

; ========== Testing (2) ==========

; Deep equality
(deep-equal? #5 #5)
; Expected: #t

(deep-equal? (cons #1 #2) (cons #1 #2))
; Expected: #t

(deep-equal? (cons #1 #2) (cons #1 #3))
; Expected: #f

; Test case (passing)
(test-case :test-pass #t #t)
; Expected: #t

; Test case (failing) - COMMENTED OUT to avoid confusing test harness
; (test-case :test-fail #t #f)
; Expected: ⚠(:test-failed ...)

; ========== Documentation (5) ==========

; Get description
(doc (quote +))
; Expected: Description string

; Get type signature
(doc-type (quote +))
; Expected: Type signature string

; Get dependencies
(doc-deps (quote test-fn))
; Expected: List of dependencies

; Get source
(doc-source (quote test-fn))
; Expected: Source code

; Generate tests
(doc-tests (quote +))
; Expected: List of auto-generated tests

; ========== CFG/DFG (2) ==========

; Control flow graph
(define factorial (lambda (n) (if (equal? n #0) #1 (* n (factorial (- n #1))))))
(query-cfg (quote factorial))
; Expected: CFG structure

; Data flow graph
(query-dfg (quote factorial))
; Expected: DFG structure

; ========== Structures - Leaf (5) ==========

; Define leaf structure
(struct-define :Point :x :y)
; Expected: :Point type defined

; Create instance
(define point (struct-create :Point #3 #4))
point
; Expected: Point instance

; Get field
(struct-get point :x)
; Expected: #3

(struct-get point :y)
; Expected: #4

; Update field (immutable)
(define point2 (struct-set point :x #10))
(struct-get point2 :x)
; Expected: #10

(struct-get point :x)
; Expected: #3 (original unchanged)

; Check type
(struct? point :Point)
; Expected: #t

(struct? #5 :Point)
; Expected: #f

; ========== Structures - Node (4) ==========

; Define ADT
(adt-define :List [:Nil] [:Cons :head :tail])
; Expected: :List type defined

; Create nil variant
(define empty (adt-create :List :Nil))
empty
; Expected: List Nil

; Create cons variant
(define lst (adt-create :List :Cons #42 empty))
lst
; Expected: List Cons with head=#42

; Get field
(adt-get lst :head)
; Expected: #42

; Check type and variant
(adt? lst :List :Cons)
; Expected: #t

(adt? empty :List :Nil)
; Expected: #t

(adt? lst :List :Nil)
; Expected: #f

; ========== Graphs (6) ==========

; Define graph type
(graph-define :SocialGraph :MyGraph :nodes :edges)
; Expected: :SocialGraph type defined

; Create empty graph
(define graph (graph-create :SocialGraph :MyGraph))
graph
; Expected: Empty graph

; Add node
(define graph1 (graph-add-node graph #node1))
; Expected: Graph with one node

; Add edge
(define graph2 (graph-add-edge graph1 #1 #2 :follows))
; Expected: Graph with edge

; Query property
(graph-query graph2 :nodes)
; Expected: List of nodes

; Check type
(graph? graph2 :SocialGraph)
; Expected: #t

(graph? #5 :SocialGraph)
; Expected: #f

; ========== Summary ==========
:comprehensive-correctness-test-complete
