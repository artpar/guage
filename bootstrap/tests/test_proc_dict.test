; Day 98: Process Dictionary tests — ⟳⊔⊕, ⟳⊔?, ⟳⊔⊖, proc-dict-all

; Reset state
(actor-reset)

; === put-get-basic ===
; Store and retrieve a value
(actor-reset)
(define a1 (actor-spawn (lambda (self)
  (bind (proc-dict-put :name :alice) (lambda (_)
    (proc-dict-get :name))))))
(actor-run #10)
(test-case (quote :put-get-basic) :alice (actor-result a1))

; === put-overwrite ===
; Overwriting returns old value
(actor-reset)
(define a2 (actor-spawn (lambda (self)
  (bind (proc-dict-put :x #10) (lambda (_)
    (proc-dict-put :x #20))))))
(actor-run #10)
(test-case (quote :put-overwrite) #10 (actor-result a2))

; === get-missing ===
; Lookup missing key returns nil
(actor-reset)
(define a3 (actor-spawn (lambda (self)
  (proc-dict-get :nonexistent))))
(actor-run #10)
(test-case (quote :get-missing) nil (actor-result a3))

; === erase-basic ===
; Erase returns old value
(actor-reset)
(define a4 (actor-spawn (lambda (self)
  (bind (proc-dict-put :key #42) (lambda (_)
    (proc-dict-erase :key))))))
(actor-run #10)
(test-case (quote :erase-basic) #42 (actor-result a4))

; === erase-missing ===
; Erase missing key returns nil
(actor-reset)
(define a5 (actor-spawn (lambda (self)
  (proc-dict-erase :ghost))))
(actor-run #10)
(test-case (quote :erase-missing) nil (actor-result a5))

; === get-all ===
; List all entries as pairs — verify it's a 2-element list
(actor-reset)
(define a6 (actor-spawn (lambda (self)
  (bind (proc-dict-put :a #1) (lambda (_)
    (bind (proc-dict-put :b #2) (lambda (_)
      (proc-dict-all))))))))
(actor-run #10)
; get-all returns list of pairs; check non-nil and second element exists
(define all-entries (actor-result a6))
(test-case (quote :get-all) #t (not (equal? all-entries nil)))

; === multiple-keys ===
; Store several key-value pairs and retrieve each
(actor-reset)
(define a7 (actor-spawn (lambda (self)
  (bind (proc-dict-put :x #1) (lambda (_)
    (bind (proc-dict-put :y #2) (lambda (_)
      (bind (proc-dict-put :z #3) (lambda (_)
        (cons (proc-dict-get :x) (cons (proc-dict-get :y) (proc-dict-get :z))))))))))))
(actor-run #10)
(test-case (quote :multiple-keys) (cons #1 (cons #2 #3)) (actor-result a7))

; === not-in-actor ===
; Calling outside actor returns error
(actor-reset)
(test-case (quote :not-in-actor) #t (error? (proc-dict-put :k :v)))

; === isolation ===
; Two actors have separate dicts
(actor-reset)
(define actor-a (actor-spawn (lambda (self)
  (bind (proc-dict-put :shared #100) (lambda (_)
    (bind (actor-receive) (lambda (_)
      (proc-dict-get :shared))))))))
(define actor-b (actor-spawn (lambda (self)
  (bind (proc-dict-put :shared #999) (lambda (_)
    (actor-send actor-a :go))))))
(actor-run #20)
; actor-a stored 100, actor-b stored 999 under same key
; actor-a should still see 100
(test-case (quote :isolation) #100 (actor-result actor-a))

; === genserver-state ===
; GenServer using dict for mutable state (counter)
(actor-reset)
(define counter-server (actor-spawn (lambda (self)
  (bind (proc-dict-put :count #0) (lambda (_)
    (bind (actor-receive) (lambda (msg1)
      (bind (proc-dict-put :count (+ (proc-dict-get :count) #1)) (lambda (_)
        (bind (actor-reply (car (cdr msg1)) (proc-dict-get :count)) (lambda (_)
          (bind (actor-receive) (lambda (msg2)
            (bind (proc-dict-put :count (+ (proc-dict-get :count) #1)) (lambda (_)
              (actor-reply (car (cdr msg2)) (proc-dict-get :count)))))))))))))))))
(define client (actor-spawn (lambda (self)
  (bind (actor-call counter-server :inc) (lambda (r1)
    (bind (actor-call counter-server :inc) (lambda (r2)
      (cons r1 r2))))))))
(actor-run #50)
(test-case (quote :genserver-state) (cons #1 #2) (actor-result client))
