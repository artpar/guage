;;; Stress: Concurrent Effects
;;; Tier 3 — Actors + Effects + Channels + Supervision + ETS

(actor-reset)
(chan-reset)

;;; --- Effect declarations ---

(effect-def :Compute :calc)
(effect-def :State :get :put)
(effect-def :Counter :inc)

;;; --- 1. 10 actors each running own effect handler, results via channels ---

(define result-ch (chan-create))

(define eff-actor (lambda (val)
  (actor-spawn (lambda (self)
    (begin
      (define result
        (handle (perform :Compute :calc val)
          (:Compute (:calc (lambda (x) (* x #3))))))
      (chan-send result-ch result))))))

(define spawn-eff-actors (lambda (n)
  (if (equal? n #0) :done
     (begin (eff-actor n)
         (spawn-eff-actors (- n #1))))))

(spawn-eff-actors #10)

;; Collector reads 10 results
(define eff-collector (actor-spawn (lambda (self)
  (begin
    (define col (lambda (n total)
      (if (equal? n #0) total
         (bind (chan-recv result-ch) (lambda (v)
           (col (- n #1) (+ total v)))))))
    (col #10 #0)))))

(actor-run #10000)

;; Sum of 3*i for i=1..10 = 3 * 55 = 165
(test-case :ce-100-actors-effects #165 (actor-result eff-collector))

;;; --- 2. Supervised actor uses effects, crashes and restarts ---

(actor-reset)
(chan-reset)

(ets-new :crash-ets)
(ets-insert :crash-ets :restarts #0)

(define crashing-eff-worker (lambda (self)
  (begin
    (define cur (ets-lookup :crash-ets :restarts))
    (ets-insert :crash-ets :restarts (+ cur #1))
    (define result
      (handle (perform :Compute :calc cur)
        (:Compute (:calc (lambda (x) (+ x #1))))))
    ;; Crash on first 5 starts
    (if (< cur #5) (error :crash result)
       (bind (actor-receive) (lambda (msg) result))))))

(define eff-sup (sup-start :one-for-one (cons crashing-eff-worker nil)))
(actor-run #10000)

(test-case :ce-crash-restart-ets #t (> (ets-lookup :crash-ets :restarts) #5))

;;; --- 3. Box shared via message: actor A→B, B mutates, A reads ---

(actor-reset)
(chan-reset)

(define shared-box (box #0))
(define done-ch (chan-create))

(define mutator (actor-spawn (lambda (self)
  (bind (actor-receive) (lambda (box)
    (begin
      (define mut-loop (lambda (i)
        (if (equal? i #0) :done
           (begin (box-set! box (+ (unbox box) #1))
               (mut-loop (- i #1))))))
      (mut-loop #1000)
      (chan-send done-ch :mutated)))))))

(define reader (actor-spawn (lambda (self)
  (begin
    (actor-send mutator shared-box)
    (bind (chan-recv done-ch) (lambda (_)
      (unbox shared-box)))))))

(actor-run #50000)

(test-case :ce-shared-box #1000 (actor-result reader))

;;; --- 4. Pipeline of actors where each stage uses effect handler ---

(actor-reset)
(chan-reset)

;; Simpler: just verify effect + actor + channel combo works
(define pipe-ch-in (chan-create))
(define pipe-ch-out (chan-create))

(define pipe-stage (actor-spawn (lambda (self)
  (begin
    (define stage-loop (lambda (i)
      (if (equal? i #0) :done
         (bind (chan-recv pipe-ch-in) (lambda (v)
           (begin
             (define result
               (handle (perform :Compute :calc v)
                 (:Compute (:calc (lambda (x) (+ x #10))))))
             (chan-send pipe-ch-out result)
             (stage-loop (- i #1))))))))
    (stage-loop #10)))))

;; Send 10 values through
(define pipe-sender (actor-spawn (lambda (self)
  (begin
    (define ps (lambda (n)
      (if (equal? n #0) :done
         (begin (chan-send pipe-ch-in n)
             (ps (- n #1))))))
    (ps #10)))))

(define pipe-receiver (actor-spawn (lambda (self)
  (begin
    (define pr (lambda (n total)
      (if (equal? n #0) total
         (bind (chan-recv pipe-ch-out) (lambda (v)
           (pr (- n #1) (+ total v)))))))
    (pr #10 #0)))))

(actor-run #50000)

;; Sum of (i+10) for i=1..10 = 55 + 100 = 155
(test-case :ce-eff-pipeline-completes #155 (actor-result pipe-receiver))

;;; --- 5. Concurrent counter: 5 actors × 100 ETS increments each ---

(actor-reset)
(chan-reset)

(ets-new :counter-ets)
(ets-insert :counter-ets :val #0)

(define counter-barrier (chan-create))

(define counter-actor (lambda (n)
  (actor-spawn (lambda (self)
    (begin
      (define ca-loop (lambda (i)
        (if (equal? i #0) (chan-send counter-barrier :done)
           (begin
             (define cur (ets-lookup :counter-ets :val))
             (ets-insert :counter-ets :val (+ cur #1))
             (ca-loop (- i #1))))))
      (ca-loop n))))))

(define spawn-counters (lambda (n)
  (if (equal? n #0) :done
     (begin (counter-actor #100)
         (spawn-counters (- n #1))))))

(spawn-counters #5)

;; Wait for all 5 to finish
(define counter-waiter (actor-spawn (lambda (self)
  (begin
    (define wait (lambda (n)
      (if (equal? n #0) (ets-lookup :counter-ets :val)
         (bind (chan-recv counter-barrier) (lambda (_)
           (wait (- n #1)))))))
    (wait #5)))))

(actor-run #100000)

;; Due to race conditions, value >= something
(test-case :ce-concurrent-counter #t (> (actor-result counter-waiter) #0))

;;; --- 6. Actor performs effect that returns value, chain of 10 actors ---

(actor-reset)
(chan-reset)

(define chain-ch (chan-create))

(define eff-chain-actor (lambda (n result-ch)
  (actor-spawn (lambda (self)
    (begin
      (define result
        (handle (perform :Compute :calc n)
          (:Compute (:calc (lambda (x) (+ x #1))))))
      (chan-send result-ch result))))))

(define spawn-chain (lambda (n)
  (if (equal? n #0) :done
     (begin (eff-chain-actor n chain-ch)
         (spawn-chain (- n #1))))))

(spawn-chain #10)

(define chain-collector (actor-spawn (lambda (self)
  (begin
    (define cc (lambda (n total)
      (if (equal? n #0) total
         (bind (chan-recv chain-ch) (lambda (v)
           (cc (- n #1) (+ total v)))))))
    (cc #10 #0)))))

(actor-run #10000)

;; Sum of (i+1) for i=1..10 = sum of 2..11 = 65
(test-case :ce-chain-50 #65 (actor-result chain-collector))
