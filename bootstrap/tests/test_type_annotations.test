#!/usr/bin/env guage
; Test suite for type annotations
; Tests optional type hints for functions and values

(â‰‹ "Testing Type Annotations...")

; ============================================================================
; Test: Basic Type Constants
; ============================================================================

(â‰‹ "\nTesting basic type constants...")

; Type constants are primitives that return type structures
(âŠ¨ :int-type-exists
   #t
   (âŠ™? (â„¤) :type))

(âŠ¨ :bool-type-exists
   #t
   (âŠ™? (ğ”¹) :type))

(âŠ¨ :string-type-exists
   #t
   (âŠ™? (ğ•Š) :type))

(âŠ¨ :any-type-exists
   #t
   (âŠ™? (âŠ¤) :type))

(âŠ¨ :nil-type-exists
   #t
   (âŠ™? (âˆ…â‚œ) :type))

; ============================================================================
; Test: â†’ (Function Type Constructor)
; ============================================================================

(â‰‹ "Testing â†’ (function type)...")

; Create function types
(âŠ¨ :arrow-creates-type
   #t
   (âŠ™? (â†’ (â„¤) (â„¤)) :type))

; Multi-arg function type
(âŠ¨ :arrow-multi-arg
   #t
   (âŠ™? (â†’ (â„¤) (â„¤) (â„¤)) :type))

; Nested function type (curried)
(âŠ¨ :arrow-curried
   #t
   (âŠ™? (â†’ (â„¤) (â†’ (â„¤) (â„¤))) :type))

; ============================================================================
; Test: []â‚œ (List Type Constructor)
; ============================================================================

(â‰‹ "Testing []â‚œ (list type)...")

; Create list types
(âŠ¨ :list-type-creates
   #t
   (âŠ™? ([]â‚œ (â„¤)) :type))

(âŠ¨ :list-bool-type
   #t
   (âŠ™? ([]â‚œ (ğ”¹)) :type))

; Nested list
(âŠ¨ :list-nested-type
   #t
   (âŠ™? ([]â‚œ ([]â‚œ (â„¤))) :type))

; ============================================================================
; Test: âŸ¨âŸ©â‚œ (Pair Type Constructor)
; ============================================================================

(â‰‹ "Testing âŸ¨âŸ©â‚œ (pair type)...")

; Create pair types
(âŠ¨ :pair-type-creates
   #t
   (âŠ™? (âŸ¨âŸ©â‚œ (â„¤) (â„¤)) :type))

(âŠ¨ :pair-mixed-type
   #t
   (âŠ™? (âŸ¨âŸ©â‚œ (â„¤) (ğ•Š)) :type))

; ============================================================================
; Test: âˆªâ‚œ (Union Type Constructor)
; ============================================================================

(â‰‹ "Testing âˆªâ‚œ (union type)...")

; Create union types
(âŠ¨ :union-type-creates
   #t
   (âŠ™? (âˆªâ‚œ (â„¤) (âˆ…â‚œ)) :type))

(âŠ¨ :union-int-string
   #t
   (âŠ™? (âˆªâ‚œ (â„¤) (ğ•Š)) :type))

; ============================================================================
; Test: âˆˆâŠ™ (typeof - runtime type detection)
; ============================================================================

(â‰‹ "Testing âˆˆâŠ™ (typeof)...")

; Type of integer
(âŠ¨ :typeof-int
   #t
   (âŠ™? (âˆˆâŠ™ #42) :type))

; Type of boolean
(âŠ¨ :typeof-bool-t
   #t
   (âŠ™? (âˆˆâŠ™ #t) :type))

(âŠ¨ :typeof-bool-f
   #t
   (âŠ™? (âˆˆâŠ™ #f) :type))

; Type of string
(âŠ¨ :typeof-string
   #t
   (âŠ™? (âˆˆâŠ™ "hello") :type))

; Type of nil
(âŠ¨ :typeof-nil
   #t
   (âŠ™? (âˆˆâŠ™ âˆ…) :type))

; Type of symbol
(âŠ¨ :typeof-symbol
   :symbol
   (âˆˆâŠ™ :foo))

; Type of pair
(âŠ¨ :typeof-pair
   :pair
   (âˆˆâŠ™ (âŸ¨âŸ© #1 #2)))

; Type of lambda
(âŠ¨ :typeof-lambda
   :function
   (âˆˆâŠ™ (Î» (x) x)))

; Type of error
(âŠ¨ :typeof-error
   :error
   (âˆˆâŠ™ (âš  :test-error #0)))

; ============================================================================
; Test: âˆˆâ‰¡ (Type equality)
; ============================================================================

(â‰‹ "Testing âˆˆâ‰¡ (type equality)...")

; Same basic types
(âŠ¨ :type-eq-int
   #t
   (âˆˆâ‰¡ (â„¤) (â„¤)))

(âŠ¨ :type-eq-bool
   #t
   (âˆˆâ‰¡ (ğ”¹) (ğ”¹)))

; Different basic types
(âŠ¨ :type-neq-int-bool
   #f
   (âˆˆâ‰¡ (â„¤) (ğ”¹)))

; Function types equal
(âŠ¨ :type-eq-func
   #t
   (âˆˆâ‰¡ (â†’ (â„¤) (â„¤)) (â†’ (â„¤) (â„¤))))

; Function types not equal
(âŠ¨ :type-neq-func
   #f
   (âˆˆâ‰¡ (â†’ (â„¤) (â„¤)) (â†’ (â„¤) (ğ”¹))))

; List types equal
(âŠ¨ :type-eq-list
   #t
   (âˆˆâ‰¡ ([]â‚œ (â„¤)) ([]â‚œ (â„¤))))

; List types not equal
(âŠ¨ :type-neq-list
   #f
   (âˆˆâ‰¡ ([]â‚œ (â„¤)) ([]â‚œ (ğ”¹))))

; ============================================================================
; Test: âˆˆâŠ† (Subtype checking)
; ============================================================================

(â‰‹ "Testing âˆˆâŠ† (subtype)...")

; Same type is subtype of itself
(âŠ¨ :subtype-same
   #t
   (âˆˆâŠ† (â„¤) (â„¤)))

; Everything is subtype of âŠ¤ (any)
(âŠ¨ :subtype-any-int
   #t
   (âˆˆâŠ† (â„¤) (âŠ¤)))

(âŠ¨ :subtype-any-bool
   #t
   (âˆˆâŠ† (ğ”¹) (âŠ¤)))

(âŠ¨ :subtype-any-string
   #t
   (âˆˆâŠ† (ğ•Š) (âŠ¤)))

; Different types are not subtypes of each other
(âŠ¨ :not-subtype-int-bool
   #f
   (âˆˆâŠ† (â„¤) (ğ”¹)))

; Union subtype checking
(âŠ¨ :subtype-union-left
   #t
   (âˆˆâŠ† (â„¤) (âˆªâ‚œ (â„¤) (ğ•Š))))

(âŠ¨ :subtype-union-right
   #t
   (âˆˆâŠ† (ğ•Š) (âˆªâ‚œ (â„¤) (ğ•Š))))

; ============================================================================
; Test: âˆˆ! (Type assertion)
; ============================================================================

(â‰‹ "Testing âˆˆ! (type assertion)...")

; Assert value has correct type - returns value
(âŠ¨ :assert-int-ok
   #42
   (âˆˆ! #42 (â„¤)))

(âŠ¨ :assert-string-ok
   "hello"
   (âˆˆ! "hello" (ğ•Š)))

(âŠ¨ :assert-bool-ok
   #t
   (âˆˆ! #t (ğ”¹)))

(âŠ¨ :assert-nil-ok
   âˆ…
   (âˆˆ! âˆ… (âˆ…â‚œ)))

; Assert any type (always succeeds)
(âŠ¨ :assert-any-ok
   :anything
   (âˆˆ! :anything (âŠ¤)))

; Assert with wrong type returns error
(âŠ¨ :assert-type-error
   #t
   (âš ? (âˆˆ! "not-an-int" (â„¤))))

(âŠ¨ :assert-type-error2
   #t
   (âš ? (âˆˆ! #42 (ğ•Š))))

; ============================================================================
; Test: âˆˆ and âˆˆ? (Type declaration and query)
; ============================================================================

(â‰‹ "Testing âˆˆ and âˆˆ? (declaration and query)...")

; Declare type for a value
(â‰” my-x #42)
(âˆˆ my-x (â„¤))

; Query declared type
(âŠ¨ :query-declared
   #t
   (âˆˆâ‰¡ (âˆˆ? my-x) (â„¤)))

; Declare type for a function
(â‰” my-inc (Î» (n) (âŠ• n #1)))
(âˆˆ my-inc (â†’ (â„¤) (â„¤)))

(âŠ¨ :query-func-type
   #t
   (âˆˆâ‰¡ (âˆˆ? my-inc) (â†’ (â„¤) (â„¤))))

; Query undeclared - returns nil
(â‰” my-y #99)
(âŠ¨ :query-undeclared
   âˆ…
   (âˆˆ? my-y))

; ============================================================================
; Test: Type introspection for function types
; ============================================================================

(â‰‹ "Testing type introspection...")

; Get domain (input type) of function type
(âŠ¨ :type-domain
   #t
   (âˆˆâ‰¡ (âˆˆâ— (â†’ (â„¤) (ğ”¹))) (â„¤)))

; Get codomain (output type) of function type
(âŠ¨ :type-codomain
   #t
   (âˆˆâ‰¡ (âˆˆâ–· (â†’ (â„¤) (ğ”¹))) (ğ”¹)))

; Get element type of list type
(âŠ¨ :type-element
   #t
   (âˆˆâ‰¡ (âˆˆâŠ™â‚œ ([]â‚œ (â„¤))) (â„¤)))

; Multi-arg function domain
(âŠ¨ :type-domain-multi
   #t
   (âˆˆâ‰¡ (âˆˆâ— (â†’ (â„¤) (ğ”¹) (ğ•Š))) (â„¤)))

; ============================================================================
; Integration Tests
; ============================================================================

(â‰‹ "Testing integration scenarios...")

; Declare and use typed values
(â‰” typed-add (Î» (x y) (âŠ• x y)))
(âˆˆ typed-add (â†’ (â„¤) (â„¤) (â„¤)))

(âŠ¨ :typed-func-use
   #5
   (typed-add #2 #3))

(âŠ¨ :typed-func-query
   #t
   (âˆˆâ‰¡ (âˆˆ? typed-add) (â†’ (â„¤) (â„¤) (â„¤))))

; Multiple declarations
(â‰” a #1)
(â‰” b #2)
(â‰” c "three")
(âˆˆ a (â„¤))
(âˆˆ b (â„¤))
(âˆˆ c (ğ•Š))

(âŠ¨ :multi-decl-a
   #t
   (âˆˆâ‰¡ (âˆˆ? a) (â„¤)))

(âŠ¨ :multi-decl-b
   #t
   (âˆˆâ‰¡ (âˆˆ? b) (â„¤)))

(âŠ¨ :multi-decl-c
   #t
   (âˆˆâ‰¡ (âˆˆ? c) (ğ•Š)))

; Type checks with computed values
(âŠ¨ :typeof-computed
   #t
   (âŠ™? (âˆˆâŠ™ (âŠ• #1 #2)) :type))

(â‰‹ "\nâœ… All type annotation tests passed!")
