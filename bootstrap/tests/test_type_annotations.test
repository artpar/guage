#!/usr/bin/env guage
; Test suite for type annotations
; Tests optional type hints for functions and values

(print "Testing Type Annotations...")

; ============================================================================
; Test: Basic Type Constants
; ============================================================================

(print "\nTesting basic type constants...")

; Type constants are primitives that return type structures
(test-case :int-type-exists
   #t
   (struct? (Int) :type))

(test-case :bool-type-exists
   #t
   (struct? (Bool) :type))

(test-case :string-type-exists
   #t
   (struct? (String) :type))

(test-case :any-type-exists
   #t
   (struct? (Any) :type))

(test-case :nil-type-exists
   #t
   (struct? (Nil-type) :type))

; ============================================================================
; Test: -> (Function Type Constructor)
; ============================================================================

(print "Testing -> (function type)...")

; Create function types
(test-case :arrow-creates-type
   #t
   (struct? (-> (Int) (Int)) :type))

; Multi-arg function type
(test-case :arrow-multi-arg
   #t
   (struct? (-> (Int) (Int) (Int)) :type))

; Nested function type (curried)
(test-case :arrow-curried
   #t
   (struct? (-> (Int) (-> (Int) (Int))) :type))

; ============================================================================
; Test: List-type (List Type Constructor)
; ============================================================================

(print "Testing List-type (list type)...")

; Create list types
(test-case :list-type-creates
   #t
   (struct? (List-type (Int)) :type))

(test-case :list-bool-type
   #t
   (struct? (List-type (Bool)) :type))

; Nested list
(test-case :list-nested-type
   #t
   (struct? (List-type (List-type (Int))) :type))

; ============================================================================
; Test: Pair-type (Pair Type Constructor)
; ============================================================================

(print "Testing Pair-type (pair type)...")

; Create pair types
(test-case :pair-type-creates
   #t
   (struct? (Pair-type (Int) (Int)) :type))

(test-case :pair-mixed-type
   #t
   (struct? (Pair-type (Int) (String)) :type))

; ============================================================================
; Test: Union-type (Union Type Constructor)
; ============================================================================

(print "Testing Union-type (union type)...")

; Create union types
(test-case :union-type-creates
   #t
   (struct? (Union-type (Int) (Nil-type)) :type))

(test-case :union-int-string
   #t
   (struct? (Union-type (Int) (String)) :type))

; ============================================================================
; Test: type-of (typeof - runtime type detection)
; ============================================================================

(print "Testing type-of (typeof)...")

; Type of integer
(test-case :typeof-int
   #t
   (struct? (type-of #42) :type))

; Type of boolean
(test-case :typeof-bool-t
   #t
   (struct? (type-of #t) :type))

(test-case :typeof-bool-f
   #t
   (struct? (type-of #f) :type))

; Type of string
(test-case :typeof-string
   #t
   (struct? (type-of "hello") :type))

; Type of nil
(test-case :typeof-nil
   #t
   (struct? (type-of nil) :type))

; Type of symbol
(test-case :typeof-symbol
   :symbol
   (type-of :foo))

; Type of pair
(test-case :typeof-pair
   :pair
   (type-of (cons #1 #2)))

; Type of lambda
(test-case :typeof-lambda
   :function
   (type-of (lambda (x) x)))

; Type of error
(test-case :typeof-error
   :error
   (type-of (error :test-error #0)))

; ============================================================================
; Test: type-equal? (Type equality)
; ============================================================================

(print "Testing type-equal? (type equality)...")

; Same basic types
(test-case :type-eq-int
   #t
   (type-equal? (Int) (Int)))

(test-case :type-eq-bool
   #t
   (type-equal? (Bool) (Bool)))

; Different basic types
(test-case :type-neq-int-bool
   #f
   (type-equal? (Int) (Bool)))

; Function types equal
(test-case :type-eq-func
   #t
   (type-equal? (-> (Int) (Int)) (-> (Int) (Int))))

; Function types not equal
(test-case :type-neq-func
   #f
   (type-equal? (-> (Int) (Int)) (-> (Int) (Bool))))

; List types equal
(test-case :type-eq-list
   #t
   (type-equal? (List-type (Int)) (List-type (Int))))

; List types not equal
(test-case :type-neq-list
   #f
   (type-equal? (List-type (Int)) (List-type (Bool))))

; ============================================================================
; Test: type-subtype? (Subtype checking)
; ============================================================================

(print "Testing type-subtype? (subtype)...")

; Same type is subtype of itself
(test-case :subtype-same
   #t
   (type-subtype? (Int) (Int)))

; Everything is subtype of Any (any)
(test-case :subtype-any-int
   #t
   (type-subtype? (Int) (Any)))

(test-case :subtype-any-bool
   #t
   (type-subtype? (Bool) (Any)))

(test-case :subtype-any-string
   #t
   (type-subtype? (String) (Any)))

; Different types are not subtypes of each other
(test-case :not-subtype-int-bool
   #f
   (type-subtype? (Int) (Bool)))

; Union subtype checking
(test-case :subtype-union-left
   #t
   (type-subtype? (Int) (Union-type (Int) (String))))

(test-case :subtype-union-right
   #t
   (type-subtype? (String) (Union-type (Int) (String))))

; ============================================================================
; Test: type-assert! (Type assertion)
; ============================================================================

(print "Testing type-assert! (type assertion)...")

; Assert value has correct type - returns value
(test-case :assert-int-ok
   #42
   (type-assert! #42 (Int)))

(test-case :assert-string-ok
   "hello"
   (type-assert! "hello" (String)))

(test-case :assert-bool-ok
   #t
   (type-assert! #t (Bool)))

(test-case :assert-nil-ok
   nil
   (type-assert! nil (Nil-type)))

; Assert any type (always succeeds)
(test-case :assert-any-ok
   :anything
   (type-assert! :anything (Any)))

; Assert with wrong type returns error
(test-case :assert-type-error
   #t
   (error? (type-assert! "not-an-int" (Int))))

(test-case :assert-type-error2
   #t
   (error? (type-assert! #42 (String))))

; ============================================================================
; Test: type-decl and type-check (Type declaration and query)
; ============================================================================

(print "Testing type-decl and type-check (declaration and query)...")

; Declare type for a value
(define my-x #42)
(type-decl my-x (Int))

; Query declared type
(test-case :query-declared
   #t
   (type-equal? (type-check my-x) (Int)))

; Declare type for a function
(define my-inc (lambda (n) (+ n #1)))
(type-decl my-inc (-> (Int) (Int)))

(test-case :query-func-type
   #t
   (type-equal? (type-check my-inc) (-> (Int) (Int))))

; Query undeclared - returns nil
(define my-y #99)
(test-case :query-undeclared
   nil
   (type-check my-y))

; ============================================================================
; Test: Type introspection for function types
; ============================================================================

(print "Testing type introspection...")

; Get domain (input type) of function type
(test-case :type-domain
   #t
   (type-equal? (type-domain (-> (Int) (Bool))) (Int)))

; Get codomain (output type) of function type
(test-case :type-codomain
   #t
   (type-equal? (type-codomain (-> (Int) (Bool))) (Bool)))

; Get element type of list type
(test-case :type-element
   #t
   (type-equal? (type-element (List-type (Int))) (Int)))

; Multi-arg function domain
(test-case :type-domain-multi
   #t
   (type-equal? (type-domain (-> (Int) (Bool) (String))) (Int)))

; ============================================================================
; Integration Tests
; ============================================================================

(print "Testing integration scenarios...")

; Declare and use typed values
(define typed-add (lambda (x y) (+ x y)))
(type-decl typed-add (-> (Int) (Int) (Int)))

(test-case :typed-func-use
   #5
   (typed-add #2 #3))

(test-case :typed-func-query
   #t
   (type-equal? (type-check typed-add) (-> (Int) (Int) (Int))))

; Multiple declarations
(define a #1)
(define b #2)
(define c "three")
(type-decl a (Int))
(type-decl b (Int))
(type-decl c (String))

(test-case :multi-decl-a
   #t
   (type-equal? (type-check a) (Int)))

(test-case :multi-decl-b
   #t
   (type-equal? (type-check b) (Int)))

(test-case :multi-decl-c
   #t
   (type-equal? (type-check c) (String)))

; Type checks with computed values
(test-case :typeof-computed
   #t
   (struct? (type-of (+ #1 #2)) :type))

(print "\nâœ… All type annotation tests passed!")
