; Test: Resumable Effect Handlers
; Day 87 - Continuations via replay-based resumption
;
; handle-resume handlers receive continuation k as first argument.
; Calling (k value) resumes the body computation.
; Not calling k aborts (handler result replaces handle-resume).

; Load iteration macros for ⊎ (begin/sequencing)
(load "bootstrap/stdlib/macros_iteration.scm")

; ============ Declare Effects ============

(effect-def :Ask :prompt)
(effect-def :State :get :put)
(effect-def :Yield :value)
(effect-def :Logger :log)
(effect-def :Choice :choose)
(effect-def :Math :compute)

; ============ Basic Resume ============

; Handler calls k — body completes with resumed value
(test-case (quote :basic-resume)
  #42
  (handle-resume (perform :State :get)
    (:State
      (:get (lambda (k) (k #42)))
      (:put (lambda (k v) (k nil))))))

; Resume in arithmetic expression
(test-case (quote :resume-in-expr)
  #43
  (handle-resume (+ (perform :State :get) #1)
    (:State
      (:get (lambda (k) (k #42)))
      (:put (lambda (k v) (k nil))))))

; Resume with argument passed through
(test-case (quote :resume-with-arg)
  #99
  (handle-resume (perform :State :put #99)
    (:State
      (:get (lambda (k) (k #0)))
      (:put (lambda (k v) (k v))))))

; Handler uses perform arg to compute resume value
(test-case (quote :handler-computes)
  #84
  (handle-resume (perform :State :put #42)
    (:State
      (:get (lambda (k) (k #0)))
      (:put (lambda (k v) (k (* v #2)))))))

; ============ No Resume (Abort) ============

; Handler doesn't call k — acts like exception
(test-case (quote :abort-no-k)
  :aborted
  (handle-resume (+ (perform :State :get) #1)
    (:State
      (:get (lambda (k) :aborted))
      (:put (lambda (k v) :aborted)))))

; Abort returns handler's direct value
(test-case (quote :abort-with-value)
  #999
  (handle-resume (+ (perform :State :get) #1)
    (:State
      (:get (lambda (k) #999))
      (:put (lambda (k v) nil)))))

; ============ Handler Transforms Result ============

; Handler wraps continuation result
(test-case (quote :transform-result)
  #84
  (handle-resume (perform :State :get)
    (:State
      (:get (lambda (k) (* (k #42) #2)))
      (:put (lambda (k v) (k nil))))))
; k(42) -> body returns 42, handler doubles -> 84

; Handler post-processes with addition
(test-case (quote :transform-add)
  #143
  (handle-resume (+ (perform :State :get) #1)
    (:State
      (:get (lambda (k) (+ (k #42) #100)))
      (:put (lambda (k v) (k nil))))))
; k(42) -> body returns 43, handler adds 100 -> 143

; ============ Multiple Performs ============

; Two performs — each handled independently via replay
(test-case (quote :two-performs)
  #52
  (handle-resume (+ (perform :Ask :prompt "x") (perform :Ask :prompt "y"))
    (:Ask
      (:prompt (lambda (k msg)
        (k (if (equal? msg "x") #10 #42)))))))
; First: msg="x" -> k(10). Second: msg="y" -> k(42). 10+42=52

; Three performs
(test-case (quote :three-performs)
  #6
  (handle-resume (+ (perform :Ask :prompt "a")
           (+ (perform :Ask :prompt "b")
               (perform :Ask :prompt "c")))
    (:Ask
      (:prompt (lambda (k msg)
        (k (if (equal? msg "a") #1
              (if (equal? msg "b") #2 #3))))))))
; 1 + 2 + 3 = 6

; ============ Perform in Conditional ============

(test-case (quote :perform-in-cond)
  :big
  (handle-resume (if (> (perform :State :get) #10) :big :small)
    (:State
      (:get (lambda (k) (k #42)))
      (:put (lambda (k v) (k nil))))))

; ============ Perform in Lambda ============

; Perform inside zero-arg lambda
(test-case (quote :perform-in-lambda)
  #42
  (handle-resume ((lambda () (perform :State :get)))
    (:State
      (:get (lambda (k) (k #42)))
      (:put (lambda (k v) (k nil))))))

; Higher-order: pass effectful function
(test-case (quote :effectful-fn)
  #42
  (handle-resume ((lambda (f) (f)) (lambda () (perform :State :get)))
    (:State
      (:get (lambda (k) (k #42)))
      (:put (lambda (k v) (k nil))))))

; ============ Generator / Yield Pattern ============

; Collect yielded values into a list
; Handler wraps continuation result with cons
(test-case (quote :yield-collect)
  (cons #1 (cons #2 (cons #3 nil)))
  (handle-resume (⊎ (perform :Yield :value #1)
            (perform :Yield :value #2)
            (perform :Yield :value #3)
            nil)
    (:Yield
      (:value (lambda (k v) (cons v (k nil)))))))

; Two-element yield
(test-case (quote :yield-two)
  (cons :a (cons :b nil))
  (handle-resume (⊎ (perform :Yield :value :a)
            (perform :Yield :value :b)
            nil)
    (:Yield
      (:value (lambda (k v) (cons v (k nil)))))))

; ============ Choice Effect ============

; Handler picks first option
(test-case (quote :choice-first)
  #10
  (handle-resume (perform :Choice :choose #10 #20)
    (:Choice
      (:choose (lambda (k a b) (k a))))))

; Handler picks second option
(test-case (quote :choice-second)
  #20
  (handle-resume (perform :Choice :choose #10 #20)
    (:Choice
      (:choose (lambda (k a b) (k b))))))

; Choice in arithmetic
(test-case (quote :choice-in-expr)
  #15
  (handle-resume (+ (perform :Choice :choose #10 #20) #5)
    (:Choice
      (:choose (lambda (k a b) (k a))))))

; ============ Multi-arg Perform ============

(test-case (quote :multi-arg-resume)
  #7
  (handle-resume (perform :Math :compute #3 #4)
    (:Math
      (:compute (lambda (k a b) (k (+ a b)))))))

; ============ Handler Closure ============

(define multiplier #3)
(test-case (quote :handler-closure)
  #126
  (handle-resume (perform :State :get)
    (:State
      (:get (lambda (k) (k (* #42 multiplier))))
      (:put (lambda (k v) (k nil))))))

; Handler from named function
(define my-getter (lambda (k) (k #77)))
(test-case (quote :handler-named-fn)
  #77
  (handle-resume (perform :State :get)
    (:State
      (:get my-getter)
      (:put (lambda (k v) (k nil))))))

; ============ No Effect Performed ============

; Body without performs returns normally
(test-case (quote :no-perform)
  #42
  (handle-resume #42
    (:State
      (:get (lambda (k) (k #0)))
      (:put (lambda (k v) (k nil))))))

; Complex body without performs
(test-case (quote :no-perform-complex)
  #10
  (handle-resume (+ #3 #7)
    (:State
      (:get (lambda (k) (k #0)))
      (:put (lambda (k v) (k nil))))))

; ============ Nested Resumable Handlers ============

; Inner resumable shadows outer for same effect
(test-case (quote :nested-shadow)
  #99
  (handle-resume
    (handle-resume (perform :State :get)
      (:State
        (:get (lambda (k) (k #99)))
        (:put (lambda (k v) (k nil)))))
    (:State
      (:get (lambda (k) (k #42)))
      (:put (lambda (k v) (k nil))))))

; Different effects across nested resumable handlers
(test-case (quote :nested-different)
  :logged
  (handle-resume
    (handle-resume (perform :Logger :log "msg")
      (:State
        (:get (lambda (k) (k #0)))
        (:put (lambda (k v) (k nil)))))
    (:Logger
      (:log (lambda (k msg) (k :logged))))))

; ============ Mix Resumable and Non-Resumable ============

; Resumable inner handles :State, non-resumable outer handles :Logger
(test-case (quote :mix-resume-nonresume)
  #43
  (handle
    (+ (handle-resume (perform :State :get)
          (:State
            (:get (lambda (k) (k #42)))
            (:put (lambda (k v) (k nil)))))
       #1)
    (:Logger
      (:log (lambda (msg) nil)))))

; Non-resumable inner, resumable outer
(test-case (quote :nonresume-inner-resume-outer)
  #43
  (handle-resume
    (+ (handle (perform :State :get)
          (:State
            (:get (lambda () #42))
            (:put (lambda (v) nil))))
       (perform :Logger :log "hi"))
    (:Logger
      (:log (lambda (k msg) (k #1))))))

; ============ Practical: Dependency Injection ============

(effect-def :Config :get)
(define get-config-r (lambda (key) (perform :Config :get key)))

(test-case (quote :di-config)
  "localhost:5432"
  (handle-resume (get-config-r :db-url)
    (:Config
      (:get (lambda (k key)
        (k (if (equal? key :db-url) "localhost:5432"
              (if (equal? key :port) #8080
                 "unknown"))))))))

(test-case (quote :di-config-port)
  #8080
  (handle-resume (get-config-r :port)
    (:Config
      (:get (lambda (k key)
        (k (if (equal? key :db-url) "localhost:5432"
              (if (equal? key :port) #8080
                 "unknown"))))))))

; ============ Zero-arg Perform ============

(test-case (quote :zero-arg-resume)
  #42
  (handle-resume (perform :State :get)
    (:State
      (:get (lambda (k) (k #42)))
      (:put (lambda (k v) (k nil))))))

; ============ Summary ============
; Total: 30 tests
