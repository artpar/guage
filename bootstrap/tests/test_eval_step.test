;;;
;;; Step-by-step evaluator test - find exact crash point
;;;

(load "bootstrap/stdlib/eval.scm")

(define empty-env (env-empty))

;;; Step 1: Test eval-atom with number
(print :step-1-atom-number)
(print ((eval-atom #42) empty-env))

;;; Step 2: Test eval-atom with boolean
(print :step-2-atom-bool)
(print ((eval-atom #t) empty-env))

;;; Step 3: Test eval-atom with nil
(print :step-3-atom-nil)
(print ((eval-atom nil) empty-env))

;;; Step 4: Check if quoted lambda is a list
(define lambda-expr (quote (lambda (:x) :x)))
(print :step-4-is-list)
(print (pair? lambda-expr))

;;; Step 5: Check special-form? function
(print :step-5-special-form-check)
(print (special-form? lambda-expr))

;;; Step 6: Get operator of lambda
(print :step-6-lambda-operator)
(print (car lambda-expr))

;;; Step 7: Compare operator
(print :step-7-compare-operator)
(print (equal? (car lambda-expr) :lambda))

;;; Step 8: Get rest of lambda (params and body)
(print :step-8-lambda-rest)
(print (cdr lambda-expr))

;;; Step 9: Check if rest is a list
(print :step-9-rest-is-list)
(print (pair? (cdr lambda-expr)))

;;; Step 10: Get params
(print :step-10-get-params)
(print (car (cdr lambda-expr)))

;;; Step 11: Get body list
(print :step-11-get-body-list)
(print (cdr (cdr lambda-expr)))

;;; Step 12: Check if body list is a list
(print :step-12-body-is-list)
(print (pair? (cdr (cdr lambda-expr))))

;;; Step 13: Get actual body expression
(print :step-13-get-body)
(print (car (cdr (cdr lambda-expr))))

;;; Step 14: Try eval-lambda directly
(print :step-14-eval-lambda)
(define params (car (cdr lambda-expr)))
(define body (car (cdr (cdr lambda-expr))))
(print params)
(print body)
(print (((eval-lambda params) body) empty-env))

;;; Step 15: Try full eval on number
(print :step-15-eval-number)
(print ((eval #42) empty-env))

;;; Step 16: Try full eval on lambda (THIS MIGHT CRASH)
(print :step-16-eval-lambda-FULL)
(print ((eval lambda-expr) empty-env))
