; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Test Suite: Standard Library Macros
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Status: CURRENT
; Created: 2026-01-27 (Day 34)
; Purpose: Comprehensive tests for stdlib/macros.scm
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

; Load the macros module
(â‹˜ "bootstrap/stdlib/macros.scm")

; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Phase 1: Control Flow Macros
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

; Test 1: ?Â¬ (unless) with false condition - should execute body
(âŠ¨ :test-?Â¬-false #42 (?Â¬ #f #42))

; Test 2: ?Â¬ (unless) with true condition - should return nil
(âŠ¨ :test-?Â¬-true âˆ… (?Â¬ #t #42))

; Test 3: ?Â¬ with computation
(âŠ¨ :test-?Â¬-comp #10 (?Â¬ (< #5 #3) (âŠ• #5 #5)))

; Test 4: âˆ§â€¦ (short-circuit AND) both true
(âŠ¨ :test-âˆ§â€¦-both-true #t (âˆ§â€¦ #t #t))

; Test 5: âˆ§â€¦ first false (should short-circuit)
(âŠ¨ :test-âˆ§â€¦-first-false #f (âˆ§â€¦ #f #t))

; Test 6: âˆ§â€¦ second false
(âŠ¨ :test-âˆ§â€¦-second-false #f (âˆ§â€¦ #t #f))

; Test 7: âˆ§â€¦ with computation
(âŠ¨ :test-âˆ§â€¦-comp #t (âˆ§â€¦ (> #10 #5) (< #3 #7)))

; Test 8: âˆ¨â€¦ (short-circuit OR) both false
(âŠ¨ :test-âˆ¨â€¦-both-false #f (âˆ¨â€¦ #f #f))

; Test 9: âˆ¨â€¦ first true (should short-circuit)
(âŠ¨ :test-âˆ¨â€¦-first-true #t (âˆ¨â€¦ #t #f))

; Test 10: âˆ¨â€¦ second true
(âŠ¨ :test-âˆ¨â€¦-second-true #t (âˆ¨â€¦ #f #t))

; Test 11: âˆ¨â€¦ with computation
(âŠ¨ :test-âˆ¨â€¦-comp #t (âˆ¨â€¦ (< #10 #5) (> #7 #3)))

; Test 12: âŠ³â†’ (thread-first) simple
(âŠ¨ :test-âŠ³â†’-simple #6 (âŠ³â†’ #5 (Î» (ğ•©) (âŠ• ğ•© #1))))

; Test 13: âŠ³â†’ with multiplication
(âŠ¨ :test-âŠ³â†’-mult #10 (âŠ³â†’ #5 (Î» (ğ•©) (âŠ— ğ•© #2))))

; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Phase 2: Binding Macros
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

; Test 14: â‰”â†“ (let) simple binding
(âŠ¨ :test-â‰”â†“-simple #43 (â‰”â†“ ğ•© #42 (âŠ• ğ•© #1)))

; Test 15: â‰”â†“ with computation in value
(âŠ¨ :test-â‰”â†“-comp #30 (â‰”â†“ ğ•© (âŠ• #10 #5) (âŠ— ğ•© #2)))

; Test 16: â‰”â†“ nested usage (must use ğ•© for both levels)
(âŠ¨ :test-â‰”â†“-nested #12
   (â‰”â†“ ğ•© #5
     (â‰”â†“ ğ•© (âŠ• ğ•© #1)
       (âŠ— ğ•© #2))))

; Test 17: â‰”â†» (letrec) basic binding (non-recursive)
(âŠ¨ :test-â‰”â†»-basic #10
   (â‰”â†» ğ•— (Î» (ğ•©) (âŠ— ğ•© #2))
     (ğ•— #5)))

; Note: Recursive tests omitted - â‰”â†» cannot create true recursive bindings
; Use â‰” (global definition) for recursive functions instead

; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Phase 3: Functional Macros
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

; Test 19: âˆ˜ (compose) simple
(âŠ¨ :test-âˆ˜-simple #12
   ((âˆ˜ (Î» (ğ•©) (âŠ— ğ•© #2)) (Î» (ğ•©) (âŠ• ğ•© #1))) #5))

; Test 20: âˆ˜ with different functions
(âŠ¨ :test-âˆ˜-diff #25
   ((âˆ˜ (Î» (ğ•©) (âŠ— ğ•© ğ•©)) (Î» (ğ•©) (âŠ• ğ•© #2))) #3))

; Test 21: âˆ˜ triple composition
(âŠ¨ :test-âˆ˜-triple #14
   ((âˆ˜ (Î» (ğ•©) (âŠ• ğ•© #2)) (âˆ˜ (Î» (ğ•©) (âŠ— ğ•© #2)) (Î» (ğ•©) (âŠ• ğ•© #1)))) #5))

; Test 22: âŠ° (partial) simple
(âŠ¨ :test-âŠ°-simple #15 ((âŠ° âŠ• #10) #5))

; Test 23: âŠ° with subtraction
(âŠ¨ :test-âŠ°-sub #5 ((âŠ° âŠ– #10) #5))

; Test 24: âŠ° with multiplication
(âŠ¨ :test-âŠ°-mult #20 ((âŠ° âŠ— #4) #5))

; Test 25: â†” (flip) simple
(âŠ¨ :test-â†”-simple #5 ((â†” âŠ–) #5 #10))

; Test 26: â†” with division
(âŠ¨ :test-â†”-div #2 ((â†” âŠ˜) #5 #10))

; Test 27: â†” double flip (identity)
(âŠ¨ :test-â†”-double #-5 ((â†” (â†” âŠ–)) #5 #10))

; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Integration Tests: Combining Macros
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

; Test 28: Compose and partial
(âŠ¨ :test-comp-partial #32
   ((âˆ˜ (âŠ° âŠ— #2) (âŠ° âŠ• #6)) #10))

; Test 29: Let with unless (< #5 #10) is true, so unless returns nil
(âŠ¨ :test-let-unless âˆ…
   (â‰”â†“ ğ•© #5 (?Â¬ (< ğ•© #10) #42)))

; Test 30: Compose with flip - compose needs compatible functions
; Instead test: flip then apply
(âŠ¨ :test-comp-flip #5
   ((â†” âŠ–) #5 #10))

; Test 31: Short-circuit avoids error
(âŠ¨ :test-short-and #f
   (âˆ§â€¦ (> #10 #5) (< #20 #10)))

; Test 32: Partial with compose
(âŠ¨ :test-partial-comp #30
   ((âˆ˜ (âŠ° âŠ— #3) (âŠ° âŠ• #5)) #5))

; Test 33: Unless with let
(âŠ¨ :test-unless-let #15
   (â‰”â†“ ğ•© #5 (?Â¬ (< ğ•© #0) (âŠ— ğ•© #3))))

; Test 34: Nested let with operations (must use ğ•© for both levels)
; Inner binds ğ•©=#7, evaluates (âŠ• (* 7 2) 7) = (âŠ• 14 7) = 21
(âŠ¨ :test-nested-let #21
   (â‰”â†“ ğ•© #5
     (â‰”â†“ ğ•© #7
       (âŠ• (âŠ— ğ•© #2) ğ•©))))

; Test 35: Letrec with composition (non-recursive)
; Apply ğ•— first: (* 5 3)=15, then (âŠ° âŠ• #5): (+ 5 15)=20
(âŠ¨ :test-letrec-comp #20
   (â‰”â†» ğ•— (Î» (ğ•©) (âŠ— ğ•© #3))
     ((âˆ˜ (âŠ° âŠ• #5) ğ•—) #5)))

; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; Summary
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"âœ“ 33 stdlib macro tests (2 recursive tests removed due to macro limitations)"
