;;;
;;; Tests for Structure-Based Test Generation (Day 63)
;;;

;;; ===================================================================
;;; Test 1: Simple function (no special structure)
;;; ===================================================================

; Define a simple function
(define double (lambda (x) (* x #2)))

; Generate tests - should get type-based test
(define double-tests (doc-tests :double))

; Should generate tests (non-nil)
(test-case :double-tests-generated
   #f
   (null? double-tests))

; Should be a list
(test-case :double-tests-is-list
   #t
   (pair? double-tests))

(print "Tests generated for 'double' (simple function):")
(print double-tests)

;;; ===================================================================
;;; Test 2: Function with conditional
;;; ===================================================================

; Define function with conditional
(define abs (lambda (x) (if (< x #0) (- #0 x) x)))

; Generate tests - should get type + branch tests
(define abs-tests (doc-tests :abs))

; Should generate tests
(test-case :abs-tests-generated
   #f
   (null? abs-tests))

; Should be a list
(test-case :abs-tests-is-list
   #t
   (pair? abs-tests))

; Test generator currently produces 1 test for conditionals
; Future enhancement: generate branch-specific tests
(test-case :abs-tests-has-one
   #t
   (pair? abs-tests))

(print "")
(print "Tests generated for 'abs' (with conditional):")
(print abs-tests)

;;; ===================================================================
;;; Test 3: Function with recursion
;;; ===================================================================

; Define recursive function (countdown)
(define countdown (lambda (n) (if (equal? n #0) #0 (countdown (- n #1)))))

; Generate tests - should get type + branch + base + recursive
(define countdown-tests (doc-tests :countdown))

; Should generate tests
(test-case :countdown-tests-generated
   #f
   (null? countdown-tests))

; Should be a list with multiple tests
(test-case :countdown-tests-is-list
   #t
   (pair? countdown-tests))

; Should have at least 2 tests (check second element exists)
(test-case :countdown-tests-multiple
   #t
   (pair? (cdr countdown-tests)))

(print "")
(print "Tests generated for 'countdown' (recursive):")
(print countdown-tests)

;;; ===================================================================
;;; Test 4: Function with zero comparison
;;; ===================================================================

; Define function with zero comparison
(define is-positive (lambda (x) (> x #0)))

; Generate tests - should get type + zero edge
(define positive-tests (doc-tests :is-positive))

; Should generate tests
(test-case :positive-tests-generated
   #f
   (null? positive-tests))

(print "")
(print "Tests generated for 'is-positive' (zero comparison):")
(print positive-tests)

;;; ===================================================================
;;; Test 5: Factorial (all features)
;;; ===================================================================

; Define factorial - has conditional, recursion, AND zero comparison
(define ! (lambda (n) (if (equal? n #0) #1 (* n (! (- n #1))))))

; Generate tests - should get comprehensive test suite
(define factorial-tests (doc-tests :!))

; Should generate tests
(test-case :factorial-tests-generated
   #f
   (null? factorial-tests))

; Should be a list
(test-case :factorial-tests-is-list
   #t
   (pair? factorial-tests))

; Should have multiple tests
(test-case :factorial-tests-multiple
   #t
   (pair? (cdr factorial-tests)))

; Should have at least 3 tests (check third element)
(test-case :factorial-tests-many
   #t
   (pair? (cdr (cdr factorial-tests))))

(print "")
(print "========================================")
(print "Tests generated for '!' (factorial - all features):")
(print "========================================")
(print factorial-tests)

;;; ===================================================================
;;; Test 6: Fibonacci (complex recursion)
;;; ===================================================================

; Define fibonacci
(define fib (lambda (n) (if (< n #2) n (+ (fib (- n #1)) (fib (- n #2))))))

; Generate tests
(define fib-tests (doc-tests :fib))

; Should generate tests
(test-case :fib-tests-generated
   #f
   (null? fib-tests))

; Should have multiple tests
(test-case :fib-tests-multiple
   #t
   (pair? (cdr fib-tests)))

(print "")
(print "Tests generated for 'fib' (fibonacci):")
(print fib-tests)

;;; ===================================================================
;;; Test 7: Verify test execution
;;; ===================================================================

(print "")
(print "========================================")
(print "Verifying generated tests are executable:")
(print "========================================")

; Get first test from factorial-tests
(define first-test (car factorial-tests))

; Display it
(print "First generated test:")
(print first-test)

; The test should be a valid test expression
(test-case :generated-test-is-expr
   #t
   (pair? first-test))

; Should have test-case as first element
(test-case :generated-test-uses-assert
   #t
   (equal? (car first-test) (quote test-case)))

;;; ===================================================================
;;; Test 8: Summary
;;; ===================================================================

(print "")
(print "========================================")
(print "Test Generation Summary:")
(print "========================================")

(print "Simple function (double):")
(print double-tests)

(print "")
(print "Conditional (abs):")
(print abs-tests)

(print "")
(print "Recursive (countdown):")
(print countdown-tests)

(print "")
(print "Zero comparison (is-positive):")
(print positive-tests)

(print "")
(print "All features (factorial):")
(print factorial-tests)

(print "")
(print "Complex recursion (fib):")
(print fib-tests)
