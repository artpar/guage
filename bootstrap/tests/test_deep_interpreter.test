;;;
;;; Deep Integration: ADTs + Pattern Matching + Recursion + Effects + Closures + HashMap + Error Handling
;;; A mini-interpreter for an expression language
;;;

;;; --- AST defined as ADT ---

(adt-define :Expr
  (quote (:Lit :val))
  (quote (:Var :name))
  (quote (:Plus :left :right))
  (quote (:Times :left :right))
  (quote (:IfZ :cond :then :else))
  (quote (:Let :var :val :body))
  (quote (:Lam :param :body))
  (quote (:App :fn :arg)))

;;; --- Environment via HashMap (copy-on-extend for immutability) ---

(define empty-env (hashmap))

(define env-lookup (lambda (env name)
  (begin
    (define elv (hashmap-get env name))
    (if (null? elv) (error :undefined-var name) elv))))

(define env-extend (lambda (env name val)
  (begin
    (define nenv (hashmap))
    (define ekeys (hashmap-keys env))
    (define ecopy (lambda (ks)
      (if (null? ks) nil
         (begin (hashmap-put nenv (car ks) (hashmap-get env (car ks)))
             (ecopy (cdr ks))))))
    (ecopy ekeys)
    (hashmap-put nenv name val)
    nenv)))

;;; --- Forward declaration stub (will be redefined) ---
(define interp (lambda (expr env) nil))

;;; --- Evaluator helpers (one per node type to avoid deep nesting) ---

(define interp-plus (lambda (expr env)
  (begin
    (define ipL (interp (adt-get expr :left) env))
    (define ipR (interp (adt-get expr :right) env))
    (if (error? ipL) ipL (if (error? ipR) ipR (+ ipL ipR))))))

(define interp-times (lambda (expr env)
  (begin
    (define itL (interp (adt-get expr :left) env))
    (define itR (interp (adt-get expr :right) env))
    (if (error? itL) itL (if (error? itR) itR (* itL itR))))))

(define interp-ifz (lambda (expr env)
  (begin
    (define icv (interp (adt-get expr :cond) env))
    (if (error? icv) icv
       (if (equal? icv #0)
          (interp (adt-get expr :then) env)
          (interp (adt-get expr :else) env))))))

(define interp-let (lambda (expr env)
  (begin
    (define ilv (interp (adt-get expr :val) env))
    (if (error? ilv) ilv
       (interp (adt-get expr :body)
               (env-extend env (adt-get expr :var) ilv))))))

(define interp-app (lambda (expr env)
  (begin
    (define iafv (interp (adt-get expr :fn) env))
    (define iaav (interp (adt-get expr :arg) env))
    (if (error? iafv) iafv
       (if (error? iaav) iaav
          (if (and (pair? iafv) (equal? (car iafv) :closure))
             (begin
               (define iap (car (cdr iafv)))
               (define iab (car (cdr (cdr iafv))))
               (define iae (car (cdr (cdr (cdr iafv)))))
               (interp iab (env-extend iae iap iaav)))
             (error :not-a-function iafv)))))))

;;; --- Main evaluator dispatcher ---

(define interp (lambda (expr env)
  (if (adt? expr :Expr :Lit)   (adt-get expr :val)
  (if (adt? expr :Expr :Var)   (env-lookup env (adt-get expr :name))
  (if (adt? expr :Expr :Plus)  (interp-plus expr env)
  (if (adt? expr :Expr :Times) (interp-times expr env)
  (if (adt? expr :Expr :IfZ)   (interp-ifz expr env)
  (if (adt? expr :Expr :Let)   (interp-let expr env)
  (if (adt? expr :Expr :Lam)
     (cons :closure (cons (adt-get expr :param) (cons (adt-get expr :body) (cons env nil))))
  (if (adt? expr :Expr :App)   (interp-app expr env)
     (error :unknown-expr expr)))))))))))

;;; --- Test: literal ---
(test-case :interp-lit #42
  (interp (adt-create :Expr :Lit #42) empty-env))

;;; --- Test: addition ---
(test-case :interp-add #8
  (interp (adt-create :Expr :Plus (adt-create :Expr :Lit #3) (adt-create :Expr :Lit #5)) empty-env))

;;; --- Test: multiplication ---
(test-case :interp-times #15
  (interp (adt-create :Expr :Times (adt-create :Expr :Lit #3) (adt-create :Expr :Lit #5)) empty-env))

;;; --- Test: nested arithmetic: (2 + 3) * 4 ---
(test-case :interp-nested #20
  (interp (adt-create :Expr :Times
    (adt-create :Expr :Plus (adt-create :Expr :Lit #2) (adt-create :Expr :Lit #3))
    (adt-create :Expr :Lit #4))
  empty-env))

;;; --- Test: if-zero true branch ---
(test-case :interp-ifz-true #10
  (interp (adt-create :Expr :IfZ (adt-create :Expr :Lit #0) (adt-create :Expr :Lit #10) (adt-create :Expr :Lit #20))
  empty-env))

;;; --- Test: if-zero false branch ---
(test-case :interp-ifz-false #20
  (interp (adt-create :Expr :IfZ (adt-create :Expr :Lit #1) (adt-create :Expr :Lit #10) (adt-create :Expr :Lit #20))
  empty-env))

;;; --- Test: let binding ---
(test-case :interp-let #12
  (interp (adt-create :Expr :Let :x (adt-create :Expr :Lit #5)
    (adt-create :Expr :Plus (adt-create :Expr :Var :x) (adt-create :Expr :Lit #7)))
  empty-env))

;;; --- Test: nested let ---
(test-case :interp-nested-let #11
  (interp (adt-create :Expr :Let :x (adt-create :Expr :Lit #3)
    (adt-create :Expr :Let :y (adt-create :Expr :Lit #8)
      (adt-create :Expr :Plus (adt-create :Expr :Var :x) (adt-create :Expr :Var :y))))
  empty-env))

;;; --- Test: lambda + application ---
(test-case :interp-lam-app #10
  (interp (adt-create :Expr :App
    (adt-create :Expr :Lam :x (adt-create :Expr :Times (adt-create :Expr :Var :x) (adt-create :Expr :Lit #2)))
    (adt-create :Expr :Lit #5))
  empty-env))

;;; --- Test: closure captures environment ---
(test-case :interp-closure #15
  (interp (adt-create :Expr :Let :y (adt-create :Expr :Lit #10)
    (adt-create :Expr :App
      (adt-create :Expr :Lam :x (adt-create :Expr :Plus (adt-create :Expr :Var :x) (adt-create :Expr :Var :y)))
      (adt-create :Expr :Lit #5)))
  empty-env))

;;; --- Test: undefined variable error ---
(test-case :interp-undef-var #t
  (error? (interp (adt-create :Expr :Var :z) empty-env)))

;;; --- Test: non-function application error ---
(test-case :interp-not-fn #t
  (error? (interp (adt-create :Expr :App (adt-create :Expr :Lit #42) (adt-create :Expr :Lit #1)) empty-env)))

;;; --- Test: complex expression: let f = Î»x.(x+1) in f(f(3)) ---
(test-case :interp-complex #5
  (interp (adt-create :Expr :Let :f
    (adt-create :Expr :Lam :x (adt-create :Expr :Plus (adt-create :Expr :Var :x) (adt-create :Expr :Lit #1)))
    (adt-create :Expr :App (adt-create :Expr :Var :f)
      (adt-create :Expr :App (adt-create :Expr :Var :f) (adt-create :Expr :Lit #3))))
  empty-env))

;;; --- Test: evaluator wrapped in effect handler ---

(effect-def :InterpLog :eval)

(test-case :interp-with-effect #8
  (handle
    (interp (adt-create :Expr :Plus
      (adt-create :Expr :Lit (perform :InterpLog :eval #3))
      (adt-create :Expr :Lit (perform :InterpLog :eval #5)))
    empty-env)
    (:InterpLog
      (:eval (lambda (v) v)))))
