;;;
;;; Deep Integration: Pattern Matching (guards/as-patterns/view patterns) + Effects + ADTs + Error Handling
;;;

;;; --- ADT definitions ---

(adt-define :Result (quote (:Ok :value)) (quote (:Err :error)))

;;; --- Pattern match on ADT variant inside effect handler ---

(effect-def :Provider :fetch)

(test-case :adt-in-handler :got-ok
  (handle
    (match (perform :Provider :fetch :data) (quote (
      ((adt-create :Result :Ok v) :got-ok)
      ((adt-create :Result :Err e) :got-err))))
    (:Provider
      (:fetch (lambda (key) (adt-create :Result :Ok #42))))))

;;; --- Effect handler returns ADT, pattern match outside ---

(define handler-res (handle (perform :Provider :fetch :data)
  (:Provider
    (:fetch (lambda (key) (adt-create :Result :Ok #99))))))

(test-case :adt-from-handler #99
  (match handler-res (quote (
    ((adt-create :Result :Ok v) v)
    ((adt-create :Result :Err e) #0)))))

;;; --- Guard depends on constant threshold ---

(test-case :guard-threshold :high
  (handle
    (match (adt-create :Result :Ok (perform :Provider :fetch :temp)) (quote (
      (((adt-create :Result :Ok v) | (> v #50)) :high)
      ((adt-create :Result :Ok v) :low)
      ((adt-create :Result :Err e) :error))))
    (:Provider
      (:fetch (lambda (key) #75)))))

;;; --- Resumable effect result matched by pattern with guard ---

(effect-def :State :get :put)

(test-case :resumable-guard :big
  (handle-resume
    (match (perform :State :get) (quote (
      ((n | (> n #50)) :big)
      (n :small))))
    (:State
      (:get (lambda (k) (k #100)))
      (:put (lambda (k v) (k nil))))))

;;; --- ADT construction inside resumable handler, destructured outside ---

(test-case :adt-from-resumable #t
  (adt? (handle-resume (adt-create :Result :Ok (perform :State :get))
    (:State
      (:get (lambda (k) (k #77)))
      (:put (lambda (k v) (k nil)))))
  :Result :Ok))

(test-case :adt-from-resumable-val #77
  (adt-get (handle-resume (adt-create :Result :Ok (perform :State :get))
    (:State
      (:get (lambda (k) (k #77)))
      (:put (lambda (k v) (k nil)))))
  :value))

;;; --- View pattern with classify function on effect-returned value ---

(define classify (lambda (n)
  (if (> n #100) :hot
     (if (> n #50) :warm
        :cold))))

(test-case :view-pattern-effect :warm
  (handle
    (match (perform :Provider :fetch :temp) (quote (
      ((-> classify :hot) :hot)
      ((-> classify :warm) :warm)
      (_ :other))))
    (:Provider
      (:fetch (lambda (key) #75)))))

;;; --- Nested pattern match + effect perform in one branch ---

(test-case :nested-match-effect :inner-ok
  (handle
    (match (perform :Provider :fetch :outer) (quote (
      ((adt-create :Result :Ok v)
        (match (adt-create :Result :Ok (+ v #10)) (quote (
          ((adt-create :Result :Ok w) :inner-ok)
          (_ :inner-other)))))
      (_ :outer-fail))))
    (:Provider
      (:fetch (lambda (key) (adt-create :Result :Ok #5))))))

;;; --- As-pattern captures full ADT while destructuring fields ---

(test-case :as-pattern-adt #t
  (match (adt-create :Result :Ok #42) (quote (
    ((whole @ (adt-create :Result :Ok v)) (and (adt? whole :Result :Ok) (equal? v #42)))))))

;;; --- Guard on ADT field value ---

(test-case :guard-adt-field :large-ok
  (match (adt-create :Result :Ok #150) (quote (
    (((adt-create :Result :Ok v) | (> v #100)) :large-ok)
    ((adt-create :Result :Ok v) :small-ok)
    ((adt-create :Result :Err e) :error)))))

;;; --- Recursive AST evaluator using ADT + pattern matching + error handling ---

(adt-define :Expr
  (quote (:Num :val))
  (quote (:Add :left :right))
  (quote (:Div :numer :denom)))

(define eval-expr (lambda (e)
  (if (adt? e :Expr :Num)
     (adt-get e :val)
     (if (adt? e :Expr :Add)
        (+ (eval-expr (adt-get e :left)) (eval-expr (adt-get e :right)))
        (if (adt? e :Expr :Div)
           (begin
             (define d (eval-expr (adt-get e :denom)))
             (if (equal? d #0)
                (error :div-by-zero nil)
                (/ (eval-expr (adt-get e :numer)) d)))
           (error :unknown-expr e))))))

(test-case :eval-num #5 (eval-expr (adt-create :Expr :Num #5)))

(test-case :eval-add #8
  (eval-expr (adt-create :Expr :Add (adt-create :Expr :Num #3) (adt-create :Expr :Num #5))))

(test-case :eval-div #4
  (eval-expr (adt-create :Expr :Div (adt-create :Expr :Num #20) (adt-create :Expr :Num #5))))

(test-case :eval-div-zero #t
  (error? (eval-expr (adt-create :Expr :Div (adt-create :Expr :Num #10) (adt-create :Expr :Num #0)))))

;;; --- Evaluator wrapped in effect handler ---

(test-case :eval-in-handler #8
  (handle (eval-expr (adt-create :Expr :Add
    (adt-create :Expr :Num (perform :Provider :fetch :x))
    (adt-create :Expr :Num (perform :Provider :fetch :y))))
    (:Provider
      (:fetch (lambda (key)
        (if (equal? key :x) #3
           (if (equal? key :y) #5 #0)))))))
