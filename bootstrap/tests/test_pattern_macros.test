; ═══════════════════════════════════════════════════════════════
; Test suite for pattern-based macros (Day 75)
; ═══════════════════════════════════════════════════════════════
; Symbol: ⧉⊜ (macro-rules)
; Syntax: (⧉⊜ name ((pattern) template) ...)
;
; Pattern variables: symbols starting with $ (e.g., $x, $body)
; Literal keywords: any non-pattern-var symbols match exactly
; ═══════════════════════════════════════════════════════════════

; ═══════════════════════════════════════════════════════════════
; Section 1: Basic Pattern Matching
; ═══════════════════════════════════════════════════════════════

; Test 1: Simple single-pattern macro
(⧉⊜ inc1
  (($x) (⊕ $x #1)))

(⊨ :pattern-macro-simple #6 (inc1 #5))

; Test 2: Macro with two arguments
(⧉⊜ add-double
  (($x $y) (⊕ (⊗ $x #2) $y)))

(⊨ :pattern-macro-two-args #12 (add-double #5 #2))

; Test 3: Macro with three arguments
(⧉⊜ add3
  (($x $y $z) (⊕ $x (⊕ $y $z))))

(⊨ :pattern-macro-three-args #10 (add3 #2 #3 #5))

; ═══════════════════════════════════════════════════════════════
; Section 2: Multiple Pattern Clauses
; ═══════════════════════════════════════════════════════════════

; Test 4: Multi-clause - different arities
(⧉⊜ my-add
  (($x) $x)
  (($x $y) (⊕ $x $y))
  (($x $y $z) (⊕ $x (⊕ $y $z))))

(⊨ :multi-clause-one #5 (my-add #5))
(⊨ :multi-clause-two #7 (my-add #3 #4))
(⊨ :multi-clause-three #10 (my-add #2 #3 #5))

; Test 5: Pattern with specific arity selection
(⧉⊜ arity-test
  (($a) :one)
  (($a $b) :two)
  (($a $b $c) :three))

(⊨ :arity-one :one (arity-test #1))
(⊨ :arity-two :two (arity-test #1 #2))
(⊨ :arity-three :three (arity-test #1 #2 #3))

; ═══════════════════════════════════════════════════════════════
; Section 3: Literal Keyword Matching
; ═══════════════════════════════════════════════════════════════

; Test 6: Match literal keywords in pattern
(⧉⊜ kw-test
  ((:left $x) (⟨⟩ :l $x))
  ((:right $x) (⟨⟩ :r $x)))

(⊨ :kw-left (⟨⟩ :l #5) (kw-test :left #5))
(⊨ :kw-right (⟨⟩ :r #10) (kw-test :right #10))

; Test 7: Keyword in middle of pattern
(⧉⊜ between-kw
  (($x :to $y) (⟨⟩ $x $y)))

(⊨ :kw-middle (⟨⟩ #1 #10) (between-kw #1 :to #10))

; ═══════════════════════════════════════════════════════════════
; Section 4: Nested Patterns
; ═══════════════════════════════════════════════════════════════

; Test 8: Nested list patterns - extract from pair
(⧉⊜ extract-pair
  ((($a $b)) (⊕ $a $b)))

(⊨ :nested-extract #7 (extract-pair (#3 #4)))

; Test 9: Double nested - pattern ((($a))) matches (((#42)))
(⧉⊜ deep-extract
  (((($a))) $a))

(⊨ :deep-nested #42 (deep-extract ((#42))))

; ═══════════════════════════════════════════════════════════════
; Section 5: Template with Complex Expressions
; ═══════════════════════════════════════════════════════════════

; Test 10: Template with multiple uses of pattern var
(⧉⊜ double
  (($x) (⊕ $x $x)))

(⊨ :double-use #10 (double #5))

; Test 11: Template with nested expressions
(⧉⊜ complex-template
  (($x $y) (⊗ (⊕ $x #1) (⊖ $y #1))))

(⊨ :complex-templ #24 (complex-template #5 #5))

; Test 12: Template building a list
(⧉⊜ make-triple
  (($a $b $c) (⟨⟩ $a (⟨⟩ $b (⟨⟩ $c ∅)))))

(⊨ :make-triple-head #1 (◁ (make-triple #1 #2 #3)))
(⊨ :make-triple-second #2 (◁ (▷ (make-triple #1 #2 #3))))

; ═══════════════════════════════════════════════════════════════
; Section 6: Conditional Macros
; ═══════════════════════════════════════════════════════════════

; Test 13: When macro (single clause)
(⧉⊜ when2
  (($cond $body) (? $cond $body ∅)))

(⊨ :when-true #42 (when2 #t #42))
(⊨ :when-false ∅ (when2 #f #42))

; Test 14: Unless macro
(⧉⊜ unless2
  (($cond $body) (? $cond ∅ $body)))

(⊨ :unless-true ∅ (unless2 #t #42))
(⊨ :unless-false #42 (unless2 #f #42))

; ═══════════════════════════════════════════════════════════════
; Section 7: Hygiene Tests
; ═══════════════════════════════════════════════════════════════

; Test 15: Macro doesn't accidentally capture
(≔ x #100)
(⧉⊜ use-outer
  (($y) (⊕ $y x)))

(⊨ :hygiene-outer #105 (use-outer #5))

; Test 16: Pattern var shadows outer
(⧉⊜ shadow-x
  (($x) (⊗ $x #2)))

(⊨ :hygiene-shadow #10 (shadow-x #5))

; ═══════════════════════════════════════════════════════════════
; Section 8: Literal Matching in Patterns
; ═══════════════════════════════════════════════════════════════

; Test 17: Literal number matching in first position
(⧉⊜ literal-first
  ((#0 $x) :zero)
  ((#1 $x) :one)
  (($n $x) :other))

(⊨ :literal-zero :zero (literal-first #0 :ignored))
(⊨ :literal-one :one (literal-first #1 :ignored))
(⊨ :literal-other :other (literal-first #5 :ignored))

; Test 18: Literal in second position
(⧉⊜ literal-second
  (($x #0) (⟨⟩ $x :zero))
  (($x #1) (⟨⟩ $x :one))
  (($x $y) (⟨⟩ $x :other)))

(⊨ :literal-second-zero (⟨⟩ :a :zero) (literal-second :a #0))
(⊨ :literal-second-one (⟨⟩ :b :one) (literal-second :b #1))
(⊨ :literal-second-other (⟨⟩ :c :other) (literal-second :c #5))

; ═══════════════════════════════════════════════════════════════
; Section 9: Error Cases
; ═══════════════════════════════════════════════════════════════

; Test 19: No matching pattern (wrong arity)
(⧉⊜ fixed-arity
  (($x $y) (⊕ $x $y)))

(⊨ :no-match-arity #t (⚠? (fixed-arity #1)))

; ═══════════════════════════════════════════════════════════════
; Summary
; ═══════════════════════════════════════════════════════════════
(≋ "✓ 25 Pattern-based macros tests")
