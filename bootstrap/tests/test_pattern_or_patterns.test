;; Test Suite: Or-Patterns for Pattern Matching (Day 60)
;; Or-patterns match multiple alternatives (first match wins)
;; Syntax: (or pattern₁ pattern₂ ...)
;; Example: (or #0 #1 #2) matches 0, 1, or 2
;;
;; IMPORTANT: All alternatives must bind the same variables (or none)
;; This is standard in OCaml and Rust

;; ============================================================================
;; Basic Or-Patterns with Literals
;; ============================================================================

;; Test 1: Or-pattern with 2 alternatives - match first
;; Pattern: (or #0 #1)
;; Value: #0
;; Expected: Matches first alternative
(test-case :or-two-first
    :zero
    (match #0 (quote (((or #0 #1) :zero)
              (_ :other)))))

;; Test 2: Or-pattern with 2 alternatives - match second
;; Pattern: (or #0 #1)
;; Value: #1
;; Expected: Matches second alternative
(test-case :or-two-second
    :one
    (match #1 (quote (((or #0 #1) :one)
              (_ :other)))))

;; Test 3: Or-pattern with 2 alternatives - no match
;; Pattern: (or #0 #1)
;; Value: #2
;; Expected: Falls through to wildcard
(test-case :or-two-nomatch
    :other
    (match #2 (quote (((or #0 #1) :matched)
              (_ :other)))))

;; Test 4: Or-pattern with 3 alternatives
;; Pattern: (or #0 #1 #2)
;; Tests all three alternatives
(test-case :or-three-first
    :small
    (match #0 (quote (((or #0 #1 #2) :small)
              (_ :other)))))

(test-case :or-three-second
    :small
    (match #1 (quote (((or #0 #1 #2) :small)
              (_ :other)))))

(test-case :or-three-third
    :small
    (match #2 (quote (((or #0 #1 #2) :small)
              (_ :other)))))

;; Test 5: Or-pattern with 4+ alternatives
;; Pattern: (or #0 #1 #2 #3 #4)
(test-case :or-many-alternatives
    :digit
    (match #3 (quote (((or #0 #1 #2 #3 #4) :digit)
              (_ :other)))))

;; ============================================================================
;; Or-Patterns with Symbols and Booleans
;; ============================================================================

;; Test 6: Or-pattern with symbols
;; Pattern: (or :red :green :blue)
(test-case :or-symbols
    :primary
    (match :blue (quote (((or :red :green :blue) :primary)
                 (_ :other)))))

;; Test 7: Or-pattern with booleans
;; Pattern: (or #t #f)
(test-case :or-booleans-true
    :boolean
    (match #t (quote (((or #t #f) :boolean)
             (_ :other)))))

(test-case :or-booleans-false
    :boolean
    (match #f (quote (((or #t #f) :boolean)
             (_ :other)))))

;; ============================================================================
;; Or-Patterns with Pairs (Same Structure, Different Values)
;; ============================================================================

;; Test 8: Or-pattern with pair patterns (same structure)
;; Pattern: (or (cons #1 #2) (cons #3 #4))
;; Both alternatives bind no variables (all literals)
(test-case :or-pairs-first
    :pair-one
    (match (cons #1 #2) (quote (((or (cons #1 #2) (cons #3 #4)) :pair-one)
                       (_ :other)))))

(test-case :or-pairs-second
    :pair-two
    (match (cons #3 #4) (quote (((or (cons #1 #2) (cons #3 #4)) :pair-two)
                       (_ :other)))))

;; Test 9: Or-pattern with pair patterns with variables
;; Pattern: (or (cons #1 x) (cons #2 x))
;; Both alternatives bind variable x
(test-case :or-pairs-variables
    #10
    (match (cons #2 #10) (quote (((or (cons #1 x) (cons #2 x)) x)
                        (_ :other)))))

;; ============================================================================
;; Or-Patterns with ADTs
;; ============================================================================

;; Define Option ADT for tests
(adt-define :Option (quote (:None)) (quote (:Some :value)))

;; Test 10: Or-pattern with ADT - both alternatives bind nothing
;; Pattern: (or (adt-create :Option :None) (adt-create :Option :Some #42))
(test-case :or-adt-none
    :matched
    (match (adt-create :Option :None) (quote (((or (adt-create :Option :None) (adt-create :Option :Some #42)) :matched)
                              (_ :other)))))

(test-case :or-adt-some-specific
    :matched
    (match (adt-create :Option :Some #42) (quote (((or (adt-create :Option :None) (adt-create :Option :Some #42)) :matched)
                                  (_ :other)))))

;; Define Result ADT for tests
(adt-define :Result (quote (:Ok :value)) (quote (:Err :error)))

;; Test 11: Or-pattern matching specific Result values
;; Pattern: (or (adt-create :Result :Ok #0) (adt-create :Result :Ok #1))
(test-case :or-adt-specific-first
    :zero-ok
    (match (adt-create :Result :Ok #0) (quote (((or (adt-create :Result :Ok #0) (adt-create :Result :Ok #1)) :zero-ok)
                               (_ :other)))))

(test-case :or-adt-specific-second
    :one-ok
    (match (adt-create :Result :Ok #1) (quote (((or (adt-create :Result :Ok #0) (adt-create :Result :Ok #1)) :one-ok)
                               (_ :other)))))

;; Test 12: Or-pattern with ADT - both alternatives bind same variable
;; Pattern: (or (adt-create :Result :Ok v) (adt-create :Result :Err v))
;; Both bind variable v (different field, but same name)
(test-case :or-adt-same-variable
    #42
    (match (adt-create :Result :Ok #42) (quote (((or (adt-create :Result :Ok v) (adt-create :Result :Err v)) v)
                                (_ :other)))))

(test-case :or-adt-same-variable-err
    :failed
    (match (adt-create :Result :Err :failed) (quote (((or (adt-create :Result :Ok v) (adt-create :Result :Err v)) v)
                                     (_ :other)))))

;; ============================================================================
;; Or-Patterns Combined with Guards
;; ============================================================================

;; Test 13: Or-pattern with guard condition - bind variable
;; Pattern: ((or x x) | (> x #0))
;; Both alternatives bind same variable x, guard checks it's positive
;; Note: (or x x) is redundant but valid - demonstrates guard works
(test-case :or-guard-pass
    #42
    (match #42 (quote ((((or x x) | (> x #0)) x)
               (_ :failed)))))

;; Test 14: Or-pattern guard fails - negative value
(test-case :or-guard-fail
    :failed
    (match #-5 (quote ((((or x x) | (> x #0)) x)
               (_ :failed)))))

;; ============================================================================
;; Or-Patterns Combined with As-Patterns
;; ============================================================================

;; Test 15: Or-pattern combined with as-pattern
;; Pattern: whole@(or #0 #1 #2)
;; Binds whole value and matches alternatives
(test-case :or-as-pattern
    (cons #1 #1)
    (match #1 (quote (((whole @ (or #0 #1 #2)) (cons whole whole))
              (_ :other)))))

;; Test 16: As-pattern inside or-pattern alternatives
;; Pattern: (or (pair@(cons #1 #2)) (pair@(cons #3 #4)))
;; Both alternatives bind same variable name 'pair'
(test-case :as-inside-or-first
    (cons #1 #2)
    (match (cons #1 #2) (quote (((or (pair @ (cons #1 #2)) (pair @ (cons #3 #4))) pair)
                       (_ :other)))))

(test-case :as-inside-or-second
    (cons #3 #4)
    (match (cons #3 #4) (quote (((or (pair @ (cons #1 #2)) (pair @ (cons #3 #4))) pair)
                       (_ :other)))))

;; ============================================================================
;; Nested Or-Patterns
;; ============================================================================

;; Test 17: Nested or-patterns
;; Pattern: (or (or #0 #1) #2)
;; Outer or has two alternatives: inner or and #2
(test-case :nested-or-inner-first
    :matched
    (match #0 (quote (((or (or #0 #1) #2) :matched)
              (_ :other)))))

(test-case :nested-or-inner-second
    :matched
    (match #1 (quote (((or (or #0 #1) #2) :matched)
              (_ :other)))))

(test-case :nested-or-outer
    :matched
    (match #2 (quote (((or (or #0 #1) #2) :matched)
              (_ :other)))))

;; Test 18: Or-pattern in pair component
;; Pattern: (cons (or #1 #2) (or #3 #4))
(test-case :or-in-pair
    :matched
    (match (cons #1 #4) (quote (((cons (or #1 #2) (or #3 #4)) :matched)
                       (_ :other)))))

;; ============================================================================
;; Edge Cases
;; ============================================================================

;; Test 19: Or-pattern with wildcard alternatives
;; Pattern: (or _ _)
;; Both alternatives are wildcard (both bind nothing)
(test-case :or-wildcard
    :matched
    (match #999 (quote (((or _ _) :matched)
               (_ :never)))))

;; Test 20: Or-pattern with all same literal (redundant)
;; Pattern: (or #42 #42)
;; Both alternatives are same - tests first-match semantics
(test-case :or-redundant
    :matched
    (match #42 (quote (((or #42 #42) :matched)
               (_ :other)))))

;; Test 21: Or-pattern with nil
;; Pattern: (or nil nil)
(test-case :or-nil
    :empty
    (match nil (quote (((or nil nil) :empty)
             (_ :other)))))

;; ============================================================================
;; Real-World Examples
;; ============================================================================

;; Test 22: Arithmetic operator classification
;; Classify operators into groups
(test-case :realworld-operator-arithmetic
    :arithmetic
    (match :mul (quote (((or :add :sub :mul :div) :arithmetic)
                ((or :eq :ne :lt :gt) :comparison)
                (_ :unknown)))))

(test-case :realworld-operator-comparison
    :comparison
    (match :lt (quote (((or :add :sub :mul :div) :arithmetic)
               ((or :eq :ne :lt :gt) :comparison)
               (_ :unknown)))))

;; Test 23: State machine - match multiple valid states
;; Pattern: (or :idle :running :paused)
(test-case :realworld-state-machine
    :active
    (match :running (quote (((or :idle :running :paused) :active)
                    ((or :stopped :error) :inactive)
                    (_ :unknown)))))

;; Test 24: Multiple constant values
;; Pattern: (or #100 #200 #300)
(test-case :realworld-constants
    :valid
    (match #200 (quote (((or #100 #200 #300) :valid)
               (_ :invalid)))))
